<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VScode配置笔记</title>
    <url>/2022/02/20/22-32-35/</url>
    <content><![CDATA[<h2 id="vscode配置笔记">VScode配置笔记</h2>
<ol type="1">
<li><p>下载并安装编译器MinGW：https://bit.ly/mingw10</p></li>
<li><p>将MinGW的bin文件路径添加到系统环境变量中</p></li>
<li><p>在cmd中运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br></pre></td></tr></table></figure>
<p>检测是否成功配置路径</p></li>
<li><p>安装VScode：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p></li>
<li><p>“设置”中输入"run in terminal"<img src="/2022/02/20/22-32-35/image-20210907225325312.png" alt="image-20210907225325312"></p></li>
<li><p>安装插件”Code Runner“和”C/C++“；选装”Chinese (Simplified) Language Pack for Visual Studio Code“</p></li>
<li><p>为了正确地在文本编辑器上敲除中文，需要给文本编辑器设置合适的编码方式：<img src="/2022/02/20/22-32-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20210916093752004.png" alt="image-20210916093752004"></p>
<p>点红框，选择“通过编码重新打开”，输入编码方式即可。</p>
<p>打开cmd，查看“属性”可得知终端的编码方式</p>
<p><img src="/2022/02/20/22-32-35/image-20210916093952277.png" alt="image-20210916093952277" style="zoom:25%;"></p>
<p>终端的编码方式需要与编辑器的编码方式匹配</p>
<p>在终端输入：“chcp 65001”可以切换代码页到使用UTF8。</p></li>
<li><p>想要正确识别别人代码中的中文，需要“设置”中输入"<strong>files.autoGuessEncoding</strong>"<img src="/2022/02/20/22-32-35/image-20210907225635399.png" alt="image-20210907225635399"></p></li>
<li><p>设置自动保存：“设置“中输入”<strong>auto save</strong>“，选择"afterDelay"选项</p></li>
<li><p>設置自動格式化：“设置”中输入“<strong>editor.formatOnType</strong>”，选择True“</p></li>
<li><p>”ctrl+k“配合”ctrl+t“可快速切换主题</p></li>
<li><p>”ctrl+“是放大</p></li>
<li><p>单行注释：“Ctrl + /”；块注释：“Alt+Shift+A”</p></li>
<li><p>多文件编译：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#code in CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output in Chinese</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -fexec-charset=GB2312&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="补充终端shell命令">补充：终端（shell）命令</h2>
<p>不区分大小写。</p>
<p>tab键补全内容，再次点击切换内容</p>
<h3 id="文件跳转">文件跳转</h3>
<p>磁盘跳转</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:</span></span><br></pre></td></tr></table></figure>
<p>显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
<p>树形显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>
<p>进入下一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件名（有空格的夹引号，平时使用tab补全就好）</span><br></pre></td></tr></table></figure>
<p>进入上一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd..</span><br></pre></td></tr></table></figure>
<p>退回磁盘根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/11/16-23-37/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Homework</title>
    <url>/2022/02/24/11-07-35/</url>
    <content><![CDATA[<h2 id="homework">Homework</h2>
<h3 id="home-work">1-Home work</h3>
<p>1.d 2.c 3.a 4.a</p>
<h3 id="home-work-1">2-Home work</h3>
<p>1.b 2.c</p>
<ol start="3" type="1">
<li>Differentiate between insulator, semiconductor and conductor?
<ul>
<li>Insulator : Don't allow the current to pass through.</li>
<li>Semiconductor : have a conductivity between conductors and insulators.</li>
<li>Condctior : Allow the current and heat to pass through.</li>
</ul></li>
<li>What is forbidden energy gap?
<ul>
<li>The bandgap btewenn conduction band and valence band is called forbidden energy gap.</li>
</ul></li>
<li>How does the band gap indicate whether or not your substance is an insulator, semiconductor or conductor?
<ul>
<li>The bandgap of the insulator is very high;</li>
<li>The bandgap of the semiconductor is low;</li>
<li>There is no band gap in the conductor</li>
</ul></li>
</ol>
<h3 id="home-work-2">3-Home work</h3>
<ol type="1">
<li><p>Define doping?</p>
<ul>
<li>The process by which an impurity is added to a semiconductor is known as Doping.</li>
</ul></li>
<li><p>What is difference between a pentavalent atom and a trivalent impurity?</p>
<ul>
<li>They have different numbers of outermost electrons.</li>
<li>Pentavalent atoms have 5 valence electrons; Trivalent atoms have 3 valence electrons.</li>
</ul></li>
<li><p>How is an n-type semiconductor formed? Is N-type material electrically neutral? Comment.</p>
<ul>
<li>N-type semiconductors are formed by adding pentavalent impurity.</li>
<li>N-type material is electrically neutral.</li>
</ul></li>
<li><p>How is an p-type semiconductor formed?</p>
<ul>
<li>N-type semiconductors are formed by adding trivalent impurity.</li>
</ul></li>
<li><p>What is difference between intrinsic and extrinsic semiconductor?</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
</ul></li>
<li><p>c</p></li>
</ol>
<h3 id="home-work-3">4-Home work</h3>
<ol type="1">
<li>Calculate.</li>
<li>Calculate.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-4">5-Home work</h3>
<ol type="1">
<li><p>Calculate.</p></li>
<li><p>Describe the Avalanche and Zener breakdown mechanism in diode.</p>
<ul>
<li><p>Avalanche breakdown:</p>
<p>If high reverse bias voltage is applied to a lightly doped diode, then the minority carriers will move to the PN junction with high velocity and collide with atoms in the depletion region and break the covalent bond.This cumulative process eventually leads current increase suddenly in the device. The phenomena is called avalanche breakdown.</p></li>
<li><p>Zener breakdown:</p>
<p>The depletion width in heavily doped diodes is very narrow, which develops high electric field across the depletion region under reverse voltage. In this case, the covalent bond is disrupted in the depletion region and more and more electrons are liberated. So the current increases repidly in the diode. The phenomena is called Zener breakdown.</p>
<p>The depletion widthe is very narrow in heavily doped diodes, resulting in a large electric field in the depletion region when reverse voltage is applied</p></li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Differentiate between Zener diode and PN junction normal diode. Also, explain how Zener breakdown differs from Avalanche breakdown.</p>
<ul>
<li><p>Compared with ordinary diodes, Zener diodes are heavily doped diodes, and Zener diodes work in the state of reverse breakdown.</p></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>lightly doped.</li>
<li>Depletion width is wide.</li>
<li>Electric field is weaker in the depletion region as compared to Zener breakdown.</li>
<li>Breakdown voltage is more than 8 V.</li>
<li>Avalanche breakdown occurs due to collision of electron with atoms in the depletion region.</li>
</ol></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>highly doped.</li>
<li>Depletion width is thin.</li>
<li>Electric field is stronger in the depletion region as compared to Avalanche breakdown.</li>
<li>Breakdown voltage is between 5V to 8V.</li>
<li>Zener breakdown occurs Due to rupture of covalent bond in the depletion region since electric field is very strong.</li>
</ol></li>
</ul></li>
</ol>
<h3 id="home-work-5">6-Home work</h3>
<ol type="1">
<li>Draw:
<ul>
<li><span class="math inline">\(AC \Rightarrow Transform \Rightarrow Rectifier \Rightarrow Filter \Rightarrow Regulator \Rightarrow DC\)</span></li>
</ul></li>
<li>Explain the basic circuit operation of half wave rectifier.
<ul>
<li>In half wave rectifier circuit, when the AC voltage is positive, the diode is forward biased so the current will pass through the circuit. when the AC voltage is negatve, the diode is reverse biased and the current can't pass through the circuit. Hence only positive half of the signal can pass through the circuit and the other half is zero.</li>
</ul></li>
<li>Calcution.</li>
</ol>
<h3 id="home-work-6">7-Home work</h3>
<ol type="1">
<li>Why half-wave rectifiers are generally not used in dc power supply？
<ul>
<li>Its efficiency is low and its ripple factor is high.</li>
</ul></li>
<li>Define ripple in a rectifier circuit.
<ul>
<li>The AC harmonics in DC are called ripple. And we have full wave rectifier as an substitute.</li>
</ul></li>
<li>Calculate.</li>
<li>Draw.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-7">8-Home work</h3>
<ol type="1">
<li>What are the bias voltage that need to be applied to an NPN transistor such that the transistor is biased in the forward active mode？
<ul>
<li>The input voltage should exceed cut-in voltage and make transisitor biased in the forward active region.</li>
</ul></li>
<li>What is the necessity of biasing a transistor circuit.State different types.
<ul>
<li>To achieve faithful amplification, the input voltage should exceed cut-in voltage and the transistor should be in the active region, so we need biasing to set the operating point.</li>
<li>Fixed bias, Emitter bias, collector feedback bias and voltage divider bias.</li>
</ul></li>
<li>Define common base,common emitter and common current gain.
<ul>
<li>Equation.</li>
</ul></li>
<li>Define the Parameters that define a load line.define Q-point and it's significance in details. （i）Q-point region near cut off point （ii）Q-point near saturation region （iii）Q-point in the middle of the load line
<ul>
<li>The load line is jointly determined by Vcc and Rc, and the Q point is at the midpoint of the load line</li>
<li>if the Q point is close to the saturation area or the cut-off area, the output signal will be clipped</li>
<li>and if it is in the amplification area, a stable waveform can be output</li>
</ul></li>
<li>Mention the parameters that can cause shift in Q point in transistor circuit.
<ul>
<li><span class="math inline">\(I_B\)</span> and <span class="math inline">\(R_C\)</span></li>
</ul></li>
<li>Define Thermal Runaway in transistor and how to mitigate
<ul>
<li>Negative feedback and heat sink.</li>
</ul></li>
</ol>
<h2 id="assignment">Assignment</h2>
<ol type="1">
<li><p>Define intrinsic and extrinsic semiconductor. Also describe need of trivalent and pentavalent imurities in semiconductor.</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
<li>N-type semiconductors are formed by adding pentavalent imurities and P-type semiconductors are formed by adding trivalent imurities.</li>
</ul></li>
<li><p>Explain P-N junction under no-bias, forward bias and reverse bias conditions.</p>
<ul>
<li>The concentration gradient lets the PN junction forms a diffusion current, resulting in a built-in electric field. When the built-in electric field and the concentration gradient reach equilibrium, the diffusion stops and a depletion layer is formed.</li>
<li>When the PN junction is forward biased, the depletion width reduce and the balance between the built-in electric field and the concentration gradient is destroyed. The diffusion current continues to flow from the N-side to the P-side.</li>
<li>When the PN junction is reverse biased, the depletion width increase and diffusion current is further suppressed. Only drift current exists when reverse biased.</li>
</ul></li>
<li><p>Define Knee voltage, reverse saturation current and Breakdown voltage.</p>
<ul>
<li>Knee voltage: The forword bias voltage at which current increase through diode rapidly.</li>
<li>Reverse saturation current: Current due to minority carrier drift during reverse bias.</li>
<li>Breakdown voltage: The reverse bias voltage at which current increase through diode rapidly.</li>
</ul></li>
<li><p>Explain the basic concept of mass-action law in semiconductor and <strong>Calculate</strong>.</p>
<ul>
<li>The product of electron and hole concentrations in thermal equilibrium is equal to the square of the intrinsic carrier concentration</li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Describe the current flow mechanism in NPN transistor. Also compare the input and output characteristics of C-B,C-E and C-C.</p>
<ul>
<li><p>Transistor is used as an amplofying device when EB is forward biased and CB is reverse biased. When EB is forward biased, the electrons move from E into C through B, which formed the emitter current. The hole move from B into E and the hole move from wire into the B formed the base current. The electrons move form E into the C and the reverse current due to the reverse bias of CB formed the collector current.</p></li>
<li><table>
<thead>
<tr class="header">
<th></th>
<th>CB</th>
<th>CC</th>
<th>CE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入电阻</td>
<td>minimum</td>
<td>maximum</td>
<td>medium</td>
</tr>
<tr class="even">
<td>输出电阻</td>
<td>same to CE</td>
<td>minimum</td>
<td>same to CB</td>
</tr>
<tr class="odd">
<td>放大情况</td>
<td>only amplified voltage</td>
<td>only amplified current</td>
<td>both</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>What is the necessity of biasing in a transistor. State different types biasing in detail.</p>
<ul>
<li>Find operating points for faithful amplification.</li>
<li>Fixed bias:
<ul>
<li>include R_B, R_C and V_{CC}, simple but unstable.</li>
</ul></li>
<li>Emitter bias:
<ul>
<li>Introduce an additional R_E and makes it more stable.</li>
</ul></li>
<li>Voltage divider bias:
<ul>
<li>A voltage divider resistor is used for a more stable effect.</li>
</ul></li>
</ul></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><ol type="a">
<li>Explain the basic construction, operation and characteristics of N-channel JFET. Also explain the input and output transfer characteristics. If we apply positive VGS to the JFET what will happen with the device?</li>
<li>Draw.</li>
</ol>
<ul>
<li>The main body of an n-channel JFET is an N-type semiconductor, and P-type semiconductors are embedded on both sides to form an n-channel. The top of the N-channel is the drain, the bottom is the source, and the left and right P-type semiconductors are connected to the gate.</li>
<li>The gate controls the voltage across this drain and source</li>
<li>The most important feature is the high input impedance</li>
</ul></li>
<li><p>Compare BJT and JFET.</p>
<ul>
<li><table>
<thead>
<tr class="header">
<th>比较内容</th>
<th>BJT</th>
<th>JFET</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>construction</td>
<td>NPN &amp; PNP</td>
<td>N-channal &amp; P-channal</td>
</tr>
<tr class="even">
<td>current carrier</td>
<td>majorities diffusion<br>minorities drift</td>
<td>majorities diffusion</td>
</tr>
<tr class="odd">
<td>Input</td>
<td>current</td>
<td>voltage</td>
</tr>
<tr class="even">
<td>contralled virable</td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(g_m\)</span></td>
</tr>
<tr class="odd">
<td>sensitivity to the temperature</td>
<td>high</td>
<td>low</td>
</tr>
<tr class="even">
<td>stability</td>
<td>bad</td>
<td>good</td>
</tr>
<tr class="odd">
<td>input resistance</td>
<td>small</td>
<td>large</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><ol type="a">
<li>Describe the operation and charcteristics of the inverting and Non-inverting amplifier.</li>
<li>Draw.</li>
</ol>
<ul>
<li>The amplifier which has 180 degrees out of phase output with respect to input is known as an inverted amplifier,</li>
<li>whereas the amplifier which has the o/p in phase with respect to i/p is known as a non-inverting amplifier.</li>
</ul></li>
<li><p>What is the concept of virtual ground?</p>
<ul>
<li>A node of a circuit that is maintained at a steady reference potential, without being connected directly to the reference potential.</li>
</ul></li>
</ol>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/29/16-12-02/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">clc; </span><br><span class="line">close all; </span><br><span class="line">clear all; </span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;);%要求你.m文件下有test.bmp这个图像文件 </span><br><span class="line">PR=I(:,:,1);%提取红色分量 </span><br><span class="line">PG=I(:,:,2);%提取绿色分量 </span><br><span class="line">PB=I(:,:,3);%提取蓝色分量 </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(PR);title(&#x27;提取红分量后&#x27;); </span><br><span class="line">subplot(2,2,3);imshow(PG);title(&#x27;提取绿色分量后&#x27;); </span><br><span class="line">subplot(2,2,4);imshow(PB);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;); </span><br><span class="line">[m,n,d]=size(I); </span><br><span class="line"> </span><br><span class="line">level=15;%设置阈值 </span><br><span class="line">level2=70;%设置阈值 </span><br><span class="line"> </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,1)-I(i,j,2)&gt;level2)&amp;&amp;(I(i,j,1)-I(i,j,3)&gt;level2)) </span><br><span class="line">            r(i,j,1)=I(i,j,1); </span><br><span class="line">            r(i,j,2)=I(i,j,2); </span><br><span class="line">            r(i,j,3)=I(i,j,3); </span><br><span class="line">       else  </span><br><span class="line">            r(i,j,1)=255; </span><br><span class="line">            r(i,j,2)=255; </span><br><span class="line">            r(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(r);title(&#x27;提取红分量后&#x27;);%显示提取红分量后的图 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取绿分量，不满足阈值的变为白色 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,2)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,2)-I(i,j,3)&gt;level)) </span><br><span class="line">            g(i,j,1)=I(i,j,1); </span><br><span class="line">            g(i,j,2)=I(i,j,2); </span><br><span class="line">            g(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            g(i,j,1)=255; </span><br><span class="line">            g(i,j,2)=255; </span><br><span class="line">            g(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,3);imshow(g);title(&#x27;提取绿分量后&#x27;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取蓝色分量 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,3)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,3)-I(i,j,2)&gt;level)) </span><br><span class="line">                    b(i,j,1)=I(i,j,1); </span><br><span class="line">                    b(i,j,2)=I(i,j,2); </span><br><span class="line">                    b(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            b(i,j,1)=255; </span><br><span class="line">            b(i,j,2)=255; </span><br><span class="line">            b(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,4);imshow(b);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%清空变量，读取图像</span></span><br><span class="line">RGB = imread(<span class="string">&#x27;2019050913413134.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;process&#x27;</span>),</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(RGB),title(<span class="string">&#x27;原始RGB&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%convert frame from RGB to YCBCR colorspace（转换到YCBCR空间）</span></span><br><span class="line">YCBCR = rgb2ycbcr(RGB);</span><br><span class="line">whos,</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(YCBCR),title(<span class="string">&#x27;YCBCR&#x27;</span>),</span><br><span class="line"><span class="comment">%filter YCBCR image between values and store filtered image to threshold</span></span><br><span class="line"><span class="comment">%matrix（用各个通道的阈值对其进行二值化处理）</span></span><br><span class="line">Y_MIN = <span class="number">0</span>;  Y_MAX = <span class="number">256</span>;</span><br><span class="line">Cb_MIN = <span class="number">100</span>;   Cb_MAX = <span class="number">127</span>;</span><br><span class="line">Cr_MIN = <span class="number">138</span>;   Cr_MAX = <span class="number">170</span>;</span><br><span class="line">threshold=roicolor(YCBCR(:,:,<span class="number">1</span>),Y_MIN,Y_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">2</span>),Cb_MIN,Cb_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">3</span>),Cr_MIN,Cr_MAX);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(threshold),title(<span class="string">&#x27;YCBCR二值化&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%perform morphological operations on thresholded image to eliminate noise</span></span><br><span class="line"><span class="comment">%and emphasize the filtered object(s)（进行形态学处理：腐蚀、膨胀、孔洞填充）</span></span><br><span class="line">erodeElement = strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">3</span>) ;</span><br><span class="line">dilateElement=strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">8</span>) ;</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imfill(threshold,<span class="string">&#x27;holes&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(threshold),title(<span class="string">&#x27;形态学处理&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%获取区域的&#x27;basic&#x27;属性， &#x27;Area&#x27;, &#x27;Centroid&#x27;, and &#x27;BoundingBox&#x27; </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;处理结果&#x27;</span>),</span><br><span class="line">stats = regionprops(threshold, <span class="string">&#x27;basic&#x27;</span>);</span><br><span class="line">[C,area_index]=<span class="built_in">max</span>([stats.Area]);</span><br><span class="line"><span class="comment">%定位脸部区域</span></span><br><span class="line">face_locate=[stats(area_index).Centroid(<span class="number">1</span>),stats(area_index).Centroid(<span class="number">2</span>)];</span><br><span class="line">imshow(RGB);title(<span class="string">&#x27;after&#x27;</span>),<span class="built_in">hold</span> on</span><br><span class="line">text(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>)<span class="number">-40</span>,  <span class="string">&#x27;face&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>), <span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[stats(area_index).BoundingBox],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>信号与系统</title>
    <url>/2022/02/27/16-42-18/</url>
    <content><![CDATA[<h2 id="信号">信号</h2>
<h3 id="常见的奇异信号">常见的奇异信号</h3>
<p>奇异信号：函数中包含不连续点或其微分与积分有不连续点的函数，统称为奇异函数，也就是奇异信号。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>函数表达式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f(t)\)</span>：单位斜变信号</td>
<td><span class="math inline">\(f(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ t &amp; t\ge0 \\ \end{cases}\)</span></td>
</tr>
<tr class="even">
<td>$ u(t)$：单位阶跃信号</td>
<td><span class="math inline">\(u(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ 1 &amp; t&gt;0 \\ \end{cases}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</td>
<td><span class="math inline">\(\begin{cases} \begin{aligned} &amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\ &amp;\delta(t) = 0\quad while(t\not=0) \end{aligned} \end{cases}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</td>
<td><span class="math inline">\(\delta(t)&#39;=\frac{d\delta(t)}{dt}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="ft单位斜变信号"><span class="math inline">\(f(t)\)</span>：单位斜变信号</h4>
<p>单位斜变信号的“单位”体现在其非零部分的斜率为 <span class="math inline">\(1\)</span> 。</p>
<p>函数表达式： <span class="math display">\[
f(t) = 
\begin{cases}
0 &amp;     t&lt;0     \\\\
t &amp;     t\ge0   \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后： <span class="math display">\[
f(t-t_0) = 
\begin{cases}
0       &amp;       t&lt;t_0           \\\\
t-t_0   &amp;       t\ge t_0        \\
\end{cases}
\]</span></p>
<h4 id="ut单位阶跃信号">$ u(t)$：单位阶跃信号</h4>
<p>函数表达式：</p>
<p>由表达式可知 <span class="math inline">\(t=0\)</span> 处函数未定义，可以将 <span class="math inline">\(t=0\)</span> 处函数值定义为 <span class="math inline">\(u(0)=\frac{1}{2}\)</span>。 <span class="math display">\[
u(t) = 
\begin{cases}
0   &amp;       t&lt;0     \\\\
1   &amp;       t&gt;0     \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后（或认为阶跃延时 <span class="math inline">\(t\)</span> 后），有： <span class="math display">\[
u(t-t_0) = 
\begin{cases}
0   &amp;       t&lt;t_0       \\\\
1   &amp;       t&gt;t_0       \\
\end{cases}
\]</span></p>
<h4 id="deltat单位冲激函数"><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</h4>
<p>狄拉克（Dirac）定义方式： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\
&amp;\delta(t) = 0\quad while(t\not=0)
\end{aligned}
\end{cases}
\]</span> 狄拉克（Dirac）定义表明：</p>
<ol type="1">
<li>除了坐标轴零点处，其余位置单位冲激函数的函数值均为 <span class="math inline">\(0\)</span> 。</li>
<li>单位冲激函数仅在一点处取值，而其面积（积分）为 <span class="math inline">\(1\)</span> ，由此可知单位冲激函数为长度为 <span class="math inline">\(1\)</span> 的线段：表示中我们使用长度为 <span class="math inline">\(1\)</span> 的向量来表示，方向与 <span class="math inline">\(y\)</span> 轴正半轴方向相同。</li>
</ol>
<h4 id="deltat冲激偶函数"><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</h4>
<p>由符号可知冲激偶函数为冲激函数的导数。</p>
<h4 id="常见奇异信号之间的关系">常见奇异信号之间的关系：</h4>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{df(t)}{dt}=u(t)\\\\
&amp;\frac{du(t)}{dt}=\delta(t)\\\\
&amp;\delta(t)&#39;=\frac{d\delta(t)}{dt}
\end{aligned}
\end{cases}
\]</span></p>
<h4 id="单位冲激函数-deltat-的简单性质">单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 的简单性质：</h4>
<ol type="1">
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 具有<strong>抽样特性</strong>（也称“筛选”特性），<span class="math inline">\(\delta(t)\)</span> 可以用来筛选出信号中某一时刻的值（函数值），具体操作如下： <span class="math display">\[
\int_{-\infty}^{\infty}\delta(t-t_0)f(t)dt=f(t_0)
\]</span> 解释：对于任意一个信号 <span class="math inline">\(f(t)\)</span> ，我们使用 <span class="math inline">\(\delta(t)\)</span> 可以筛选出目标的函数值 <span class="math inline">\(f(t_0)\)</span> 。</p></li>
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 是一个偶函数，即 <span class="math inline">\(\delta(t)=\delta(-t)\)</span></p></li>
</ol>
<h3 id="线性时不变系统lti">线性时不变系统——LTI</h3>
<ol type="1">
<li><p>理解线性：</p>
<ol type="1">
<li>满足叠加性和均匀性</li>
</ol></li>
<li><p>理解时不变特性：即系统本身的参数不随时间发生改变</p></li>
<li><p>线性时不变系统还具有的特性：</p>
<ol type="1">
<li><p>微分特性：微分特性由线性和时不变性共同得出，内容为：</p>
<p>若激励信号 <span class="math inline">\(e(t)\)</span> 可使系统产生响应信号 <span class="math inline">\(r(t)\)</span>，则</p>
<ul>
<li>激励 <span class="math inline">\(\frac{de(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{dr(t)}{dt}\)</span></li>
<li>激励 <span class="math inline">\(\frac{d^2e(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{d^2r(t)}{dt}\)</span>，其余高阶求导同理</li>
<li>激励 <span class="math inline">\(\int^t_0e(\tau)d\tau\)</span> 可产生响应 <span class="math inline">\(\int^t_0r(\tau)d\tau\)</span></li>
</ul></li>
<li><p>因果特性：因果特性描述了激励信号与响应信号之间的联系，因果特性表明：<span class="math inline">\(t_0\)</span> 时刻的响应只与<span class="math inline">\(t=t_0\)</span> 和 <span class="math inline">\(t&lt;t_0\)</span> 时刻的输入有关，即激励和响应有着因果关系，只有有激励才会有响应。</p></li>
</ol></li>
</ol>
<h3 id="分析lti">分析LTI</h3>
<p>系统建模就是使用数学工具例如方程或者微分方程来建立模型。</p>
<ol type="1">
<li>系统的数学描述方法可以分为两大类：</li>
</ol>
<ul>
<li>输入输出描述法——该方法注重系统激励和响应之间的关系，不关心系统内部变量情况
<ul>
<li>这种方法在数学上表现为一元<span class="math inline">\(n\)</span>阶微分方程</li>
</ul></li>
<li>状态变量描述法
<ul>
<li>可以给出系统响应</li>
<li>提供系统内部各变量的情况</li>
<li>可以用于多输入多输出系统的分析</li>
<li>这种方法在数学上表现为<span class="math inline">\(n\)</span>元联立一阶微分方程</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>使用数学方法描述了一个系统后，我们就需要一些求解方法来求解系统模型，求解方法大体上也可以分为两类：</li>
</ol>
<ul>
<li>时域分析——时域分析是指在时间域上分析系统；前文可知系统可以简单理解为一个以时间为自变量的函数或函数族，时间域分析就是直接分析这个以时间变量作为自变量的函数。
<ul>
<li>时域分析分析输入输出法描述的系统模型时：
<ul>
<li>可以使用经典的常系数微分方程和差分方程</li>
<li>也可以使用算子符号来简化上面的微分方程和差分方程</li>
<li>卷积是分析线性系统时域的重要数学工具</li>
</ul></li>
<li>时域分析分析状态变量法描述的系统模型时：
<ul>
<li>需要求解矩阵方程</li>
</ul></li>
</ul></li>
<li>变换域分析——变换域是指将时变函数中的自变量：时间变量变换成其他变量函数。变换域分析使得时域分析中复杂的微分积分运算变成了代数运算，将复杂的卷积运算变成了乘法运算</li>
</ul>
<h3 id="电系统的lti数学模型建立">电系统的LTI数学模型建立</h3>
<p>构成电系统的LTI模型表现为微分方程式</p>
<p>构成此类方程式的依据是电系统网络的两类约束特性：</p>
<ul>
<li>电元器件约束特性——电子元器件的伏安特性
<ul>
<li>欧姆定律：
<ul>
<li><span class="math inline">\(V_R(t)=Ri_R(t)\)</span></li>
<li><span class="math inline">\(V_L(t)=L\frac{di(t)}{dt}\)</span></li>
<li><span class="math inline">\(V_C(t)=\frac{1}{C}\int_{-\infty}^ti_C{(\tau)}d\tau\)</span></li>
</ul></li>
</ul></li>
<li>网络拓扑结构——网络结构决定的电流电压关系
<ul>
<li>基尔霍夫定律：
<ul>
<li><span class="math inline">\(\sum i(t)=0\)</span></li>
<li><span class="math inline">\(\sum v(t)=0\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>线性时不变系统的时域分析，微分方程的一般形式： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 上式可以缩写为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 特殊形式，例如我们可以整理约束关系得到下式： <span class="math display">\[
\frac{d^3r(t)}{dt^3}+7\frac{d^2r(t)}{dt^2}+16\frac{dr(t)}{dt}+12r(t)=e(t)
\]</span> 微分方程的全解由齐次解 <span class="math inline">\(r_h(t)\)</span> 和特解 <span class="math inline">\(r_h(t)\)</span> )组成，即： <span class="math display">\[
r(t)=r_h(t)+r_h(t)
\]</span> 解法：</p>
<ol type="1">
<li>求齐次解 <span class="math inline">\(r_h(t)\)</span>：</li>
</ol>
<ul>
<li><p>令 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0\)</span>，该式称为齐次方程</p></li>
<li><p>将 <span class="math inline">\(r(t)=Ae^{\alpha t}\)</span> 代入齐次方程得 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\alpha^{i}=0\)</span>，称为特征方程</p></li>
<li><p>根据特征方程可以得齐次解 <span class="math inline">\(r_h(t)\)</span> 为</p>
<ul>
<li><p>特征方程没有重根：<img src="/2022/02/27/16-42-18/image-20220326234840139-16483097818622.png" alt="image-20220326234840139" style="zoom: 40%;"></p></li>
<li><p>特征方程有重根：<img src="/2022/02/27/16-42-18/image-20220326234918784-16483097790591.png" alt="image-20220326234918784" style="zoom: 40%;"></p></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>求特解 <span class="math inline">\(r_h(t)\)</span>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>激励函数 <span class="math inline">\(e(t)\)</span></th>
<th>响应函数 <span class="math inline">\(r(t)\)</span> 的特解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E\)</span></td>
<td><span class="math inline">\(B\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^p\)</span></td>
<td><span class="math inline">\(B_1t^p+B_2t^{p-1}+···+B_pt+B_{p+1}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(e^{\alpha t}\)</span></td>
<td><span class="math inline">\(Be^{\alpha t}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(cos(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(sin(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^pe^{\alpha t}cos(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(t^pe^{\alpha t}sin(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>求待定系数 <span class="math inline">\(A\)</span>：</p></li>
</ol>
<h3 id="拉普拉斯变换">拉普拉斯变换</h3>
<p>形态上，拉普拉斯变换做了这样一件事： <span class="math display">\[
f(t)\xrightarrow{\sf{拉普拉斯变换}}F(s)
\]</span> 或者说： <span class="math display">\[
f(t)\xrightarrow{\mathscr{L}\{f(t)\}}F(s)
\]</span> 从形态上讲，拉普拉斯变换将一个以时间 <span class="math inline">\(t\)</span> 为自变量的函数变换成了一个以频率 <span class="math inline">\(s\)</span> 为自变量的函数。</p>
<p>拉普拉斯变换将函数从时域变换到了频域，其实就是信号的自变量发生了变化。</p>
<p>意义：拉普拉斯变换可以将时域内的微分方程变换成频域内的代数方程，降低计算难度并且从频域再次回到时域时保证解不变。</p>
<p><span class="math inline">\(\mathscr{L}\{f(t)\}\)</span> 拉氏变换的定义为： <span class="math display">\[
\mathscr{L}\{f(t)\}=\int_{0}^{\infty}f(t)\cdot e^{-st}dt
\]</span> 注意事项：</p>
<ol type="1">
<li>进行拉氏变换的 <span class="math inline">\(f(t)\)</span> 是否存在的问题：
<ul>
<li>首先是初等函数都能进行拉氏变换</li>
<li>默认在线性电路分析中均使用能够进行拉氏变换的电源进行系统的激励</li>
</ul></li>
<li>上述拉氏变换也可以称作单边拉氏变换，此变换忽略了 <span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span></li>
<li><span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span> 可以通过初始条件来考虑</li>
</ol>
<p>分类：</p>
<p>学习拉普拉斯变换将拉普拉斯变换分为函数变换和算子变换</p>
<ul>
<li>函数变换：研究初等函数的拉氏变换</li>
<li>算子变换：研究一般函数的拉氏变换</li>
</ul>
<h4 id="算子变换">算子变换：</h4>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>拉氏变换</th>
<th><span class="math inline">\(\mathscr{L}\{f(t)\}=F(s)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乘以常数</td>
<td><span class="math inline">\(\mathscr{L}\{Kf(t)\}=KF(s)\)</span></td>
</tr>
<tr class="even">
<td>加减运算</td>
<td><span class="math inline">\(\mathscr{L}\{f(t_1)+f(t_2)-f(t_3)\}=F(s_1)+F(s_2)-F(s_3)\)</span></td>
</tr>
<tr class="odd">
<td>微分运算</td>
<td>一重微分：<span class="math inline">\(\mathscr{L}\{\frac{df(t)}{dt}\}=sF(s)-f(0^-)\)</span><br><span class="math inline">\(n\)</span> 重微分：<span class="math inline">\(\mathscr{L}\{\frac{d^nf(t)}{dt^n}\}=s^nF(s)-s^{n-1}f(0^-)-\sum_{i=2}^{n}s^{n-i}\frac{d^{i-1}f(0^-)}{dt^{i-1}}\)</span></td>
</tr>
<tr class="even">
<td>积分运算</td>
<td><span class="math inline">\(\mathscr{L}\{\int_{0^-}^{t}f(t)dt\}=F(s)/s\)</span></td>
</tr>
<tr class="odd">
<td>时域平移特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(t-a)\cdot u(t-a)\}=e^{-as}\cdot F(s),\quad a&gt;0\)</span><br><span class="math inline">\(\mathscr{L}\{e^{-as}\cdot F(s)\}=F(s+a)\)</span></td>
</tr>
<tr class="even">
<td>尺度变换特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(at)\}=\frac{1}{a}F\left(\frac{s}{a}\right),\quad a&gt;0\)</span></td>
</tr>
</tbody>
</table>
<h3 id="傅里叶分析简介">傅里叶分析简介</h3>
<p>傅里叶定理表明，任何一个角频率为<span class="math inline">\(\omega_0\)</span>的周期函数都可以表示为无穷多个频率为<span class="math inline">\(\omega_0\)</span>整数倍的正弦函数与余弦函数之和。</p>
<p>对于一个周期函数<span class="math inline">\(f(t)\)</span>，若满足Dirichlet条件，则该周期函数可以展开成傅里叶级数，即： <span class="math display">\[
\begin{aligned}
    &amp;if\quad f(t)=f(t+T)\\\\
    &amp;then\quad f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) +  \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
        &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
    &amp;if \quad f(t)=f(-t)\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\;\,\\\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
        &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=0 \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p>展开式中<span class="math inline">\(a_0\)</span>称为直流分量，其值等于函数<span class="math inline">\(f(t)\)</span>的平均值；<span class="math inline">\(a_n\)</span>与<span class="math inline">\(b_n(n\not=0)\)</span>是交流分量的幅值 <span class="math display">\[
f(t)=f(t+T)\Rightarrow
f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) + \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
\]</span></p>
<p><span class="math display">\[
\begin{array}{c|c|c}
    \begin{aligned}
    &amp;general\quad condition\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
            &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
            &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) sin(n\omega_0t) \,dt \\
        \end{aligned}
    }
    \end{aligned}
    &amp;
    \begin{aligned}
        &amp;if \quad f(t)=f(-t)\\
        &amp;\boxed
        {
            \begin{aligned}
                &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
                &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
                &amp;b_n=0 \\
            \end{aligned}
}
    \end{aligned}
    &amp; 
    \begin{aligned}
    &amp;if \quad f(t)=-f(-t)\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=0\\
            &amp;a_n=0\\
            &amp;b_n=\frac{4}{T}\int^{T/2}_{0} f(t) sin(n\omega_0t) \,dt  \\
        \end{aligned}
}
    \end{aligned}\\
\end{array}\\
\]</span></p>
<p><span class="math display">\[
P_{1\Omega}=F_{rms}^2=a_0^2+\frac{1}{2}\displaystyle\sum_{n=1}^{\infty}(a_n^2+b_n^2)
\]</span></p>
<p>线性系统：</p>
<p>线性系统是指具有叠加性和均匀性的系统：</p>
<ul>
<li>叠加性：多个激励同时作用时产生的响应 = 多个激励分别作用时产生的响应的和</li>
<li>均匀性：输入增益于输出增益相同</li>
</ul>
<p><span class="math display">\[
v_R(t)=Ri_R(t)\\
v_L(t)=L\frac{i_L(t)}{dt}\\
v_C(t)=\frac{1}{C}\int_{-\infty}^{t}i_C(\tau)d\tau
\]</span></p>
<p><span class="math display">\[
V_L(t)+V_R(t)+V_C(t)=e(t)\\
L\frac{i_L(t)}{dt}+Ri_R(t)+\frac{1}{C}\int_{-\infty}^{t}i_C(\tau)d\tau=e(t)\\
L\frac{d^2i_L(t)}{dt^2}+R\frac{di_R(t)}{dt}+\frac{1}{C}i_C(t)=\frac{de(t)}{dt}\\
对于串联，有i_L=i_R=i_C\\
L\frac{d^2i(t)}{dt^2}+R\frac{di(t)}{dt}+\frac{1}{C}i(t)=\frac{de(t)}{dt}\\
\]</span></p>
<p><span class="math display">\[
i_R(t)=\frac{1}{R}v(t)\\
i_L(t)=\frac{1}{L}\int_{-\infty}^{t}v(\tau)d\tau\\
i_C(t)=C\frac{dv_C(t)}{dt}
\]</span></p>
<p><span class="math display">\[
i_C(t)+i_R(t)+i_L(t)=i_S(t)\\
C\frac{d^2v(t)}{dt^2}+\frac{1}{R}\frac{dv(t)}{dt}+\frac{1}{L}v(t)=\frac{di_S(t)}{dt}\\
\]</span></p>
<p>若组成系统的都是参数恒定的线性元件，则相应的数学模型是一个线性常系数常微分方程，若各器件初始无储能，则为一个线性时不变系统</p>
<p>则对于一个线性时不变系统来说，其数学模型可以使用一个微分方程来描述： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 方程的解可以记作： $$</p>
<p>$$</p>
<p>线性电路系统由线性电子元器件构成，描述此类系统需要借助电路网络的两类约束条件：</p>
<ul>
<li>元件约束特性</li>
<li>网络拓扑约束</li>
</ul>
<p>两种约束的数学描述可以由<strong>微分方程组</strong>给出，这类方程组称为系统的<strong>状态方程</strong></p>
<p>我们联立上述方程组可以得到<strong>一个高阶微分方程</strong>，这个高阶微分方程称作<strong>输入输出方程</strong>，其阶数为系统的阶数</p>
<p>系统的输入称为激励，输出称为响应；若能给出系统的<strong>初始状态</strong>和<strong>激励</strong>，则可以获得<strong>响应</strong></p>
<p>系统的初始状态由若干独立条件给出，独立条件的个数与系统的阶数相同</p>
<p>线性时不变系统一般使用一个n阶线性微分方程来描述</p>
<p>这个方程可以被整理为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 一般来说，对于响应，其有实际意义的定义域称为响应区间，即：<span class="math inline">\(0_+ \le t&lt; \infty\)</span></p>
<p><span class="math inline">\(e(t)\)</span>加入前，系统为起始状态（<span class="math inline">\(0_-\)</span>状态） <span class="math display">\[
r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]
\]</span></p>
<p><span class="math inline">\(e(t)\)</span>加入后，系统为初始状态（<span class="math inline">\(0_+\)</span>状态） <span class="math display">\[
r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]
\]</span> 因此，决定关系为：</p>
<ul>
<li>起始状态 <span class="math inline">\(+\)</span> <span class="math inline">\(e(t)\)</span> <span class="math inline">\(\rightarrow\)</span> 初始状态</li>
<li>初始状态 <span class="math inline">\(\rightarrow\)</span> 响应齐次解的常系数 <span class="math inline">\(A\)</span></li>
</ul>
<p>响应可以拆解为三种形式：</p>
<ul>
<li>固有响应 <span class="math inline">\(+\)</span> 受迫响应</li>
<li>零输入响应 <span class="math inline">\(+\)</span> 零状态响应</li>
<li>暂态响应 <span class="math inline">\(+\)</span> 稳态响应</li>
</ul>
<h6 id="全响应">全响应：</h6>
<p>对于使用<span class="math inline">\(n\)</span>阶微分方程描述的线性系统： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 上述微分方程的解，即系统的响应，为：<span class="math inline">\(r(t)=r_h+r_p\)</span>，求解步骤为：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数
<ul>
<li>使用 <span class="math inline">\(r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]\)</span> 来求解系数向量 <span class="math inline">\(A_n\)</span></li>
<li>寻找 <span class="math inline">\(r^k(0_-)\)</span> 与 <span class="math inline">\(r^k(0_+)\)</span> 之间的关系
<ul>
<li>物理法：对于电路系统来说即换路定理：电容电感端性质的连续性</li>
<li>数学法：冲激函数匹配法：微分方程两端保持各阶奇异函数的平衡</li>
</ul></li>
</ul></li>
</ul>
<h6 id="固有响应和受迫响应">固有响应和受迫响应：</h6>
<p><span class="math inline">\(r(t)=r_h+r_p\)</span> <span class="math display">\[
r(t)=\underbrace_{\sf{固有响应}}+\underbrace_{\sf{受迫响应}}
\]</span></p>
<h6 id="零输入响应和零状态响应">零输入响应和零状态响应：</h6>
<p><strong>零输入响应：</strong> <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0
\]</span> 其中 <span class="math display">\[
\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}=0
\]</span> 说明 <span class="math display">\[
[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]=r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]
\]</span> <strong>零状态响应：</strong> <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 但是与全响应不同的是，零状态响应中： <span class="math display">\[
r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]=[0,0,...,0]
\]</span> 其余求法依旧是：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数</li>
</ul>
<p>注意：先求特解再求系数不要乱！</p>
<p>对于使用<span class="math inline">\(n\)</span>阶微分方程描述的线性系统： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 上述微分方程的解，即系统的响应，为：<span class="math inline">\(r(t)=r_h+r_p\)</span>，求解步骤为：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数：使用 <span class="math inline">\(r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]\)</span> 来求解系数向量 <span class="math inline">\(A_n\)</span></li>
</ul>
<h2 id="如何从微分方程上判断线性系统">如何从微分方程上判断线性系统</h2>
<ol type="1">
<li>只能出现函数本身，以及函数的任何阶次的导函数；</li>
<li>函数本身跟所有的导函数之间除了加减之外，不可以有任何运算；</li>
<li>函数本身跟本身、各阶导函数本身跟本身，都不可以有任何加减之外的运算；</li>
<li>若有积分项，被积函数应为输入变量，如 <span class="math inline">\(\int_{-\infty}^{t}r(\tau)d\tau\)</span>。其实积分就是微分的负次幂。</li>
<li>不允许对函数本身、各阶导函数做任何形式的复合运算。</li>
</ol>
<p><a href="https://www.zhihu.com/question/40919950">线性微分方程与非线性微分方程的区别是什么？</a></p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>写给电子专业同学的C语言教程</title>
    <url>/2022/02/27/16-41-11/</url>
    <content><![CDATA[<h1 id="cc语言教程">C/C++语言教程</h1>
<h3 id="递归">递归</h3>
<p>一般来讲，递归对于初学者来说是一个比较困难的内容，就我个人的学习经历来说，递归也是我在初学时比较头痛的一部分。对于这种情况，我想总结一下我学习中遇到的困难，然后在与大家分享递归思想的过程中，尽可能扫清那些影响我的障碍，让递归的学习梯度更缓一些，从而帮助大家更快地学习递归。</p>
<p>首先我想来说一下在我初学递归的过程中，我遇到了哪些困难：首先最重要的一条，我最早接触递归是通过一道习题接触的，就是大名鼎鼎的汉诺塔问题，算是个经典的递归问题了。但是经典归经典，我却不认为初学递归应该从汉诺塔开始，因为汉诺塔本身并不属于掷色子或者猜拳那种人尽皆知的游戏，想要去理解汉诺塔，首先要先看其规则并烂熟于心，然后就是汉诺塔使用了两个递归去完成，自然比单个递归要困难一些：以循环为例，通常的学法是先学明白单循环，再接触双层循环，接受起来才更容易些。因此，在接下来的讲解中，我将从一个非常非常简单的例子：打印1-5这五个数字为例，讲解递归操作的使用。</p>
<p>在讲解例子之前，我们先整体描述一下递归，<strong>递归即函数自己调用自己</strong>。</p>
<p>对于上述的定义，我们拆开来阐述一下：“函数自己调用自己”，这句话可以缩句为“函数调用”，调用谁先不管，要做的事情是函数调用，这件事要首先明确。在之前的课程中我们已经学习了函数的调用，尤其是我们将一段完整的，具有通用性的且需要多次使用的语句封装成一个函数，并在主函数中进行调用，这种操作我们已经非常熟悉，下面我们来看一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">A</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">B</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">C</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">E</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">D</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">E</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 11560)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们可以看到函数的多个函数依次调用：<code>main()</code> 调用 <code>E()</code>，<code>E()</code> 调用 <code>D()</code>，<code>D()</code> 调用 <code>C()</code>，<code>C()</code> 调用 <code>B()</code>，<code>B()</code> 调用 <code>A()</code>，当函数 <code>A()</code> 运行结束后，函数自动退出，然后就会返回 <code>B()</code>，返回到 <code>B()</code> 后 <code>B()</code> 也走到其函数体的最后了，因此 <code>B()</code> 也退出，然后就会返回 <code>C()</code>，就这样依次返回，最终回到 <code>main()</code>，执行 <code>return 0;</code> 。</p>
<p>在循环中，我们将具有相似结构的语句进行简化，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*本段代码为伪代码。*/</span></span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写为：</span></span><br><span class="line">sum = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后可以抽象出：</span></span><br><span class="line">sum = sum+mid;</span><br><span class="line">mid++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//于是可以使用循环解决问题：</span></span><br><span class="line"><span class="keyword">while</span>(mid&lt;=<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum = sum+mid;</span><br><span class="line">	mid++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么同样的，对于有着相同形式的函数，就像最前面一段代码中那样，函数 <code>A()</code> 到函数 <code>E()</code> 的函数体具有高度的相似性，我们是否也可以通过类似于循环那样的方法来实现同样的功能呢？</p>
<p>答案是可以的，我们可以只使用函数 <code>A()</code> ，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">		cout &lt;&lt; n;</span><br><span class="line">		<span class="built_in">A</span>(n + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 5580)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>接下来我们画图来分析一下，这段代码是如何工作的。</p>
<p>现在你应该对于递归的自调用有一定的概念了，那么现在我们来讨论一个问题，那就是，<strong>为什么是递归</strong>？毕竟我们以及有循环了，在刚才的示例中，我们递归能做的事情，循环可以做的更好，并且还好理解，我们何苦呢。</p>
<p>为了解决目前我们的递归看起来还没啥用的情况，我们引入第二个问题：十进制正整数转二进制数。</p>
<p>首先，解决这个问题，我们首先要知道十进制正整数转二进制数的算法。这个算法是非常简单的，这里我取我们数字电路课本中的例题来说明一下算法：</p>
<figure>
<img src="/2022/02/27/16-41-11/image-20220423044903868-16506605454001-16506605484693-16506605497375.png" alt="image-20220423044903868"><figcaption aria-hidden="true">image-20220423044903868</figcaption>
</figure>
<p>算法如下：</p>
<ol type="1">
<li>十进制正整数不断除以二，记录余数</li>
<li>当除法运算结果为0时，保留这次运算的余数并停止运算</li>
<li>将余数从下往上取出，在等号右侧从左往右依次列出</li>
</ol>
<p>这个算法，使用循环的话，我们会遇到一些麻烦的事情，让循环变得不那么好用了，因为，我们第一个得到的结果，需要在最后被打印出来。</p>
<p>这时候就到了递归登场的时候了，因为递归是函数的自调用，当函数一层一层的调用后，还需要一层一层的退出，比较的话，可以这样看待循环和递归，循环只是前进，而递归要去一趟回一趟，也就是两趟。</p>
<p><img src="/2022/02/27/16-41-11/image-20220423050047145-16506612490237.png" alt="image-20220423050047145" style="zoom:33%;"></p>
<p>这种特性使得我们能够轻松使用递归实现先得到的结果最后展示，在最终公布“十进制正整数转二进制数”题目的答案前，我们插一个小实例，来看一下，递归如何实现先得到的结果最后展示的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">A</span>(n + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">54321</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 8548)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>这段代码看着根前面的那段代码很想，唯一不同的是5、6两行的顺序颠倒了，这样导致的结果就是，程序将会先走到调用的最底层，然后在返回的时候在逐次打印，具体如下图展示。</p>
<p>最后我们来看一下十进制正整数转二进制数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">A</span>(n / <span class="number">2</span>);</span><br><span class="line">		cout &lt;&lt; n % <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">A</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">53</span><br><span class="line">110101</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 10544)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>目前，我们已经使用递归来解决实际问题了，也算是从不懂到会用了。耶！</p>
<p>但是，光看别人写是不够的，因为很多书写的细节对出初学者来说是难以注意到的。值得在你们自己开始写递归前就重点强调一下的书写细节是递归的停止条件。</p>
<p>在循环中，尤其是最常用的 <code>for</code> 循环，具有很明确的开始和截至的标识，在递归中，我们没有一个循环变量小i来直到我们设置递归的层数，但是，无穷的递归是不被允许的，无穷递归很快就会使程序运行内存中一片叫栈的区域爆满（或者专业点，叫溢出）。在上面所有的递归程序中，我们都可以看到，自调用的函数，我们在开头都设置了条件判断，只有在一定条件内的输入才能往后进行迭代，否则就</p>
<p>接下来，我将带领大家，在前面已经理解递归的基础上，从理解汉诺塔的规则开始，一点一点写出整个汉诺塔代码，一行一行的说明我在书写汉诺塔程序时是如何进行思考的。</p>
<p>首先是汉诺塔问题描述，摘录自维基百科：</p>
<blockquote>
<p>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<ol type="1">
<li>每次只能移动一个圆盘；</li>
<li>大盘不能叠在小盘上面。</li>
</ol>
<p>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>
<p>问：如何移？最少要移动多少次？</p>
</blockquote>
<p>然后是摘自维基百科的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Towers</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Move disk &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; from&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">Towers</span>(n<span class="number">-1</span>,a,c,b);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Move disk &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; from&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">Towers</span>(n<span class="number">-1</span>,b,a,c);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">Towers</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	cout&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 28576)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>根据运行结果，我们可以画出3个圆盘的汉诺塔是如何实现移动的：</p>
<p><img src="/2022/02/27/16-41-11/cd940d4cbf859995dd8175f2c250e70-165066295755110.jpg" alt="cd940d4cbf859995dd8175f2c250e70" style="zoom: 33%;"></p>
<p>然后问题就来了，因为我们会发现一个问题，那就是，根本找不到规律啊，递归要求一个函数，也就是说一种方法，只改变一下输入参数，不断调用这一个方法就能实现整个过程，但是看上面的图根本就无法找到规律啊。</p>
<p>那么，我们该如何解决现在面临的问题呢？是不是可以考虑，可能是取的数量太少，我们可以试试圆盘数量为4个或者5个？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 2 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line">Move disk 3 from A to B</span><br><span class="line">Move disk 1 from C to A</span><br><span class="line">Move disk 2 from C to B</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 4 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line">Move disk 2 from B to A</span><br><span class="line">Move disk 1 from C to A</span><br><span class="line">Move disk 3 from B to C</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 2 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 25272)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 4 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 2 from C to A</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 3 from C to B</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 5 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 3 from B to A</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 2 from C to A</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 4 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 28244)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>好家伙，我们会发现一个要命的问题——太多了，到五个的时候，就已经接近30次移动了。这要是画出来，可有点麻烦，那怎么办呢？</p>
<p>答案很简单，查资料！因为这实在是一个很普遍的问题，还是来看看其他人是如何理解这个问题的吧。</p>
<p>我们打开知乎直接搜汉诺塔+递归，很快，就出来了一个好回答，我们引用来给大家看一下：</p>
<blockquote>
<p>举例来说，如果要把一个N层<a href="https://www.zhihu.com/search?q=汉诺塔&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%22258015386%22%7D">汉诺塔</a>从A搬到C，那么：</p>
<p>如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？</p>
<p>你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到B；然后把最下面的第N层搬到C；然后再把前N-1层从B搬到C。</p>
</blockquote>
<p>把上面的话变成图像，就是这样子的，我们以四圆盘汉诺塔为例子说明：</p>
<p><img src="/2022/02/27/16-41-11/f5934171b9e47846656830e885174e3-165066362487913.jpg" alt="f5934171b9e47846656830e885174e3" style="zoom:33%;"></p>
<p>好的，看到这个图不知道大家会不会有些疑问哈，可能会有同学觉得，这样搬会不会违反汉诺塔的游戏规则了？emmm，如果你最后的结果是这样搬动的确实是不行的，但是关键在于，我们按照搬动顺序去寻找递归方法是行不通的，我们需要寻找一种能解决问题的通用方法（这里的通用是指对每一层圆盘移动的通用方法），然后我们在解决完问题后，再去调整顺序输出，来实现满足游戏规则的搬动方法。</p>
<p>因此，上述操作，确实可以帮助我们将4个圆盘，从A移动到C，并且我们可以注意到，从第3行到第4行，因为移动的圆盘都比C上的大圆盘小，故移动是随意的，即ABC三个底座都可以放圆盘。</p>
<p><img src="/2022/02/27/16-41-11/69227befb2e0235c3a257acdcc450ad-165066408870616.jpg" alt="69227befb2e0235c3a257acdcc450ad" style="zoom: 50%;"></p>
<p>观察上图，我们可以看到，第一列中有四个圆盘，从第一步到第二部和从第三步到第四步在规则的制约下都不是可以一步实现的，但是因为每一次变化都依旧有三个底座可用，故具有移动方法上的相似性，这使得函数的自调用成为可能。</p>
<p>我们可以看到，随着列数往后数，我们处理的问题的规模在逐渐下降，最初是4个圆盘，第二列时，我们关注的就成了3个圆盘，这样依次下推，最终我们会得到一种情况，这种情况下只有一个圆盘，如图：</p>
<figure>
<img src="/2022/02/27/16-41-11/5898a6106be97a5e17f672399758dd2-165066466531719.jpg" alt="5898a6106be97a5e17f672399758dd2"><figcaption aria-hidden="true">5898a6106be97a5e17f672399758dd2</figcaption>
</figure>
<p>我们观察放大部分中的最后一列，可以看到，最后一列中所有的操作都是将圆盘从A移动到C，这种特性说明了每一次递归的终点都是“将圆盘从A移动到C”，如果你回到上面看代码，你会发现代码中真正打印的移动操作都是从a到c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_1</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_2</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	move_1(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_1(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_3</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	move_2(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_2(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_4</span><span class="params">(<span class="type">int</span> level,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span> </span><br><span class="line">&#123;</span><br><span class="line">	move_3(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_3(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Towers</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move disk &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Towers(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move disk &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		Towers(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; level;</span><br><span class="line">	Towers(level, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_4(level, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理实验绘图</title>
    <url>/2022/02/25/06-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="标准程序">标准程序</h2>
<h3 id="数据标识标准">数据标识标准</h3>
<blockquote>
<p>实验测量数据统一使用measure的首字母m做下标表示</p>
<p>标准数据使用standard的首字母s做下标表示</p>
<p>通过拟合方程计算得出的结果使用calculate的首字母c做下标表示</p>
</blockquote>
<h3 id="相对误差计算程序">相对误差计算程序</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入测量值Xm=&#x27;</span>;</span><br><span class="line">Xm = input(prompt);</span><br><span class="line">prompt = <span class="string">&#x27;请输入标准值Xs=&#x27;</span>;</span><br><span class="line">Xs = input(prompt);</span><br><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">RelEor =<span class="built_in">abs</span>((Xm-Xs)/Xs)*<span class="number">100</span>;</span><br><span class="line">R=<span class="built_in">round</span>(RelEor,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;计算得相对误差为:&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([num2str(R),<span class="string">&#x27;%&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="描点作图">描点作图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="求平均值">求平均值</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];y</span><br><span class="line">Xm_mean=<span class="built_in">mean</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="一元线性回归">一元线性回归</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=[<span class="number">-1.875</span>,<span class="number">-1.474</span>,<span class="number">-1.262</span>,<span class="number">-0.709</span>,<span class="number">-0.586</span>];</span><br><span class="line">Ym=[<span class="number">8.214</span>,<span class="number">7.408</span>,<span class="number">6.879</span>,<span class="number">5.490</span>,<span class="number">5.196</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="绘图">绘图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">title(<span class="string">&quot;标题&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;X轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;Y轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="隐函数族图像绘制">隐函数族图像绘制</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">z</span> = <span class="title">z</span><span class="params">(x,y,k)</span></span></span><br><span class="line">z = <span class="number">0.5</span>*x^<span class="number">2</span>+<span class="number">3</span>*x*y+<span class="number">0.5</span>*y^<span class="number">2</span>-k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%k限定着函数族的范围</span></span><br><span class="line">k = <span class="number">-10</span>;</span><br><span class="line"><span class="keyword">while</span> k &lt; <span class="number">10</span></span><br><span class="line">    k = k + <span class="number">1</span>;</span><br><span class="line">    ezplot(@(x,y)z(x,y,k));</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="实验数据处理">实验数据处理</h2>
<h3 id="非线性负组电路元件伏安特性">非线性负组电路元件伏安特性</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">Ym=[<span class="number">-0.002</span>,<span class="number">-0.011</span>,<span class="number">-0.031</span>,<span class="number">-0.046</span>,<span class="number">-0.072</span>,<span class="number">-0.140</span>,<span class="number">-0.618</span>,<span class="number">-0.731</span>,<span class="number">-0.894</span>,<span class="number">-1.148</span>,<span class="number">-1.582</span>,<span class="number">-1.672</span>,<span class="number">-1.688</span>,<span class="number">-1.748</span>,<span class="number">-1.901</span>,<span class="number">-2.068</span>,<span class="number">-2.250</span>,<span class="number">-2.677</span>,<span class="number">-2.926</span>,<span class="number">-3.206</span>,<span class="number">-3.888</span>,<span class="number">-4.311</span>,<span class="number">-4.806</span>,<span class="number">-6.106</span>,<span class="number">-6.276</span>,<span class="number">-6.493</span>,<span class="number">-6.618</span>,<span class="number">-6.803</span>,<span class="number">-7.195</span>,<span class="number">-8.105</span>,<span class="number">-8.656</span>,<span class="number">-9.267</span>,<span class="number">-9.962</span>,<span class="number">-10.353</span>,<span class="number">-10.766</span>,<span class="number">-11.214</span>,<span class="number">-11.214</span>,<span class="number">-11.533</span>,<span class="number">-11.645</span>,<span class="number">-11.893</span>,<span class="number">-12.094</span>,<span class="number">-12.146</span>,<span class="number">-12.273</span>,<span class="number">-12.352</span>,<span class="number">-12.457</span>];</span><br><span class="line">R=[<span class="number">300</span>,<span class="number">600</span>,<span class="number">900</span>,<span class="number">1000</span>,<span class="number">1100</span>,<span class="number">1200</span>,<span class="number">1300</span>,<span class="number">1305</span>,<span class="number">1310</span>,<span class="number">1315</span>,<span class="number">1320</span>,<span class="number">1325</span>,<span class="number">1330</span>,<span class="number">1350</span>,<span class="number">1400</span>,<span class="number">1450</span>,<span class="number">1500</span>,<span class="number">1600</span>,<span class="number">1650</span>,<span class="number">1700</span>,<span class="number">1800</span>,<span class="number">1850</span>,<span class="number">1900</span>,<span class="number">2000</span>,<span class="number">2010</span>,<span class="number">2020</span>,<span class="number">2030</span>,<span class="number">2040</span>,<span class="number">2060</span>,<span class="number">2100</span>,<span class="number">2120</span>,<span class="number">2140</span>,<span class="number">2160</span>,<span class="number">2170</span>,<span class="number">2180</span>,<span class="number">2190</span>,<span class="number">2200</span>,<span class="number">2700</span>,<span class="number">3000</span>,<span class="number">4000</span>,<span class="number">5000</span>,<span class="number">6000</span>,<span class="number">8000</span>,<span class="number">10000</span>,<span class="number">15000</span>];</span><br><span class="line">I=Ym./R;</span><br><span class="line">Xm=I;</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);<span class="comment">%数据点图</span></span><br><span class="line">title(<span class="string">&quot;非线性负组电路元件伏安特性&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;电流(A)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;电压(V)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="弦线上波的传播规律">弦线上波的传播规律</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定张力和线密度</span></span><br><span class="line">f=[<span class="number">70</span> <span class="number">90</span> <span class="number">110</span> <span class="number">130</span> <span class="number">150</span> <span class="number">180</span>];</span><br><span class="line">lamt=[<span class="number">1.22</span> <span class="number">0.9122</span> <span class="number">0.74</span> <span class="number">0.6136</span> <span class="number">0.5264</span> <span class="number">0.449</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(lamt);</span><br><span class="line">Ym=<span class="built_in">log</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(频率)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(频率)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173254618.png" alt="image-20211106173254618" style="zoom:33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">-0.935900</span>x+<span class="number">4.421856</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.998356</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.1989</span>   <span class="number">-0.0919</span>   <span class="number">-0.3011</span>   <span class="number">-0.4884</span>   <span class="number">-0.6417</span>   <span class="number">-0.8007</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">    <span class="number">4.2485</span>    <span class="number">4.4998</span>    <span class="number">4.7005</span>    <span class="number">4.8675</span>    <span class="number">5.0106</span>    <span class="number">5.1930</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定频率和线密度</span></span><br><span class="line">T=[<span class="number">2.45</span> <span class="number">7.34</span> <span class="number">12.23</span> <span class="number">17.12</span> <span class="number">22.02</span> <span class="number">26.91</span>];</span><br><span class="line">lamt=[<span class="number">0.449</span> <span class="number">0.6850</span> <span class="number">0.8934</span> <span class="number">1.032</span> <span class="number">1.148</span> <span class="number">1.2662</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(T);</span><br><span class="line">Ym=<span class="built_in">log</span>(lamt);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(周期)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(周期)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173033589.png" alt="image-20211106173033589" style="zoom: 33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">0.435631</span>x+<span class="number">-1.209052</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.997443</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8961</span>    <span class="number">1.9933</span>    <span class="number">2.5039</span>    <span class="number">2.8402</span>    <span class="number">3.0920</span>    <span class="number">3.2925</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.8007</span>   <span class="number">-0.3783</span>   <span class="number">-0.1127</span>    <span class="number">0.0315</span>    <span class="number">0.1380</span>    <span class="number">0.2360</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="磁滞曲线">磁滞曲线</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.2</span>:<span class="number">3</span>;</span><br><span class="line">&gt;&gt; y1=[<span class="number">-1.4</span>,<span class="number">-1.2</span>,<span class="number">-1.1</span>,<span class="number">-1.0</span>,<span class="number">-0.9</span>,<span class="number">-0.8</span>,<span class="number">-0.6</span>,<span class="number">-0.3</span>,<span class="number">0</span>,<span class="number">0.4</span>,<span class="number">0.7</span>,<span class="number">1.1</span>,<span class="number">1.4</span>,<span class="number">1.8</span>,<span class="number">1.9</span>,<span class="number">2.0</span>];</span><br><span class="line">&gt;&gt; y2=[<span class="number">1.4</span> <span class="number">1.3</span> <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.7</span> <span class="number">1.7</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.9</span> <span class="number">2.0</span> <span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x,y2)</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y2)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y1)</span><br><span class="line"></span><br><span class="line">title(<span class="string">&quot;磁滞曲线&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/25/06-07-35/Users\qjy\Desktop\untitled.png" alt="untitled"><figcaption aria-hidden="true">untitled</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程笔记</title>
    <url>/2022/02/25/05-07-35/</url>
    <content><![CDATA[<p>​</p>
<p>[TOC]</p>
<hr>
<h3 id="分类和解法">分类和解法</h3>
<h4 id="一阶线性方程">一阶线性方程</h4>
<p>$$ First,order,linear,differential,equation:x'+p(t)x=q(t) \\ solution:</p>
<p>e<sup>{<em>{}{}{p(t)}dt}x'+e^{</em>{}{}{p(t)}dt}p(t)x=e</sup>{<em>{}{}{p(t)}dt}q(t) \  \ (e^{</em>{}{}{p(t)}dt}x)'=e^{_{}{}{p(t)}dt}q(t) $$</p>
<h4 id="变量分离方程">变量分离方程</h4>
<p><span class="math display">\[
Separable\,equation : x&#39;=h(t)g(x) \qquad g(x)!= 0
\\\\
solution:x&#39;=h(t)g(x) \xrightarrow{x&#39;=\frac{dx}{dt}} \frac{dx}{g(x)}=h(t)dt
\\
\Downarrow 
\\
\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt
\]</span></p>
<h4 id="恰当方程">恰当方程</h4>
<p><span class="math display">\[
Exact\,equation:
\begin{cases}
M(x,y)dx+N(x,y)dy=0\\
\\
N_x=M_y\\
\end{cases}
\\\\
\]</span></p>
<h3 id="二阶线性常微分方程">二阶线性常微分方程</h3>
<p>最一般的二阶线性微分方程为： <span class="math display">\[
a_0(t)x&#39;&#39;+a_1(t)x&#39;+a_2(t)x=g(t)
\]</span> 下述讨论中，我们仅讨论<span class="math inline">\(a_0(t)\not=0\)</span>的情况</p>
<p>即： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)
\]</span></p>
<h4 id="齐次方程">齐次方程：</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=0\tag{1}
\]</span> 求齐次方程通解的方法：</p>
<ol type="1">
<li><p>找到两个特解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p>
<ol type="1">
<li><p>如果不能找到两个特解，那就先找到一个特解<span class="math inline">\(x_1\)</span>，那么<span class="math inline">\(x_2\)</span>为：</p>
<ol type="1">
<li>设<span class="math inline">\(x_2=v_1(t)x_1\)</span>，将<span class="math inline">\(x_2\)</span>带入到<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=0\)</span>中，整理求出<span class="math inline">\(v_1(t)\)</span></li>
</ol>
<p><span class="math display">\[
x_2=x_1\int \frac{e^{-\int p(t)dt}}{x_1^2}dt
\]</span></p></li>
<li><p>如果一个特解也找不到：</p>
<p>？？？？？</p></li>
</ol></li>
<li><p>验证两个特解<strong>线性无关</strong>:<span class="math inline">\(W(t)\not=0\)</span></p>
<ol type="1">
<li><p>Remark：若<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>是二阶常微分方程的解，则：<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>线性相关<span class="math inline">\(\,\Leftrightarrow W(x_1,x_2)(t)=0\)</span></p></li>
<li><p>其中： <span class="math display">\[
W(x_1,x_2)(t)=\begin{vmatrix}
x_1 &amp; x_2\\
x_1&#39; &amp; x_2&#39;
\end{vmatrix}=x_1x_2&#39;-x_1&#39;x_2
\]</span></p></li>
</ol></li>
<li><p>若两特解线性无关，则齐次方程(1)式的通解为：<span class="math inline">\(x=c_1x_1+c_2x_2\)</span></p></li>
</ol>
<h4 id="非齐次方程">非齐次方程</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\tag{2}
\]</span> 求非齐次方程通解的方法：</p>
<ol type="1">
<li><p>先令<span class="math inline">\(f(t)\equiv 0\)</span>，求出<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\)</span>的通解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p></li>
<li><p>非齐次方程的通解可以表示为：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span>，其中<span class="math inline">\(x_p=v_1(t)x_1+v_2(t)x_2\)</span></p></li>
<li><p>求解<span class="math inline">\(v_1(t),v_2(t)\)</span></p>
<ol type="1">
<li><p>列方程组 <span class="math display">\[
\begin{cases}
\begin{aligned}
v_1&#39;x_1+v_2&#39;x_2&amp;=0\\\\
v_1&#39;x_1&#39;+v_2&#39;x_2&#39;&amp;=f(t)
\end{aligned}
\end{cases}
\]</span></p></li>
<li><p>利用克莱姆法则：</p>
<ul>
<li><p>克莱姆法则：</p>
<p><img src="/2022/02/25/05-07-35/image-20211126105116954.png" alt="image-20211126105116954" style="zoom:33%;"></p>
<p><img src="/2022/02/25/05-07-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20211126105131958.png" alt="image-20211126105131958" style="zoom:33%;"></p></li>
</ul>
<p><span class="math display">\[
v1&#39;=\frac{\begin{vmatrix}0 &amp; x_2\\f(t) &amp; x_1&#39;\end{vmatrix}}{W(t)}=-\frac{x_2f(t)}{W(t)}\\\\
v2&#39;=\frac{\begin{vmatrix}x_1 &amp; 0\\x_1&#39; &amp; f(t)\end{vmatrix}}{W(t)}=-\frac{x_1f(t)}{W(t)}
\]</span></p></li>
<li><p>最终对<span class="math inline">\(v_1&#39;\)</span>和<span class="math inline">\(v_2&#39;\)</span>进行积分 <span class="math display">\[
v_1=\int{}v_1&#39;dt\,,\:v_2=\int{}v_2&#39;dt,
\]</span></p></li>
</ol></li>
<li><p>最终得到非齐次方程的通解：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span></p></li>
</ol>
<h4 id="常系数的二阶微分方程">常系数的二阶微分方程</h4>
<p>求解目标： <span class="math display">\[
ax&#39;&#39;+bx&#39;+cx=0\,,\:(a\not= 0)
\]</span> 求解方法： <span class="math display">\[
Let\;\;x=e^{mt}\;x&#39;=me^{mt}\;x&#39;&#39;=m^2e^{mt}\\ \Downarrow\\
ax&#39;&#39;+bx&#39;+cx=am^2e^{mt}+bme^{mt}+ce^{mt}=0\\ \Downarrow\\
e^{mt}(am^2+bm+c)=0
\]</span> 对于：<span class="math inline">\(am^2+bm+c=0\)</span></p>
<ul>
<li><p>case 1: <span class="math display">\[
\Delta &gt; 0\\
&amp;m_1=\frac{-b+\sqrt{b^2-4ac}}{2a}\\
&amp;m_2=\frac{-b-\sqrt{b^2-4ac}}{2a}\\
so\\
&amp;x_1=e^{m_1t}\;x_2=e^{m_2t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{m_1t}+c_2e^{m_2t}
\]</span></p></li>
<li><p>case 2: <span class="math display">\[
\Delta = 0\\
&amp;m=-\frac{b}{2a}\\
so\\
&amp;x_1=e^{mt}=e^{-\frac{b}{2a}t}\\
&amp;x_2=te^{-\frac{b}{2a}t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{-\frac{b}{2a}t}+c_2te^{-\frac{b}{2a}t}
\]</span></p></li>
<li><p>case 3: <span class="math display">\[
i^2=-1
\]</span></p>
<p>$$ =b^2-4ac &lt; 0\ &amp;m==i=i\</p>
<p>&amp;x=e^{t}(cos(t)+isin(t)) $$</p></li>
</ul>
<h4 id="欧拉等式">欧拉等式</h4>
<p>求解目标： <span class="math display">\[
at^2x&#39;&#39;+btx&#39;+cx=0
\]</span> 求解方法：</p>
<ol type="1">
<li><p>首先令：<span class="math inline">\(t=e^s,s=lnt\)</span></p></li>
<li><p>则有：<span class="math inline">\(x&#39;(s)=tx&#39;(t);\, x&#39;&#39;(s)-x&#39;(s)=t^2x&#39;&#39;(t)\)</span></p></li>
<li><p>上面两个式子带入<span class="math inline">\(at^2x&#39;&#39;+btx&#39;+cx=0\)</span>有：</p>
<p><span class="math inline">\(\begin{aligned}at^2x(t)&#39;&#39;+btx(t)&#39;+cx(t)\\&amp;=a(x&#39;&#39;(s)-x&#39;(s))+bx&#39;(s)+cx(s)\\&amp;=ax&#39;&#39;(s)+(b-a)x&#39;(s)+cx(s)\\&amp;=0\end{aligned}\)</span></p></li>
<li><p>根据常系数的二阶微分方程的求解方法：<span class="math inline">\(e^{mt}(am^2+(b-a)m+c)=0\)</span></p></li>
<li><p><span class="math display">\[
(am^2+(b-a)m+c)=0\;\;\sf{分三种情况讨论：}
\begin{cases}
\begin{aligned}
\Delta&gt;0\\\\
\Delta=0\\\\
\Delta&lt;0\\\\
\end{aligned}
\end{cases}
\]</span></p></li>
</ol>
<p>如果<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n × n\)</span>矩阵，那么下列语句是等价的。</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>是可逆的。</li>
<li><span class="math inline">\(Ax = 0\)</span>只有平凡解。</li>
<li><span class="math inline">\(A\)</span>的行简化阶梯形是<span class="math inline">\(I_n\)</span>。</li>
<li>A可以表示为初等矩阵的乘积.</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>都是一致的。</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>只有一个解</li>
<li><span class="math inline">\(det(A) \not= 0\)</span></li>
<li><span class="math inline">\(A\)</span>的列向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>的行向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>张成空间<span class="math inline">\(R_n\)</span>的列向量。</li>
<li><span class="math inline">\(A\)</span>的行向量张成<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的列向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的行向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的等级是<span class="math inline">\(n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零度为零。</li>
<li><span class="math inline">\(A\)</span>的零空间的正交补是<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间的正交补是<span class="math inline">\(\{0\}\)</span>。</li>
</ol>
<p>线性相关性，两种表述方式 <span class="math display">\[
x_3=c_1x_1+c_2x_2\\
\]</span> 线性无关：只有系数全为0时线性组合才恒为0</p>
<p>线性相关：能找出一组非零常数使得线性组合结果为0</p>
<h2 id="高阶微分方程">高阶微分方程</h2>
<h3 id="线性微分方程的一般理论">线性微分方程的一般理论</h3>
<p>本章讨论的问题：求解微分方程（高阶导数使用数字上标表示） <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{1}
\]</span></p>
<ol type="1">
<li><p>齐次形式： <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{2}
\]</span></p></li>
<li><p>解的存在唯一性：</p>
<p>如果<span class="math inline">\(a_i(t)(i=1,2,\cdot\cdot\cdot,n)\)</span>及<span class="math inline">\(f(t)\)</span>都是$a t b <span class="math inline">\(上的连续函数，则对于任一\)</span>t_0<span class="math inline">\(及任意的\)</span>x_0<span class="math inline">\(，\)</span>x_0'<span class="math inline">\(，\)</span><span class="math inline">\(，\)</span>x_0^{(n-1)}<span class="math inline">\(，方程（1）存在唯一解\)</span>x(t)<span class="math inline">\(，符号记为\)</span>x=(t)<span class="math inline">\(，定义于\)</span>a t b $，且满足初值条件： <span class="math display">\[
\varphi(t_0)=x_0,\;\varphi(t_0)&#39;=x_0&#39;,\;\varphi(t_0)^{(n-1)}=x_0^{(n-1)}
\]</span></p></li>
</ol>
<h4 id="齐次线性微分方程解的性质和结构"><code>齐次线性微分方程解</code>的性质和结构</h4>
<ol type="1">
<li><code>齐次线性微分方程的解</code>的<code>叠加原理</code>
<ol type="1">
<li>描述：<code>齐次线性微分方程的解</code>的<code>线性叠加</code>仍为<code>齐次线性微分方程的解</code></li>
<li>原理：
<ol type="1">
<li>常数可以从微分号下提出来</li>
<li>和的导数等于导数的和</li>
</ol></li>
<li>问题：什么情况下解的线性组合可以成为齐次线性微分方程的通解？</li>
</ol></li>
<li></li>
</ol>
<p>变量分离方程：</p>
<p>解法：</p>
<ol type="1">
<li>非初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解</li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span></li>
</ol></li>
<li>初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解
<ol type="1">
<li>若<span class="math inline">\(x=0\)</span>是方程的解，则<span class="math inline">\(x\)</span>要么恒大于0，要么恒小于0</li>
</ol></li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span>，其中<span class="math inline">\(g(x)\not=0\)</span></li>
<li>最后使用<span class="math inline">\(x(t_0)=x_0\)</span>求解常数<span class="math inline">\(c\)</span></li>
</ol></li>
</ol>
<p>备注：如果求解出的<span class="math inline">\(x(t)\)</span>的分母可以等于0，那么要排除等于0的点；如果带有初值，那么t的取值范围为带有初值的那一部分</p>
<p>如何寻找常数解？对于常数解，我们7有<span class="math inline">\(x&#39;=0\)</span>，所以只要寻找使得方程右边为<span class="math inline">\(0\)</span>的常数<span class="math inline">\(k\)</span>就好了</p>
<p>存在唯一性定理：</p>
<p>解的存在和个数由f在(x0,t0)附近的性质决定</p>
<p>如果f在(x0,t0)附近连续即可知初值问题至少存在局部唯一解</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 =&gt; 解在局部唯一</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 &amp;&amp; 偏导数在一条形区域内有界 =&gt; 则在条形区间内有唯一解</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式(Latex)</title>
    <url>/2022/02/20/23-32-35/</url>
    <content><![CDATA[<h1 id="数学公式latex">数学公式(LATEX)</h1>
<h3 id="测试">测试：</h3>
<p>行内公式测试：<span class="math inline">\(A_a\)</span>，希腊字母：<span class="math inline">\(\beta\)</span></p>
<p>行间公式测试： <span class="math display">\[
f(t)=a_t
\]</span> 换行测试</p>
<ol type="1">
<li><p>行内 <span class="math inline">\(\begin{gather*}a_2\\d^5\end{gather*}\)</span> 行内测试完毕</p></li>
<li><p>行间 <span class="math display">\[
\begin{gather*}
a_2\\
d^5
\end{gather*}、
\]</span></p></li>
</ol>
<p>可以正常渲染公式。</p>
<h3 id="常用">常用</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">上下标：y<span class="built_in">_</span>下标=x<span class="built_in">^</span>上标<span class="keyword">\\</span></span><br><span class="line">分式与求导:<span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;<span class="keyword">\\</span></span><br><span class="line">求导：求导其实就是输入字母<span class="keyword">\\</span></span><br><span class="line">积分：<span class="keyword">\int</span><span class="built_in">_</span>&#123;积分下限&#125;<span class="built_in">^</span>&#123;积分上限&#125;&#123;积分变量&#125;d被积变量<span class="keyword">\\</span></span><br><span class="line">大括号:</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">括号内第一行<span class="keyword">\\</span></span><br><span class="line">括号内第二行<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;<span class="keyword">\\</span></span><br><span class="line">极限:<span class="keyword">\lim</span><span class="built_in">_</span>&#123;n<span class="keyword">\rightarrow</span><span class="keyword">\infty</span>&#125;&#123;x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vec</span>&#123;向量&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\prod</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sqrt</span> e<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
上下标：y_下标=x^上标\\
分式与求导:\frac{分子}{分母}\\
求导：求导其实就是输入字母\\
积分：\int_{积分下限}^{积分上限}{积分变量}d被积变量\\
大括号:
\begin{cases}
括号内第一行\\
括号内第二行\\
\end{cases}\\
极限:\lim_{n\rightarrow\infty}{x}\\
\vec{向量}\\
\sum_{n=起始值}^{终值}{a_n}\\
\prod_{n=起始值}^{终值}{a_n}\\
\sqrt e\\
\approx
\end{gather*}
\]</span></p>
<h3 id="运算符">运算符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line"><span class="keyword">\times</span></span><br><span class="line">/</span><br><span class="line"><span class="keyword">\div</span></span><br><span class="line"><span class="keyword">\cdot</span></span><br><span class="line"><span class="keyword">\#</span></span><br><span class="line"><span class="keyword">\%</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
+
-
\times
/
\div
\cdot
\#
\%
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\sqcup</span></span><br><span class="line"><span class="keyword">\sqcap</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\cap
\cup
\land
\lor
\sqcup
\sqcap
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\ast</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\otimes</span></span><br><span class="line"><span class="keyword">\oplus</span></span><br><span class="line"><span class="keyword">\odot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\circ
\ast
\star
\otimes
\oplus
\odot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pm</span></span><br><span class="line"><span class="keyword">\mp</span></span><br><span class="line"><span class="keyword">\dotplus</span></span><br><span class="line"><span class="keyword">\divideontimes</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\pm
\mp
\dotplus
\divideontimes
\]</span></p>
<h4 id="约等于">约等于</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">= <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\approxeq</span></span><br><span class="line"><span class="keyword">\cong</span></span><br><span class="line"><span class="keyword">\sim</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
=
= \not
\equiv
\approx
\approxeq
\cong
\sim
\]</span></p>
<h4 id="比较">比较</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">&gt;<span class="keyword">\\</span></span><br><span class="line">0 <span class="keyword">\le</span> <span class="keyword">\omega</span> t <span class="keyword">\le</span> <span class="keyword">\pi</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ge</span></span><br><span class="line"><span class="keyword">\gg</span></span><br><span class="line"><span class="keyword">\ll</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
&lt;
&gt;\\
0 \le \omega t \le \pi \\
\ge
\gg
\ll
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\curlyeqprec</span></span><br><span class="line"><span class="keyword">\curlyeqsucc</span></span><br><span class="line"><span class="keyword">\prec</span></span><br><span class="line"><span class="keyword">\succ</span></span><br><span class="line"><span class="keyword">\preceq</span></span><br><span class="line"><span class="keyword">\succeq</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\curlyeqprec
\curlyeqsucc
\prec
\succ
\preceq
\succeq
\]</span></p>
<h3 id="集合逻辑相关">集合/逻辑相关</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br><span class="line"><span class="keyword">\owns</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\subset</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\supset</span></span><br><span class="line"><span class="keyword">\subseteq</span></span><br><span class="line"><span class="keyword">\supseteq</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\neg</span></span><br><span class="line"><span class="keyword">\emptyset</span></span><br><span class="line"><span class="keyword">\varnothing</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\because</span></span><br><span class="line"><span class="keyword">\forall</span></span><br><span class="line"><span class="keyword">\exists</span></span><br><span class="line"><span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\in
\owns \not
\subset \not
\supset
\subseteq
\supseteq
\\
\cap
\cup
\land
\lor
\\
\neg
\emptyset
\varnothing
\\
\because
\forall
\exists
\therefore
\]</span></p>
<h3 id="箭头">箭头</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\gets</span></span><br><span class="line"><span class="keyword">\leftarrow</span></span><br><span class="line"><span class="keyword">\to</span></span><br><span class="line"><span class="keyword">\rightarrow</span></span><br><span class="line"><span class="keyword">\leftrightarrow</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\uparrow</span></span><br><span class="line"><span class="keyword">\downarrow</span></span><br><span class="line"><span class="keyword">\updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\gets
\leftarrow
\to
\rightarrow
\leftrightarrow
\\
\uparrow
\downarrow
\updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Leftarrow</span></span><br><span class="line"><span class="keyword">\Rightarrow</span></span><br><span class="line"><span class="keyword">\Leftrightarrow</span></span><br><span class="line"><span class="keyword">\iff</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Uparrow</span></span><br><span class="line"><span class="keyword">\Downarrow</span></span><br><span class="line"><span class="keyword">\Updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Leftarrow
\Rightarrow
\Leftrightarrow
\iff
\\
\Uparrow
\Downarrow
\Updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\nearrow</span></span><br><span class="line"><span class="keyword">\searrow</span></span><br><span class="line"><span class="keyword">\swarrow</span></span><br><span class="line"><span class="keyword">\nwarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\nearrow
\searrow
\swarrow
\nwarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\leftharpoonup</span></span><br><span class="line"><span class="keyword">\leftharpoondown</span></span><br><span class="line"><span class="keyword">\rightharpoonup</span></span><br><span class="line"><span class="keyword">\rightharpoondown</span></span><br><span class="line"><span class="keyword">\rightleftharpoons</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\leftharpoonup
\leftharpoondown
\rightharpoonup
\rightharpoondown
\rightleftharpoons
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mapsto</span></span><br><span class="line"><span class="keyword">\leadsto</span></span><br><span class="line"><span class="keyword">\hookleftarrow</span></span><br><span class="line"><span class="keyword">\hookrightarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mapsto
\leadsto
\hookleftarrow
\hookrightarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\longleftarrow</span></span><br><span class="line"><span class="keyword">\longrightarrow</span></span><br><span class="line"><span class="keyword">\longleftrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftarrow</span></span><br><span class="line"><span class="keyword">\Longrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftrightarrow</span></span><br><span class="line"><span class="keyword">\longmapsto</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\longleftarrow
\longrightarrow
\longleftrightarrow
\Longleftarrow
\Longrightarrow
\Longleftrightarrow
\longmapsto
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\xrightarrow</span>&#123;over&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[over]&#123;&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[under]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;over&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\xrightarrow{over}
\xrightarrow[over]{}
\xrightarrow[under]{over}
\xleftarrow[]{over}
\xleftarrow[under]{}
\xleftarrow[under]{over}
\]</span></p>
<h3 id="空格间距">空格间距</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line"><span class="keyword">\sf</span>&#123;紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\it</span>&#123;a<span class="keyword">\!</span>b + ab + a<span class="keyword">\,</span>b + a<span class="keyword">\;</span>b + a<span class="keyword">\ </span>b + a<span class="keyword">\quad</span> b + a<span class="keyword">\qquad</span> b&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\sf{紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格}\\
\it{a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b}\\
\end{gather*}
\]</span></p>
<h3 id="希腊字母表">希腊字母表</h3>
<table>
<thead>
<tr class="header">
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(\gamma\)</span></td>
<td><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\nu\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\varepsilon\)</span></td>
<td><span class="math inline">\(\varrho\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\Delta\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
<td><span class="math inline">\(\varDelta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varPsi\)</span></td>
<td><span class="math inline">\(\zeta\)</span></td>
<td><span class="math inline">\(\kappa\)</span></td>
<td><span class="math inline">\(\xi\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\chi\)</span></td>
<td><span class="math inline">\(\varkappa\)</span></td>
<td><span class="math inline">\(\varsigma\)</span></td>
<td><span class="math inline">\(\Theta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Omega\)</span></td>
<td><span class="math inline">\(\varTheta\)</span></td>
<td><span class="math inline">\(\varSigma\)</span></td>
<td><span class="math inline">\(\varOmega\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\omicron\)</span></td>
<td><span class="math inline">\(\tau\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varphi\)</span></td>
<td><span class="math inline">\(\Lambda\)</span></td>
<td><span class="math inline">\(\Upsilon\)</span></td>
<td><span class="math inline">\(\varLambda\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta\)</span></td>
<td><span class="math inline">\(\theta\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\omega\)</span></td>
<td><span class="math inline">\(\varpi\)</span></td>
<td><span class="math inline">\(\digamma\)</span></td>
<td><span class="math inline">\(\partial\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\imath\)</span></td>
<td><span class="math inline">\(\jmath\)</span></td>
<td><span class="math inline">\(\aleph\)</span></td>
<td><span class="math inline">\(\hbar\)</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">No.</th>
<th style="text-align: center;">Lowercase</th>
<th style="text-align: center;">Uppercase</th>
<th style="text-align: center;">English</th>
<th style="text-align: center;">IPA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td>
<td style="text-align: center;"><span class="math inline">\(A\)</span></td>
<td style="text-align: center;"><span class="math inline">\(alpha\)</span></td>
<td style="text-align: center;"><strong>/'ælfə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\beta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(B\)</span></td>
<td style="text-align: center;"><span class="math inline">\(beta\)</span></td>
<td style="text-align: center;"><strong>/'bi:tə/or/'beɪtə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(gamma\)</span></td>
<td style="text-align: center;"><strong>/'gæmə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(delta\)</span></td>
<td style="text-align: center;"><strong>/'deltə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(E\)</span></td>
<td style="text-align: center;"><span class="math inline">\(epsilon\)</span></td>
<td style="text-align: center;"><strong>/'epsɪlɒn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(Z\)</span></td>
<td style="text-align: center;"><span class="math inline">\(zeta\)</span></td>
<td style="text-align: center;"><strong>/'zi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\eta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(eta\)</span></td>
<td style="text-align: center;"><strong>/'i:tə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(theta\)</span></td>
<td style="text-align: center;"><strong>/'θi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(9\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\iota\)</span></td>
<td style="text-align: center;"><span class="math inline">\(I\)</span></td>
<td style="text-align: center;"><span class="math inline">\(iota\)</span></td>
<td style="text-align: center;"><strong>/aɪ'əʊtə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(10\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td>
<td style="text-align: center;"><span class="math inline">\(K\)</span></td>
<td style="text-align: center;"><span class="math inline">\(kappa\)</span></td>
<td style="text-align: center;"><strong>/'kæpə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(11\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(lambda\)</span></td>
<td style="text-align: center;"><strong>/'læmdə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(12\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(M\)</span></td>
<td style="text-align: center;"><span class="math inline">\(mu\)</span></td>
<td style="text-align: center;"><strong>/mju:/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(13\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\nu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(nu\)</span></td>
<td style="text-align: center;"><strong>/nju:/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(14\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(xi\)</span></td>
<td style="text-align: center;"><strong>/ksi/or/'zaɪ/or/'ksaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(15\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omicron\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omicron\)</span></td>
<td style="text-align: center;"><strong>/əu'maikrən/or/'ɑmɪ,krɑn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(16\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(pi\)</span></td>
<td style="text-align: center;"><strong>/paɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(17\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\rho\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P\)</span></td>
<td style="text-align: center;"><span class="math inline">\(rho\)</span></td>
<td style="text-align: center;"><strong>/rəʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(18\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(sigma\)</span></td>
<td style="text-align: center;"><strong>/'sɪɡmə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(19\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\tau\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(tau\)</span></td>
<td style="text-align: center;"><strong>/tɔ:/or/taʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(20\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(upsilon\)</span></td>
<td style="text-align: center;"><strong>/'ipsilon/or/'ʌpsilɒn/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(21\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(phi\)</span></td>
<td style="text-align: center;"><strong>/faɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(22\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\chi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(X\)</span></td>
<td style="text-align: center;"><span class="math inline">\(chi\)</span></td>
<td style="text-align: center;"><strong>/kaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(23\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(psi\)</span></td>
<td style="text-align: center;"><strong>/psaɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(24\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omega\)</span></td>
<td style="text-align: center;"><strong>/'əʊmɪɡə/or/oʊ'meɡə/</strong></td>
</tr>
</tbody>
</table>
<h3 id="矩阵">矩阵</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">A = <span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
A = \begin{matrix}
a &amp; b\\
c &amp; d
\end{matrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">B = <span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{pmatrix}
a &amp; b\\
c &amp; d
\end{pmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C = <span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
C = \begin{vmatrix}
a &amp; b\\
c &amp; d
\end{vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">D = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
D = \begin{bmatrix}
a &amp; b\\
c &amp; d
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">E = <span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
E = \begin{Vmatrix}
a &amp; b\\
c &amp; d
\end{Vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">F = <span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
F = \begin{Bmatrix}
a &amp; b\\
c &amp; d
\end{Bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[A<span class="keyword">\ </span>b] = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c c c|c&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;13&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>1<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;23&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>2<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;31&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;32&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;33&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>3<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
[A\ b] = 
\begin{bmatrix}
\begin{array}{c c c|c}
a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
\end{array}
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c:c:c&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">d <span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> f <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hdashline</span></span><br><span class="line"> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span> i</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{c:c:c}
a &amp; b &amp; c \\ 
\hline
d &amp; e &amp; f \\
\hdashline
 g &amp; h &amp; i
\end{array}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">L<span class="built_in">_</span>&#123;n<span class="keyword">\times</span> n&#125; = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;1n&#125; <span class="keyword">\\</span> </span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;2n&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span><span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;n2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;nn&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
L_{n\times n} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ 
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ 
\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{bmatrix} -\frac{1}{2}(x^{(1)}(1)+x^{(1)}(2)) &amp; 1 \\  -\frac{1}{2}(x^{(1)}(2)+x^{(1)}(3)) &amp; 1  \\  \vdots &amp; \vdots \\ -\frac{1}{2}(x^{(1)}(17)+x^{(1)}(18)) &amp; 1  \\  \end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
Y = \begin{bmatrix}
x^{(0)}(2) \\ 
x^{(0)}(3)  \\ 
\vdots \\
x^{(0)}(18)  \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\textbf</span>&#123;u&#125;&#125; = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line">=<span class="keyword">\textbf</span>&#123;(B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="keyword">\textbf</span>&#123;)&#125;<span class="built_in">^</span>&#123;-1&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;Y&#125;</span><br><span class="line">=<span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\textbf{u}} = 
\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
=\textbf{(B}^{T}\textbf{B}\textbf{)}^{-1}\textbf{B}^{T}\textbf{Y}
=\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;a&#125;=<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125;= <span class="keyword">\\</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{a}=\\
\hat{b}= \\
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;dx<span class="built_in">^</span>&#123;(1)&#125;&#125;&#123;dt&#125;+<span class="keyword">\hat</span>&#123;a&#125;x<span class="built_in">^</span>&#123;(1)&#125;=<span class="keyword">\hat</span>&#123;b&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{dx^{(1)}}{dt}+\hat{a}x^{(1)}=\hat{b}
\]</span></p>
<h3 id="列式方程组">列式/方程组</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= (x+1)<span class="built_in">^</span>2<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>= x<span class="built_in">^</span>2 + 2x + 1</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= (x+1)^2\\
&amp;= x^2 + 2x + 1
\end{aligned}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">a <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if b&#125;<span class="keyword">\\</span></span><br><span class="line">b <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if a&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(x) = \begin{cases}
a &amp;\text{if b}\\
b &amp;\text{if a}\\
\end{cases}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x + 2y <span class="built_in">&amp;</span>= 1<span class="keyword">\\</span></span><br><span class="line">3x - y <span class="built_in">&amp;</span>= 5</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
x + 2y &amp;= 1\\
3x - y &amp;= 5
\end{aligned}
\end{cases}
\]</span></p>
<h3 id="注释图片">注释图片</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em;</span></span></span><br><span class="line"><span class="string"><span class="tag">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-20210531181704173&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span><br><span class="line"><span class="string"><span class="tag">    display: inline-block;</span></span></span><br><span class="line"><span class="string"><span class="tag">    color: #999;</span></span></span><br><span class="line"><span class="string"><span class="tag">    padding: 2px;&quot;</span>&gt;</span>注释<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center>
<img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/02/20/23-32-35/图片地址" alt="image-20210531181704173"> <br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
注释
</div>
</center>
<h3 id="字体">字体</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字体名</th>
<th style="text-align: center;">样式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="修饰符">修饰符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\theta</span>&#125;</span><br><span class="line"><span class="keyword">\widehat</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;y&#125;</span><br><span class="line"><span class="keyword">\overline</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\tilde</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\widetilde</span>&#123;ac&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\acute</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\check</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\grave</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\dot</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\ddot</span>&#123;a&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\theta}
\widehat{AB}
\\
\bar{y}
\overline{AB}
\\
\tilde{a}
\widetilde{ac}
\\
\bar{a}
\acute{a}
\check{a}
\grave{a}
\\
\dot{a}
\ddot{a}
\]</span></p>
<h3 id="括号">括号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">(</span><br><span class="line"><span class="keyword">\big</span>(</span><br><span class="line"><span class="keyword">\Big</span>(</span><br><span class="line"><span class="keyword">\bigg</span>(</span><br><span class="line"><span class="keyword">\Bigg</span>(</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">[]</span><br><span class="line">&lt;&gt;</span><br><span class="line">|绝对值|</span><br><span class="line"><span class="keyword">\&#123;</span><span class="keyword">\&#125;</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lgroup</span> x <span class="keyword">\rgroup</span></span><br><span class="line"><span class="keyword">\lVert</span> a <span class="keyword">\rVert</span></span><br><span class="line"><span class="keyword">\lceil</span> 2.6 <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> 1.2 <span class="keyword">\rfloor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ulcorner</span></span><br><span class="line"><span class="keyword">\urcorner</span></span><br><span class="line"><span class="keyword">\llcorner</span></span><br><span class="line"><span class="keyword">\lrcorner</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
(
\big(
\Big(
\bigg(
\Bigg(
\\
[]
&lt;&gt;
|绝对值|
\{\}
\\
\lgroup x \rgroup
\lVert a \rVert
\lceil 2.6 \rceil
\lfloor 1.2 \rfloor
\\
\ulcorner
\urcorner
\llcorner
\lrcorner
\end{gather*}
\]</span></p>
<h3 id="偏微分">偏微分</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> u&#125;&#123;<span class="keyword">\partial</span> t&#125;= h<span class="built_in">^</span>2 <span class="keyword">\left</span>( <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; +<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125;+ <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> z<span class="built_in">^</span>2&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2}+ \frac{\partial^2 u}{\partial z^2}\right)
\]</span></p>
<h3 id="图形">图形</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Box</span></span><br><span class="line"><span class="keyword">\square</span></span><br><span class="line"><span class="keyword">\blacksquare</span></span><br><span class="line"><span class="keyword">\triangle</span></span><br><span class="line"><span class="keyword">\triangledown</span></span><br><span class="line"><span class="keyword">\blacktriangle</span></span><br><span class="line"><span class="keyword">\diamond</span></span><br><span class="line"><span class="keyword">\Diamond</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\bigstar</span></span><br><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\bullet</span></span><br><span class="line"><span class="keyword">\bigcirc</span></span><br><span class="line"><span class="keyword">\bigodot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Box
\square
\blacksquare
\triangle
\triangledown
\blacktriangle
\diamond
\Diamond
\star
\bigstar
\circ
\bullet
\bigcirc
\bigodot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\diamondsuit</span></span><br><span class="line"><span class="keyword">\clubsuit</span></span><br><span class="line"><span class="keyword">\heartsuit</span></span><br><span class="line"><span class="keyword">\spadesuit</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\diamondsuit
\clubsuit
\heartsuit
\spadesuit
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\angle</span></span><br><span class="line"><span class="keyword">\measuredangle</span></span><br><span class="line"><span class="keyword">\top</span></span><br><span class="line"><span class="keyword">\bot</span></span><br><span class="line"><span class="keyword">\infty</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\angle
\measuredangle
\top
\bot
\infty
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\checkmark</span></span><br><span class="line"><span class="keyword">\dagger</span></span><br><span class="line"><span class="keyword">\ddagger</span></span><br><span class="line"><span class="keyword">\yen</span></span><br><span class="line"><span class="keyword">\$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\checkmark
\dagger
\ddagger
\yen
\$
\]</span></p>
<h3 id="变换符号">变换符号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%拉氏变换：</span></span><br><span class="line"><span class="keyword">\mathscr</span>&#123;L&#125;&#123;f(t)&#125;</span><br><span class="line"><span class="keyword">\mathcal</span>&#123;L&#125;</span><br><span class="line"><span class="comment">%傅里叶变换：</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathscr{L}\{f(t)\}\quad
\mathcal{L}
\]</span></p>
<h1 id="typroa框图博客不支持">typroa框图（博客不支持）</h1>
<h3 id="流程图">流程图</h3>
<p>语法说明：</p>
<ul>
<li>graph LR： 这一行说明要绘制的图形的方向。
<ul>
<li>LR：从左到右，left to right</li>
<li>RL：从右到左，right to left</li>
<li>TB：从上到下，top to bottom</li>
<li>BT：从下到上，bottom to top</li>
</ul></li>
<li>定义节点：有两种定义节点的方式
<ul>
<li>可以直接输入文字信息作为节点名称: node1</li>
<li>也可以在节点名称前加一个id的形式：id2(node2)，这样后续可以通过id1来引用node1这个节点。</li>
</ul></li>
<li>节点图形形状：
<ul>
<li>默认：方形</li>
<li>(node2）: 圆角</li>
<li>{[node3]) ：椭圆</li>
</ul></li>
<li>条件节点：在绘制流程图中会经常用到条件节点，在Mermaid中也可以实现的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234024945-16458036280891.png" alt="image-20220225234024945"><figcaption aria-hidden="true">image-20220225234024945</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line">para=&gt;parallel: parallel tasks</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;para</span><br><span class="line">para(path1, bottom)-&gt;sub1(right)-&gt;op1</span><br><span class="line">para(path2, top)-&gt;op1</span><br><span class="line">para(path3, top)-&gt;op1</span><br><span class="line">para(path4, top)-&gt;op1</span><br><span class="line">para(path5, top)-&gt;op1</span><br><span class="line">para(path6, top)-&gt;op1</span><br><span class="line">para(path7, top)-&gt;op1</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234115328-16458036772432.png" alt="image-20220225234115328"><figcaption aria-hidden="true">image-20220225234115328</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2022/02/17/11-07-35/</url>
    <content><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="链表">链表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> a, <span class="type">int</span> b, Node* c) : <span class="built_in">coef</span>(a), <span class="built_in">expn</span>(b), <span class="built_in">next</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Node*&amp; head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num; std::cin &gt;&gt; num;<span class="comment">//每个链表中数字的个数</span></span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin &gt;&gt; coef &gt;&gt; expn;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(coef, expn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">            new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(Node*&amp; head1, Node*&amp; head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* ptr1 = head1;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head2-&gt;expn == ptr1-&gt;expn)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr1-&gt;coef = ptr1-&gt;coef + head2-&gt;coef;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(head2-&gt;coef, head2-&gt;expn, head1);</span><br><span class="line">            head1 = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* x1 = <span class="literal">NULL</span>, * x2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Create</span>(x1); <span class="built_in">Create</span>(x2);</span><br><span class="line">    <span class="built_in">Add</span>(x1, x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">tree</span>(<span class="type">char</span> a, tree *b, tree *c) : <span class="built_in">data</span>(a), <span class="built_in">left</span>(b), <span class="built_in">right</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    tree *left;</span><br><span class="line">    tree *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(tree *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">tree</span>(c, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(tree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;tree *&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处输出是前序遍历</span></span><br><span class="line">            cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//此处输出是中序遍历</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Creat</span>(root);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的非递归前序遍历">树的非递归前序遍历</h4>
<ol type="1">
<li>创建一个栈
<ol type="1">
<li>只要节点不为空或者栈不为空
<ol type="1">
<li>如果节点为空
<ol type="1">
<li>打印</li>
<li>入栈</li>
<li>左走</li>
</ol></li>
<li>如果节点不为空
<ol type="1">
<li>取栈首</li>
<li>右走</li>
<li>出栈</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="图">图</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> vertex[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> edge[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vertex_num, edge_num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G-&gt;vertex_num;</span><br><span class="line">    cin &gt;&gt; G-&gt;edge_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G-&gt;vertex[i];</span><br><span class="line">        G-&gt;visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">            G-&gt;edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;edge_num; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G-&gt;edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; G-&gt;vertex[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;edge[i][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(queue&lt;<span class="type">int</span>&gt;&amp; queue, <span class="type">int</span> i, Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    queue.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">if</span> (!G-&gt;visited[i])<span class="comment">//这个模块起名为访问列吧</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(queue, i, G);<span class="comment">//每列入队</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())<span class="comment">//行入队后检查队是否为空，队首作为行的检测依据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">                    <span class="keyword">if</span> (G-&gt;edge[queue.<span class="built_in">front</span>()][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])<span class="comment">//这个模块起名为访问行</span></span><br><span class="line">                        <span class="built_in">visit</span>(queue, j, G);<span class="comment">//每行入队</span></span><br><span class="line">                cout &lt;&lt; G-&gt;vertex[queue.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//测试数据：9 15  A B C D E F G H I 0 1 0 5 1 2 1 8 1 6 2 3 2 8 3 4 3 7 3 6 3 8 4 5 4 7 5 6 6 7</span></span><br><span class="line">    Graph G;</span><br><span class="line">    <span class="built_in">Create</span>(&amp;G);</span><br><span class="line">    <span class="comment">//每次只能选择一个运行</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G, 0);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接矩阵的广度遍历">邻接矩阵的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>遍历 i (列)所有节点，对于未访问的节点进行下述操作
<ol type="1">
<li>打印 i 处节点并设置为访问过</li>
<li>将数字 i 入队</li>
<li>队列不为空时执行如下操作
<ol type="1">
<li>将队首元素赋值给 i</li>
<li>遍历 j (行)所有节点，当 i 和 j 有关系且 j 处节点未访问时执行如下操作
<ol type="1">
<li>打印 j 处节点并设置为访问过</li>
<li>将数字 j 入队</li>
</ol></li>
<li>队首出队</li>
</ol></li>
</ol></li>
</ol>
<h4 id="邻接矩阵的深度遍历">邻接矩阵的深度遍历</h4>
<ol type="1">
<li>遍历 i (列)所有节点，未访问节点进入 DFS(G,i)</li>
<li>DFS 函数： <br>1. 打印进入 DFS 的节点并设置为访问 <br>2. 遍历 j (行)所有节点，当 i 和 j 有关系且未访问的节点进入 DFS(G,j)</li>
</ol>
<h3 id="邻接表">邻接表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    list&lt;Vertex*&gt; edge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(vector&lt;Vertex&gt;&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> vertex_num; cin &gt;&gt; vertex_num;</span><br><span class="line">    <span class="type">int</span> edge_num; cin &gt;&gt; edge_num;</span><br><span class="line"></span><br><span class="line">    Vertex temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp.data;</span><br><span class="line">        temp.visited = <span class="literal">false</span>;</span><br><span class="line">        G.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * edge_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G[v1].edge.<span class="built_in">push_back</span>(&amp;G[v2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vertex* <span class="title">next_vertex</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> *iiter;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vertex != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vertex-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        vertex-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_level</span><span class="params">(queue&lt;Vertex*&gt;&amp; queue, Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>((*iiter));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Vertex*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(vertex);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>()-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        queue.<span class="built_in">front</span>()-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">get_level</span>(queue, queue.<span class="built_in">front</span>());</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 9 15 A B C D E F G H I 0 1 0 5 1 0 1 2 1 6 1 8 2 1 2 3 2 8 3 2 3 4 3 6 3 7 3 8 4 3 4 5 4 7 5 0 5 4 5 6 6 1 6 3 6 5 6 7 7 3 7 4 7 6 8 1 8 2 8 3</span></span><br><span class="line">    vector&lt;Vertex&gt; G;</span><br><span class="line">    <span class="built_in">Creat</span>(G);</span><br><span class="line">    <span class="comment">//每次只能运行一个</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G[0]);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表的深度遍历">邻接表的深度遍历</h4>
<p>·只要顶点不为空，打印顶点并设置为访问过；将下一个顶点进入该函数</p>
<h4 id="邻接表的广度遍历">邻接表的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>第一个顶点入队</li>
<li>队不为空，执行下述操作
<ol type="1">
<li>取队首顶点</li>
<li>打印队首顶点并设置为访问过</li>
<li>获得下一层顶点</li>
<li>队首出队</li>
</ol></li>
</ol>
<h4 id="next_node">next_node</h4>
<p>查链表，找到未访问顶点；设置为访问，返回该顶点</p>
<h4 id="get_level">get_level</h4>
<p>查链表，找到未访问顶点；设置为访问，将该顶点入队</p>
<h2 id="排序">排序</h2>
<h3 id="快排">快排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sbit = begin;</span><br><span class="line">        <span class="type">int</span> pivot = arry[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = begin; j &lt; end; j++)</span><br><span class="line">            <span class="keyword">if</span> (arry[j] &lt; pivot)</span><br><span class="line">              &#123;<span class="built_in">swap</span>(arry[j], arry[sbit]); sbit++;&#125;</span><br><span class="line">              <span class="comment">//每个数字与pivot比较，较小的与sbit交换</span></span><br><span class="line">              <span class="comment">//将pivot与sbit交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arry[sbit], arry[end]);</span><br><span class="line">        <span class="built_in">sort</span>(arry, begin, sbit - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(arry, sbit + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">8</span>] = &#123; <span class="number">27</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">81</span>, <span class="number">72</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排">堆排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heap</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = begin;</span><br><span class="line">    <span class="type">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[right] &amp;&amp; right &lt;= end) left++;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[root]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arry[left], arry[root]);</span><br><span class="line">            root = left;</span><br><span class="line">            left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, i, end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arry[<span class="number">0</span>], arry[i]);</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, <span class="number">0</span>, i<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">11</span>] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>堆排序</li>
<li>得最大堆的方法：
<ol type="1">
<li>范围：从 非叶子节点 到 根节点<br>
</li>
<li>调整对象：循环因子 到 表</li>
</ol></li>
<li>排序的方法：
<ol type="1">
<li>范围：从 表尾 到 根节点前</li>
<li>调整对象：无序首 到 无序尾</li>
</ol></li>
<li>维持堆的方法：</li>
</ol>
]]></content>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论</title>
    <url>/2022/04/10/11-17-01/</url>
    <content><![CDATA[<h1 id="概率与统计">概率与统计</h1>
<h3 id="随机实验">随机实验</h3>
<p>满足条件：</p>
<ol type="1">
<li>可以被重复；</li>
<li>具有多种可能结果并均明确可知；</li>
<li>试验结果不可预先获知。</li>
</ol>
<p>随机实验可能出现的每一种结果称为<strong>样本点</strong>，每一个样本点都彼此不相容，因而它是构成试验结果的最基础原子，故而样本点也被称为<strong>基本事件</strong>。</p>
<p>所有样本点（也即所有的可能结果）的集合就被称为<strong>样本空间</strong></p>
<p>一次试验可能出现的结果称为<strong>随机事件</strong>，随机事件是一个集合，内部元素均为随机实验的样本点</p>
<p>为什么要引入样本空间：</p>
<p>引入样本空间是为了给予“随机”这一相对较为暧昧的机制一个严格的数学范围。在这以后，一切事件的概率才得以在其相对应的样本空间之下具备良好的定义。</p>
<p>这就像样本空间（Sample space）产生出了事件域，而我们讨论相应的事件概率，就只在其定义的样本空间下具有意义，而同一事件在不同样本空间下，其发生的概率可能截然不同</p>
<p>样本空间的引入实际上是在为概率的定义提供了一个严格的范围。</p>
<p>一个样本空间可以是有限的，可数无穷的和不可数无穷的</p>
<p>假如S是可数的，包括有限和可数无穷的，那么S为一个离散的样本空间</p>
<p>假如S是不可数的，即不可数无穷的，那么S为一个连续的样本空间</p>
<p>对于随机试验的结果，即随机事件，其描述可以由多个观测量组成，因此样本空间可以是有不同维度的，维度数即描述一个随机时间的测量量的数目</p>
<p>概率的定义：（概率的本质）</p>
<p>直觉：概率就是事件发生的可能性。</p>
<p>古典概型：</p>
<p>进行<span class="math inline">\(n\)</span>次随机实验，得到的某一结果的次数记作<span class="math inline">\(N_k(n)\)</span>，则得到该结果的相对次数为<span class="math inline">\(f_k(n)=\frac{N_k(n)}{n}\)</span></p>
<p>当<span class="math inline">\(n\)</span>的数值足够大时，<span class="math inline">\(f_k(n)\)</span>则收敛于一个稳定的数值，即<span class="math inline">\(lim_{n-&gt;\infty}f_k(n)=p_k\)</span>，<span class="math inline">\(p_k\)</span>称作概率</p>
<p>古典概型的前提：</p>
<ol type="1">
<li>在古典概型的样本空间中，样本点也即基本事件的个数是有限的（骰子只能掷出6个数字）</li>
<li>每个样本点也即每个基本事件发生的可能性是相等的（投出6和投出1或任意其它一种结果的可能性完全一致）</li>
</ol>
<p>古典概型是<strong>先验</strong>的，因为我们<strong>先验</strong>的认为，这个骰子掷出任意一个数字的可能性都是相同的。并且同样<strong>先验</strong>的确定，掷出任意一个数字的频率都会稳定于古典概型计算出的这个先验概率附近。</p>
<p>先验来自于我们的直觉，来自于实践中的观察</p>
<p><strong>后验</strong>认为，对于事件发生的先验假设，我们不应当存在任何的偏好——即基本事件等可能这种事，并不是理所当然的</p>
<p>后验中我们可以随意假设一个估计性质的开始概率，重要的是，我们可以通过后续的重复试验，来不断的更新纠正这一概率，而当通过试验获取的信息趋近于无穷时，我们最终就可以获得一个收敛于某个具体数值的<strong>后验</strong>概率。</p>
<p>让我们能够摆脱“可能性”的束缚，从而绕开先验与后验的争论，来在数学上精确的定义概率呢？</p>
<p>在有了样本空间将事件构造成的集合以后，再通过测度的方式，将它们映射至0到1取值范围内的实数域 <span class="math inline">\([0,1]\)</span>上。</p>
<p>若以这样的方式来定义概率，我们不就可以将它从事件发生可能性这样的束缚上解脱出来，从而获得一个纯粹的数学定义。为了实现这种测度的构造，就可以人为的对样本空间到实数域的映射规则进行规定，即：</p>
<ol type="1">
<li>概率必然是非负的，即 <span class="math inline">\(P(A)\ge 0\)</span></li>
<li>样本空间所代表的全集，概率规定为1，即 <span class="math inline">\(P(\Omega)=1\)</span></li>
<li>对于任意可列的互不相容事件（即两两交集均为 <span class="math inline">\(\varnothing\)</span> 的子集），它们并集的概率等于它们概率的和，即 <span class="math inline">\(P(A\cup B)=P(A)+P(B)\)</span></li>
</ol>
<p>满足这三个条件的映射，即有概率 <span class="math inline">\(P\)</span> ，这也被称为概率的公理化定义。</p>
<p>也由于这种定义的实质就是将样本空间对实数进行映射，故而这种映射也被称为<strong>概率测度</strong>。</p>
<p>条件概率公式所反映的，实际上是决策树的<strong>剪枝</strong>过程。而条件概率的本质，则是<strong>由于前提事件的发生所导致的待计算事件其样本点与样本空间的同时缩小（如同上文中文氏图所示的右侧聚焦过程）</strong>。</p>
<p><strong>全概率公式</strong>：</p>
<p>假设：样本空间 <span class="math inline">\(S\)</span> 有一个完备的事件组 <span class="math inline">\(A_1,A_2,A_3\)</span>：也就是样本空间被这三个事件瓜分完了</p>
<p>满足两个条件：三个事件：</p>
<ol type="1">
<li><span class="math inline">\(A_1 \cup A_2 \cup A_3=\Omega\)</span></li>
<li><span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span></li>
</ol>
<p>则又有一事件 <span class="math inline">\(B\)</span> 时，<span class="math inline">\(P(B)=P(B \cap \Omega)=P[B\cup (A_1 \cup A_2 \cup A_3)]=P(BA_1 \cup BA_2 \cup BA_3)\)</span></p>
<p>因为 <span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span>，所以 <span class="math inline">\(BA_1 \cup BA_2 \cup BA_3=\varnothing\)</span></p>
<p>所以：<span class="math inline">\(P(BA_1 \cup BA_2 \cup BA_3)=P(BA_1)+P(BA_2)+P(BA_3)\)</span></p>
<p>由条件概率公式可得：</p>
<p><span class="math inline">\(P(B)=P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)\)</span></p>
<p>即全概率公式事实上是一种<strong>对事件的先验分解</strong>。</p>
<p>全概率公式的使用条件，就是连续做多次实验，可以画出决策树，然后每一种分支可能性会发生变化，即前一次的选择会对下一次的选择产生影响；这是若求解第二轮即以后某个结果发生的可能性，则使用全概率公式</p>
<p>贝叶斯公式：</p>
<p>贝叶斯公式是后验的，即，我们已经做了实验，然后通过实验结果我们不断去修正导致这一结果发生的某些概率值</p>
<p>贝叶斯公式可以由全概率公式变形得来： <span class="math display">\[
\begin{aligned}
P(A_1|B)&amp;=\frac{P(A_1B)}{P(B)}\\
&amp;=\frac{P(A_1B)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}\\
&amp;=\frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}
\end{aligned}
\]</span></p>
<p>随机变量：随机变量的本质实际上就是<strong>随机事件的数字化</strong>。</p>
<p>现实世界中各色各样具象的随机事件，可以被映射成数学世界中抽象的数字，而这种映射规则就叫做随机变量。</p>
<p>离散随机变量的（概率分布律）概率质量函数（<span class="math inline">\(pmf\)</span>）：</p>
<p>离散性随机变量记作 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的可能值是一个可数集合中的元素：<span class="math inline">\(S_X={x_1,x_2,x_3...}\)</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span></th>
<th><span class="math inline">\(x=1\)</span></th>
<th><span class="math inline">\(x=0\)</span></th>
<th><span class="math inline">\(x=2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(pmf\)</span></td>
<td><span class="math inline">\(P(x=1)=0.125\)</span></td>
<td><span class="math inline">\(p(x=0)=0.25\)</span></td>
<td><span class="math inline">\(P(x=2)=0.625\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(pmf\)</span> 的性质：</p>
<ul>
<li><p><span class="math display">\[
对于所有\;x\; 都有 \;P_X(x)\ge 0
\]</span></p></li>
<li><p><span class="math display">\[
\sum_{x\in S}P_X(x)=1
\]</span></p></li>
<li><p><span class="math display">\[
P(X\;in\;B)=\sum_{x\in B}P_X(x)\;其中B\subset S_X 
\]</span></p></li>
</ul>
<p>随机变量可以是离散的，连续的和混合的</p>
<p>累积分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function），常被使用在随机变量的正式定义中，可以处理三种类型的随机变量</p>
<p>一个离散性随机变量的 <span class="math inline">\(pmf\)</span> 是由 <span class="math inline">\(\{X=b\}\)</span> 来定义的，累计分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function）则是由 <span class="math inline">\(\{X\le b\}\)</span> 来定义的。</p>
<p>累计分布函数的优点在于它不局限于离散型随机变量，而是可以在所有类型的随机变量中使用</p>
<ol type="1">
<li><span class="math inline">\(F_X(x)\)</span>必然是一个单调不减函数——因概率不可为负，随着对应样本点的增多，概率的累加必然是单调不减的；</li>
<li><span class="math inline">\(F_X(x)\)</span> 必然是一个右连续函数；</li>
<li><span class="math inline">\(\lim_{n \to -\infty}F_X(x)=0\)</span>，<span class="math inline">\(\lim_{n \to \infty}F_X(x)=1\)</span> ——即对应样本点集合为空时，概率必然为0，而对应样本点集合为整个样本空间时，概率必然为1。</li>
</ol>
<p>可以看到，无论分布函数以何种形式构造，又呈现出何种性质，其最最核心的效用，就是为了能够良好的表示出样本空间的这一性质： <span class="math display">\[
P_1+P_2+P_3+...+P_n=\sum_iP_i=1
\]</span> 即实现样本空间 <span class="math inline">\(S\)</span> 对应的概率<strong>归向于1</strong>，从而完成样本空间向值域 <span class="math inline">\([0,1]\)</span> 的映射。因此，分布函数的本质实际上是<strong>随机变量的归一化</strong>。</p>
<p>而当随机变量由离散型扩展至连续型时，在把握到分布函数的本质是样本点概率的累加函数以后，便可以推测连续型随机变量的分布函数 <span class="math inline">\(F_X(x)\)</span> 必然会表现为一种积分形式。</p>
<p>但是与离散型概率分布中，每个随机变量对应着一个确定的概率值所不同，若以类似的方式来通过分布函数计算连续型随机变量中任意一点的概率，即用这一点的分布函数值减去这一点处左极限的分布函数值： <span class="math display">\[
P\{x=x_0\}=F_X(x_0)-\lim_{n \to x_0^-}F_X(x_0)
\]</span> 由于 <span class="math inline">\(F_X(x)\)</span> 是连续的概率累加，因此它在性质上也必然是一个非负不减的连续函数，故根据连续的性质，有： <span class="math display">\[
F_X(x_0)=\lim_{n \to x_0^+}F_X(x_0)= \lim_{n \to x_0^-}F_X(x_0)
\]</span> 故有： <span class="math display">\[
P\{x=x_0\}=0
\]</span> 由此可以看到，无论我们怎么计算，在连续型随机变量的分布函数上想要直接计算某一点处的概率，它将始终都会是0。</p>
<p>从这一结论，你应该就能明白，在概率论的开篇中，我们提到通过引入测度，将事件的概率测度与它在现实中发生的可能性这两个概念分开具有怎样重要的意义。</p>
<p>可以看到，在连续型随机变量中，某一点出的概率为0，并不意味着它在事件发生的角度来看是不可能的，而只是意味着这一点处的概率测度为0。</p>
<p>而之所以会出现概率测度为0的原因，是因为在这里一开始所着眼的计算目标就错了。打个比方来说就相当于，你并不会去计算一个点的长度，不会去计算一条线的面积，不会去计算一个面的体积。换句话说，在连续型随机变量中，计算某一点处的概率就相当于在求一条线的面积。</p>
<p>在认识到这一点之后，为了刻画连续型随机变量中某点处局部的概率性质就需要另外的工具，而这个工具在微积分的阶段就已经准备好早已被我们熟稔于胸——当然就是导数，即有： <span class="math display">\[
F^{&#39;}_X(x_0)=\lim_{x\to x_0}\frac{F_X(x)-F_X(x_0)}{x-x_0}
\]</span> 换句话说，对于连续型随机变量，我们用以刻画在一点处局部性质的量不是概率，而应该是<strong>概率测度的变化率。</strong></p>
<p>借用我们在散度与测度一章中的两个相类似的例子来说，就是：</p>
<ul>
<li>在位移运动中，刻画某一瞬时性质的不是位移而是速度；</li>
<li>在有质物体中，刻画某一质点性质的不是质量而是密度。</li>
</ul>
<p>也因此，以质量与密度的关系来考量概率与概率变化率，才会将连续型随机变量的分布函数，一个变上限积分：<span class="math inline">\(F(x)=\int^x_{-\infty}f(t)dt\)</span> 的导函数： <span class="math inline">\(F&#39;(x)=f(x)\)</span> 命名为<strong>概率密度</strong>。</p>
<p>更要值得一提的是，如果用离散型随机变量的概率分布即：</p>
<p>一个随机变量对应一个确定的概率测度 <span class="math inline">\(x_i\sim P_i\)</span></p>
<p>来进行类比的话，连续型随机变量的概率分布实际上应当为：</p>
<p>一个随机变量对应其<strong>附近领域</strong>的概率测度 <span class="math inline">\(x_i\sim f(x_i)dx_i\)</span></p>
<p>而非直接对应概率密度函数 <span class="math inline">\(f(x)\)</span>，从这个类比，可以更直观的认为，若视离散型随机变量的分布函数为一个楼层分明的阶梯，那么连续型随机变量的分布函数就是一个将楼层无限增加细分从而使层次分明的阶梯最终转换为一个<strong>平滑化</strong>的斜坡。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学笔记</title>
    <url>/2022/02/21/08-25-17/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="基本概念">基本概念</h3>
<p>组态：</p>
<ul>
<li>定义：晶体管接入电路的方法（晶体管接入电路的形态）。</li>
<li>种类：共基组态（共基极的接入方法）、共射组态和共集组态</li>
<li>F&amp;Q：
<ul>
<li>共"的含义——共在组态的概念中指端口共用。
<ul>
<li>进一步解释端口共用："将 BJT 晶体管看作一个双端口网络模型进行分析时，需要输入输出各两个端口，而晶体管有 3 个端口，因此需要一个端口共用。"</li>
</ul></li>
<li>在组态概念下我们要讨论的问题是什么：
<ul>
<li>首先明确组态概念下讨论的是晶体管本身的伏安特性，谈论组态时是不含不涵盖除晶体管之外的其他元器件的。</li>
<li>不同组态下晶体管展现出的不同的输入输出特性（伏安特性）是我们研究的重点</li>
</ul></li>
</ul></li>
</ul>
<p>电路负载线：</p>
<ul>
<li>定义：电路负载线表征电路对元器件施加的约束，这个约束表现为一种伏安关系</li>
<li>方法：负载线可以由基本的电路定律得到（如基尔霍夫定律）</li>
<li>tips：使用电路定律得到的负载线公式可以整理成针对于某一负载伏安关系的一次函数: <span class="math inline">\(i=k v+b\)</span></li>
</ul>
<p>器件的伏安特性与</p>
<p>耦合：</p>
<ul>
<li>定义：耦合就是连接的意思</li>
<li>耦合电容：晶体管电路中的耦合电容起到连接直流源与交流源的作用</li>
</ul>
<p>偏置与静态工作点：</p>
<ul>
<li><p>偏置的含义：偏置是一种利用直流电压为电路设置固定直流电流和电压的广义称谓</p></li>
<li><p>讨论偏置时的研究对象我们的研究对象不是电子元器件，而是某一电路</p></li>
<li><p>偏置操作不但在"电路网络（黑箱）"外加入了直流电源，而且配合了电阻器件进行约束。</p>
<ul>
<li>以晶体管的偏置为例：直流电源与电阻一起构成了晶体管电路，该对晶体管工作范围进行了约束，这种约束可以使用负载线来表示，并且可以通过数学形式变化将负载线与晶体管的输入输出特征曲线放在同一坐标轴下得到一个交点，称为静态工作点</li>
</ul></li>
<li><p>静态工作点的含义：</p>
<ul>
<li>偏置时设置的固定的电流与电压被称为静态工作点，标记为 Q</li>
<li>静态工作点由元器件伏安特性和电路伏安约束共同确定，对于特定的器件，静态工作点仅由电路的配置决定。</li>
<li>对于晶体管，配置不同的静态工作点有两个目标
<ul>
<li>第一个目标时让晶体管工作在特定的状态，在模拟电子技术中我们希望让晶体管工作在放大的工作状态</li>
<li>第二个目标是针对线性的放大工作范围，我们还要挑选一个合适的位置，不能使得放大的信号失真</li>
</ul></li>
</ul></li>
<li><p>晶体管放大要求（偏置要求）</p>
<ul>
<li><p>输入电压应该超过晶体管导通电压。</p>
<p>The input voltage should exceed <strong>cut-in voltage</strong> for the transistor to be <strong>ON</strong>.</p></li>
<li><p>BJT应该在有源区，作为一个放大器。</p>
<p>The BJT should be in the <strong>active region</strong>, to be operated as an <strong>amplifier</strong>.</p></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{gather*}
\begin{aligned}
I_C&amp;=I_{\sf{多子电流}}+I_{\sf{少子电流}}\\
   &amp;=\alpha I_E+I_{CBO}\\
   &amp;=\alpha (I_B+I_C)+I_{CBO}\\
\end{aligned}
\Rightarrow
I_C=\frac{\alpha}{1-\alpha}I_B+\frac{1}{1-\alpha}I_{CBO}=\beta I_B+I_{CEO}
\end{gather*}
\]</span> <span class="math inline">\(I_E=I_se^{v_{BE}/V_T}\)</span></p>
<p><span class="math inline">\(I_C=\alpha I_E+I_{CBO}\)</span></p>
<h3 id="稳定化stabilization">稳定化（Stabilization）</h3>
<p>为了让晶体管</p>
<blockquote>
<p>使操作点独立于温度变化或晶体管参数变化的过程被称为稳定。</p>
<p>The process of making the operating point independent of temperature changes or variations in transistor parameters is known as <strong>Stabilization</strong>.</p>
</blockquote>
]]></content>
      <tags>
        <tag>电子学</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学</title>
    <url>/2022/02/27/16-41-33/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="前言">前言</h3>
<p>本书主要参考尼曼（Donald A. Neamen）的《电子电路分析与设计（第四版）》（Microelectronics: Circuit Analysis And Design Forth Edition）写成。</p>
<h2 id="半导体器件及其基本应用">半导体器件及其基本应用</h2>
<h3 id="半导体">半导体</h3>
<p>在电路课和物理课上我们已经学习了一些电子器件，例如最典型的器件——电阻器。电阻器是导体，其最重要的性质“电阻”表示了导体对于电流的阻碍性质。除此之外我们还学习了电容和电感；电感的性质存在于线圈之中，线圈是使用导体制成的；电容则是导体极板中间夹着一个绝缘体介质形成。如此归纳，我们会发现在之前的课程之中，我们了解的范畴始终存在于导体和绝缘体之中，而半导体材料制作而成的器件却从未被提及。所以，在“半导体”这一节中，我们将注意力集中在半导体上，从研究半导体自身的性质开始，最终我们将得到一个简单的半导体器件。</p>
<p>正式开始本节前，我们简单地回顾一下中学的知识，以下这些是作者默认读者已经了解了的知识。</p>
<ul>
<li>导体中存在大量可以自由移动的电子，称之为自由电子（free electron）。自由电子在受到外电场或外磁场的作用时，能够在物质中自由移动。</li>
<li>导体中自由电子的定向移动形成了电流，电流（current）的定义式为 <span class="math inline">\(i=\frac{dq}{dt}\)</span>。</li>
<li>载流子（charge carrier）指可以自由移动的带有电荷的物质微粒，是物质中电流形成的原因，导体中的载流子是电子。</li>
<li>在半导体中存在两种载流子——电子（electron）和空穴（hole）。空穴是电子移动后留下的空位，从物理模型上可以将空穴看作是正电子。在半导体中，电子和空穴两种载流子共同形成半导体中的电流。</li>
</ul>
<h4 id="本征半导体intrinsic-semiconductor">本征半导体（intrinsic semiconductor）</h4>
<blockquote>
<p>本征半导体是指纯净（pure）的半导体</p>
</blockquote>
<p>本征半导体的概念是我们应当格外注意的，因为这不是一个偏日常化和口语化的词语，但是在这里它的含义却是十分简单——本征，不过就是纯净不含杂质的意思。</p>
<p>强调材料的纯度似乎是一件奇怪的事情，因为常识中我们通常认为提纯是必须的，无需额外强调的。例如我们不会强调一个钢筋的纯度，但是我们知道</p>
<p>本征半导体是指纯净的半导体，强调这个词似乎暗示着有一种不纯净的半导体的存在，并且这种不纯净的半导体的存在是十分有必要的。</p>
<h3 id="二极管及其基本电路">二极管及其基本电路</h3>
<p>TODO</p>
<h3 id="三极管及其基本电路">三极管及其基本电路</h3>
<p>TODO</p>
<h3 id="场效应管及其基本电路">场效应管及其基本电路</h3>
<p>TODO</p>
<h2 id="模拟电子技术">模拟电子技术</h2>
<p>TODO</p>
<h2 id="数字电子技术">数字电子技术</h2>
<p>TODO</p>
<h2 id="运算放大器电路">运算放大器电路</h2>
<p>分析顺序</p>
<ul>
<li>图像</li>
<li>公式</li>
<li>结论</li>
</ul>
<ol type="1">
<li><p>反相放大电路</p>
<ul>
<li><p>反相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1249-16473232199221.PNG" alt="IMG_1249" style="zoom: 25%;"></p></li>
<li><p>反相放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p>假设运算放大器是理想的，即</p>
<ul>
<li>开环增益 <span class="math inline">\(A_{od}=\infty\)</span>：故输入信号 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是相等的。且由于 <span class="math inline">\(v_2\)</span> 与地面连接，故 <span class="math inline">\(v_2\)</span> 是“接地”，而 <span class="math inline">\(v_1\)</span> 是“虚地”。</li>
<li>输入阻抗大小为 <span class="math inline">\(\infty\)</span>：流入运算放大器的电流为 <span class="math inline">\(0\)</span> 。</li>
</ul>
<p>理想运放约束+基尔霍夫定律可得： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{v_{i_1}-v_1}{R_1}=\frac{v_1-v_o}{R_2}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<ul>
<li>对于理想运放，闭环电压增益是运放外电阻比值的函数，与运放内部的参数无关。</li>
<li>增益中的负号表示 “反相” ，是反相放大电路名字的由来。</li>
<li>反相放大电路中没有耦合电容（就是电容，作用是耦合所以叫耦合电容），因此反相放大电路可以放大直流电压信号。</li>
</ul></li>
</ul></li>
<li><p>反相放大电路扩展——带 T 型网络的放大电路</p>
<ul>
<li><p>作为改进方案被提出的原因：</p>
<p>反相放大电路的增益 <span class="math inline">\(A_v\)</span> 为 <span class="math inline">\(-\frac{R_2}{R_1}\)</span>，那么如果我们的设计目标是设计一个闭环增益 <span class="math inline">\(A_v=-100\)</span> 且输入电阻 <span class="math inline">\(R_i=R_1=50k\Omega\)</span> 的反相放大电路。于是，反馈电阻 <span class="math inline">\(R_2\)</span> 就必须是 <span class="math inline">\(5M\Omega\)</span>。然而，这个电阻值对大多数实际电路来说太大了。为了解决这个问题我们提出了作为改进方案的带 T 型网络的放大电路。</p></li>
<li><p>带 T 型网络的放大电路的电路图如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1258.PNG" alt="IMG_1258" style="zoom:25%;"></p></li>
<li><p>设 <span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span> 和 <span class="math inline">\(R_4\)</span> 三个电阻的公共节点处电势为 <span class="math inline">\(v_x\)</span>，则: <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;i_2+i_3=i_4\\\\
&amp;\frac{v_1-v_x}{R_2}+\frac{v_x-v_o}{R_3}=\frac{v_x}{R_4}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<p>使用带 T 型网络的放大电路，可以在使用合理大小电阻的情况下获得更大的增益。</p></li>
</ul></li>
<li><p>同相放大电路；</p>
<ul>
<li><p>同相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1253-16473270320863.PNG" alt="IMG_1253" style="zoom: 25%;"></p></li>
<li><p>同相放大电路增益 <span class="math inline">\(A_v=\frac{R_2}{R_1}+1\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\begin{cases}
v_-=v_+=v_i\\\\
\frac{0-v_-}{R1}=\frac{v_--v_o}{R_2}\\
\end{cases}\\\\
&amp;get\quad A_v=\frac{v_o}{v_i}=\frac{R_2}{R_1}+1
\end{aligned}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>电压跟随器：</p>
<ul>
<li><p>电压跟随器连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1246.PNG" alt="IMG_1246" style="zoom:25%;"></p></li>
<li><p>电压跟随器增益 <span class="math inline">\(A_v\)</span>：</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>求和放大电路：</p>
<ul>
<li><p>求和放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1252.PNG" alt="IMG_1252" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}\)</span>：</p>
<p><span class="math display">\[
\sum_{j=1}^{n}\frac{v_{i_j}-0}{R_i}=\frac{0-v_o}{R_f}\\
get\quad v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>差分放大电路：</p>
<ul>
<li><p>差分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1244.PNG" alt="IMG_1244" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})\)</span>：</p>
<p>$$</p>
<span class="math display">\[\begin{aligned}
&amp;if\quad v_{i_2}=0,\;v_{i_1}\not=0\\

&amp;then\quad v_{o_1}=-\frac{R_2}{R_1}v_{i_1}\\\\\\

&amp;if\quad v_{i_2}\not=0,\;v_{i_1}=0\\

&amp;then\quad v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}\\\\\\

&amp;so\quad v_o=v_{o_1}+v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}-\frac{R_2}{R_1}v_{i_1}\\

&amp;To\quad satified\quad when\quad v_{i_1}=v_{i_2},v_o=0\,;so\quad \frac{R_4}{R_3}=\frac{R_2}{R_1}\\

&amp;Finally\quad v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})
\end{aligned}\]</span>
<p>$$</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>积分放大电路：</p>
<ul>
<li><p>积分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1254.PNG" alt="IMG_1254" style="zoom:25%;"></p></li>
<li><p>积分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=V_C-\frac{1}{RC}\int_{0}^{t}v_i(\tau)d\tau
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>微分放大电路：</p>
<ul>
<li><p>微分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1251.PNG" alt="IMG_1251" style="zoom:25%;"></p></li>
<li><p>微分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-RC\frac{dv_{i}}{dt}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>对数放大电路：</p>
<ul>
<li><p>对数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1247.PNG" alt="IMG_1247" style="zoom:25%;"></p></li>
<li><p>对数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-V_Tln\left(\frac{v_i}{I_SR_1}\right)
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>指数放大电路：</p>
<ul>
<li><p>指数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1257.PNG" alt="IMG_1257" style="zoom:25%;"></p></li>
<li><p>指数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-I_SR\cdot e^{v_i/V_T}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>仪用放大电路：</p>
<ul>
<li><p>仪用放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1256.PNG" alt="IMG_1256" style="zoom:25%;"></p></li>
<li><p>仪用放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=\frac{R_4}{R_3}\left(1+\frac{2R_2}{R_1}\right)(v_{i_2}-v_{i_1})
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
</ol>
<h2 id="集成电路偏置">集成电路偏置</h2>
<p>使用分立电子元器件对晶体管放大电路进行偏置时，我们通常使用的是分压电阻网络。在集成电路设计中，电阻的集成需要比晶体管更大的面积，因此我们更希望通过晶体管来配置放大电路。在接下来的设计中我们可以看到，晶体管可以构成恒流源和负载器件。</p>
<p>集成电路偏置和有源负载这一章节学习了在设计集成电路中需要使用到的<strong>晶体管恒流源——镜像电流源（Current Mirror）</strong>和<strong>晶体管电阻（负载）——有源负载</strong></p>
<p>关于集成电路的部分放到下一阶段学习吧</p>
<p>一个设计良好的电流源电路，必须同时满足如下这四点要求：</p>
<ul>
<li>能够输出符合要求的直流电流；</li>
<li>温度稳定性更好；</li>
<li>受到电源电压等因素的影响较小；</li>
<li>输出电阻要尽可能更大；</li>
</ul>
<p>如果一个电流源能够同时满足上述这些要求，那么就可以将其等效为下面的<strong>理想电流源</strong>：<img src="/2022/02/27/16-41-33/image-20220316212039647-16474368536751.png" alt="image-20220316212039647" style="zoom:25%;"></p>
<p>晶体管和场效应管等有源元件，在放大区的输出电流几乎不受输出电压的影响，展现出恒流特性：</p>
<h2 id="差分和多级放大电路">差分和多级放大电路</h2>
<p>本章介绍的是主要内容是一种多晶体管电路——差分放大电路。与之前理想运放一节不同的是，这里的差分放大电路是由基本的晶体管构成的电路</p>
<p>差分放大电路是模拟电路的基本单元，既是几乎所有运放的输入级，也是高速数字逻辑电路的基础。</p>
<p>差分放大电路为</p>
<h2 id="section"></h2>
<h3 id="施密特触发器">施密特触发器</h3>
<h4 id="比较器">比较器</h4>
<h4 id="施密特触发器-1">施密特触发器</h4>
<h1 id="放大电路">放大电路</h1>
<h2 id="基本放大电路的构成">基本放大电路的构成</h2>
<p>设计一个放大电路：</p>
<ol type="1">
<li><p>放大的概念：</p>
<p>放大电路的放大是指对于功率的放大，即小电流电压输入转化为一个大电流电压输出</p></li>
<li><p>本质：</p>
<p>功率放大的本质在于对能量的控制。</p>
<p>为了首先对能量的控制，我们必须在电路中引入一个控制能力的元件——有源元件，具体来说就是三极管和场效应管等。</p></li>
<li><p>前提：</p>
<p>合理放大信号的前提是不失真</p></li>
<li><p>测试：</p>
<p>在实验中我们使用正弦波进行信号放大的测试。</p>
<p>因为声波或其他各种波形，由傅里叶变换可以变换成多个正弦波的叠加，故只要电路系统可以正常的放大分解后的所有正弦波，就可以实现具体的设计目标。</p>
<p>因此在实验中我们使用正弦波进行放大的测试</p></li>
<li><p>放大电路的构建方法：</p>
<ol type="1">
<li>目标：小功率转化为大功率
<ul>
<li>小信号：小的什么程度：几毫伏或几十个毫伏</li>
</ul></li>
<li>条件：
<ul>
<li>有源元件</li>
<li>能量</li>
</ul></li>
<li>技术路线：
<ul>
<li>三极管工作在放大状态下——即 <span class="math inline">\(i_b\)</span> 可以控制 <span class="math inline">\(i_c\)</span></li>
<li>小信号控制 <span class="math inline">\(i_b\)</span></li>
<li>合理的输出</li>
</ul></li>
<li></li>
</ol></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><p><span class="math display">\[
V_i（一个小信号输出电压）-&gt;放大电路-&gt;实现功率放大
\]</span></p></li>
</ol>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>电路基础</title>
    <url>/2022/02/27/16-42-00/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab收集数据绘制箱型图</title>
    <url>/2022/02/25/08-07-35/</url>
    <content><![CDATA[<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">使用手册：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据文档：(Data Text) 软件生成的文本文档，例如：qjy_q1-1_20210827181142。</span></span><br><span class="line"><span class="comment">数据文件夹：(Date File) 使用软件时创建的文件夹，例如：20210827；约定：数据文件夹的名称按“年月日”连续数字来命名，不按照约定命名可能导致读取异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设置文件夹：</span></span><br><span class="line"><span class="comment">首先设置matlab的“当前文件夹”为包含“数据文件夹”的文件夹</span></span><br><span class="line"><span class="comment">根据提示输入“数据文件夹”名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>;</span><br><span class="line">str = input(prompt);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);<span class="comment">%读入“数字”并转化为“文件夹名”</span></span><br><span class="line"></span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name=DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);<span class="comment">%修改当前文件夹为“数据文件夹”</span></span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);<span class="comment">%以cell形式提取文件的第一列</span></span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];<span class="comment">%提取有用信息</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">==================</span></span><br><span class="line"><span class="comment">J_sc=mid(3,1);</span></span><br><span class="line"><span class="comment">V_oc=mid(8,1);</span></span><br><span class="line"><span class="comment">FF=mid(9,1);</span></span><br><span class="line"><span class="comment">Eta = mid(10,1);</span></span><br><span class="line"><span class="comment">===================</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);<span class="comment">%将元胞数组转化为普通数组(单引号字符串的数组形式会自动合并)</span></span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取字符串中的数字并以元胞数组形式储存</span></span><br><span class="line">	usfull_data_num=string(C_usfull_data_num);<span class="comment">%将元胞数组转换为普通(双引号字符串)数组</span></span><br><span class="line">	usfull_data = str2double(usfull_data_num);<span class="comment">%将字符串转化为数字</span></span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box11_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line"> X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line"> Y=vertcat(y1,y2,y3);</span><br><span class="line"> boxplot(X,Y);</span><br><span class="line"></span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line">judge=input(<span class="string">&#x27;绘图or生成表格:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> judge == <span class="string">&#x27;绘图&#x27;</span></span><br><span class="line">	<span class="comment">%查询片的数量:</span></span><br><span class="line">	PIECE=input(<span class="string">&#x27;片的数量？\n输入示例:8\n&#x27;</span>);</span><br><span class="line">	CELL=input(<span class="string">&#x27;电池的数量？\n输入示例:[9 9 9 9 9 9 9 9]\n&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%定义分类方式:</span></span><br><span class="line">	IpMid=input(<span class="string">&#x27;输入分类方式，将作为箱型图的X轴.\n输入示例:2-3石墨盒 1-2石墨盒\n&#x27;</span>,<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">	class_way = string(split(IpMid));</span><br><span class="line">	m=<span class="built_in">length</span>(class_way);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%对应分类方式与片的关系:</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		fprintf(<span class="string">&#x27;第%d个条件对应的片的序号\n输入示例:[1 3 5]&#x27;</span>,n);</span><br><span class="line">		Part(n,:) = &#123;input(<span class="string">&#x27;\n&#x27;</span>)&#125;;</span><br><span class="line">		Length(n,:)=<span class="built_in">length</span>(Part&#123;n,:&#125;);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">%画图</span></span><br><span class="line">	<span class="keyword">for</span> m=<span class="number">1</span>:CELL(<span class="number">1</span>)</span><br><span class="line">		load_data_plot(<span class="number">1</span>,m) = J_sc(m);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">2</span>:PIECE</span><br><span class="line">		<span class="keyword">for</span> m=<span class="number">1</span>:CELL(n)</span><br><span class="line">			load_data_plot(n,m) = J_sc((n<span class="number">-1</span>)*CELL(n<span class="number">-1</span>)+m);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		<span class="keyword">for</span> q=<span class="number">1</span>:Length</span><br><span class="line">			data_plot(n,:)=&#123;load_data_plot(Part&#123;n,<span class="number">1</span>&#125;(<span class="number">1</span>,q),:)&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Plot_title=input(<span class="string">&#x27;输入图像的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	X_name=<span class="string">&#x27;条件&#x27;</span>;</span><br><span class="line">	Y_name=input(<span class="string">&#x27;输入Y轴的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	<span class="keyword">switch</span> Y_name</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;J_sc&#x27;</span></span><br><span class="line">			a=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;V_oc&#x27;</span></span><br><span class="line">			a=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;FF&#x27;</span></span><br><span class="line">			a=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Eta&#x27;</span></span><br><span class="line">			a=<span class="number">4</span>;</span><br><span class="line">		<span class="keyword">otherwise</span></span><br><span class="line">			warning(<span class="string">&#x27;输入错误，请按照要求输入。&#x27;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	title(Plot_title);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">elseif</span> judge == <span class="string">&quot;生成表格&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&quot;输入错误,请输入“绘图”或者“生成表格”。&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Jsc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Voc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of FF&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Eta&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2022/02/25/11-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1 id="蓝桥杯">蓝桥杯</h1>
<figure>
<img src="/2022/02/25/11-07-35/Users\qjy\Desktop\image-20211030223845558.png" alt="image-20211030223845558"><figcaption aria-hidden="true">image-20211030223845558</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;			<span class="comment">// reg52.h 中没有定义 P4 寄存器故自己定义</span></span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “stc15f2k60s2.h”	<span class="comment">// 该文件已定义 P4 寄存器故无需重复定义</span></span></span><br><span class="line"> </span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2 的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<h3 id="基础编程位运算">基础编程——位运算</h3>
<h4 id="基本位运算符">基本位运算符</h4>
<p>取反、按位与、按位或、按位异或</p>
<h4 id="基本位运算">基本位运算</h4>
<h5 id="掩码">掩码</h5>
<p>讲各个位的值初始化为想要的样子，对于74HC138译码器，我们初始化为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initial value is not sure</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"><span class="comment">//P2 = 0001 1111</span></span><br></pre></td></tr></table></figure>
<p>通过掩码 0x1f 我们可以让 38 译码器的 ABC 三个引脚初始化为 000 。</p>
<h5 id="设置位">设置位</h5>
<p>通过或运算符可以设置各个位的值，对于 38 译码器，我们想要使之使能Y4，需要设置 ABC 为 001 ，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set P2 = 0001 1111</span></span><br><span class="line">P2 |= <span class="number">0x80</span>;</span><br><span class="line"><span class="comment">//get P2 = 1000 1111</span></span><br></pre></td></tr></table></figure>
<h5 id="关闭位">关闭位</h5>
<p>关闭 P2 的</p>
<h3 id="led">LED</h3>
<h4 id="题目要求">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现LED的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍然后熄灭；</p>
<p>接着依次点亮LED指</p>
<p>示灯；</p>
<p>最后依次熄灭指示灯；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点">考点：</h4>
<p>74HC138、74HC573和74HC02三个数字IC；C51开发方式——IO口扩展</p>
<h4 id="笔记">笔记：</h4>
<p>​ C51开发的两种方式：IO口扩展和存储器映射扩展</p>
<p>​ 跳线帽<span class="math inline">\(J3\)</span>：WR引脚，存储器映射扩展；接地，IO扩展</p>
<p><img src="/2022/02/25/11-07-35/image-20211030180455602.png" alt="image-20211030180455602" style="zoom: 50%;"></p>
<p>三八译码器：三个输入控制八路互斥的低有效输出——七位高一位低</p>
<p>使用方法：</p>
<ul>
<li>ABC三个输入端控制Y0-Y7八个输出端</li>
<li>输入端输入的三位二进制数的十进制形式对应Y的编号
<ul>
<li>如<span class="math inline">\(CBA=(100)_2=(4)_{10} \Rightarrow Y(4)\)</span></li>
</ul></li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180601344.png" alt="image-20211030180601344" style="zoom:50%;"></p>
<p>锁存器：八路三态输出的非反转透明锁存器</p>
<p>使用方法：</p>
<ul>
<li>控制引脚：LE，低电平锁存，高电平导通</li>
<li>导通时D和Q的电平一致</li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180521683.png" alt="image-20211030180521683" style="zoom:50%;"></p>
<p>使用方法：</p>
<ul>
<li><p>使用IO扩展，跳线帽设置为为GND</p></li>
<li><p><span class="math inline">\((WR-&gt;GND)J13\)</span></p>
<p><span class="math inline">\(74HC138(Y4)-&gt;(Y4)74HC02(Y4C)-&gt;(LE)M74HC573MIR\)</span></p>
<p><span class="math inline">\(\sf{使用}:WR=0;\,Y4=0\,\sf{ 时},\, Y4C=1\)</span></p></li>
</ul>
<p>左移运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	P0 = (<span class="number">0xff</span> &lt;&lt;i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; P0 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：510 1020 2040 4080 8160 16320 32640 65280</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay100ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LEDrunning</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="comment">//通过配置三八译码器使得锁存器导通，此时单片机P0口电压直接对应LED灯的电压</span></span><br><span class="line">    HC138_C = <span class="number">1</span>;</span><br><span class="line">    HC138_B = <span class="number">0</span>;</span><br><span class="line">    HC138_A = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将P0口全部设为低电平，点亮所有LED灯</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0x00</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        P0 = <span class="number">0xff</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0xff</span>&lt;&lt;i;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = ~(<span class="number">0xff</span>&lt;&lt;i);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LEDrunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蜂鸣器和继电器">蜂鸣器和继电器</h3>
<h4 id="题目要求-1">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现蜂鸣器与继电器的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍后熄灭；</p>
<p>接着依次点亮LED指示灯；</p>
<p>继电器吸合一会后断开；</p>
<p>然后依次熄灭LED指示灯；</p>
<p>蜂鸣器鸣叫会后关闭；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点-1">考点：</h4>
<p>蜂鸣器和继电器的使用；继续使用上面的三个IC；ULN2003达林顿管——一个驱动管</p>
<h4 id="笔记-1">笔记：</h4>
<p>针脚选择BTN</p>
<h4 id="代码-1">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/11-07-35/image-20211030203349176.png" alt="image-20211030203349176" style="zoom:50%;"></p>
<h3 id="独立按键">独立按键</h3>
<h4 id="题目要求-2">题目要求：</h4>
<blockquote>

</blockquote>
<h4 id="考点-2">考点：</h4>
<ul>
<li>独立按键；矩阵键盘</li>
<li>读取IO口电平</li>
<li>按键消抖</li>
</ul>
<h4 id="笔记-2">笔记：</h4>
<p>根据原理图可知：</p>
<p><img src="/2022/02/25/11-07-35/image-20211030204322671.png" alt="image-20211030204322671" style="zoom: 67%;"></p>
<p><span class="math inline">\(J5\)</span>接2、3引脚，此时<span class="math inline">\(P30-P33\)</span>四个单片机IO口分别接<span class="math inline">\(S7-S4\)</span>四个独立按键再接<span class="math inline">\(GND\)</span></p>
<h4 id="代码-2">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit s7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit s6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit s5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit s4 = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit L1 = P0^<span class="number">0</span>;</span><br><span class="line">sbit L2 = P0^<span class="number">1</span>;</span><br><span class="line">sbit L3 = P0^<span class="number">2</span>;</span><br><span class="line">sbit L4 = P0^<span class="number">3</span>;</span><br><span class="line">sbit L5 = P0^<span class="number">4</span>;</span><br><span class="line">sbit L6 = P0^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SelecHC138(<span class="number">4</span>);<span class="comment">//控制锁存器打开LED灯</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ScanKeys_Alone();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数码管">数码管</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegTab[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,</span><br><span class="line">                             <span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegBuf[]=&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>数码管延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_dtms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">10</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时刷新频率可以到100Hz，即0.01ms</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_tms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时延时大约1ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===============初始化定时器0==================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Timer0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        TMOD = <span class="number">0x01</span>;                    <span class="comment">//16位定时模式</span></span><br><span class="line">        TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;      <span class="comment">//定时50ms</span></span><br><span class="line">        TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">        ET0 = <span class="number">1</span>;                       <span class="comment">//使能定时器T0中断</span></span><br><span class="line">        EA = <span class="number">1</span>;                       <span class="comment">//使能总中断        </span></span><br><span class="line">        TR0 = <span class="number">1</span>;                       <span class="comment">//启动定时器T0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*============定时器0中断服务函数===============*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeviceTimer0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">1</span>;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">    P0=<span class="number">0xff</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EGplay(i);</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器计算">定时器计算</h3>
<p><span class="math display">\[
10ms=0.01s\\
\sf{计算机器周期数目：}\\x\frac{12}{11059200}=0.01\\
get\:x=9216=0x2400\\
so\:TH0=0x24,TL0=0x00;
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_0_ini</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD = <span class="number">0x01</span>;</span><br><span class="line">	TH0 = <span class="number">0xfc</span>;</span><br><span class="line">	TL0 = <span class="number">0x67</span>;</span><br><span class="line">	TR0=<span class="number">1</span>;</span><br><span class="line">	TF0=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">timer_0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span><span class="comment">//@ t (ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> timer_0_tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(TF0==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TF0=<span class="number">0</span>;</span><br><span class="line">        TH0 = <span class="number">0xfc</span>;</span><br><span class="line">		TL0 = <span class="number">0x67</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=t)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            timer_0_tag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> timer_0_tag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> timer_0_tag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通信">通信</h3>
<p><img src="/2022/02/25/11-07-35/image-20211116001027941.png" alt="image-20211116001027941"></p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑设计基础</title>
    <url>/2022/03/09/16-14-26/</url>
    <content><![CDATA[<h1 id="logic-design">Logic Design</h1>
<h3 id="数制">数制</h3>
<p>数制是用一组固定符号和统一规则来表示数值的方法，通常包含基数和位权两个基本要素。其中<strong>基数</strong>是指使用数码的个数，例如：二进制的基数为<code>2</code>，十进制的基数为<code>10</code>。<strong>位权</strong>是指数制某位所表示的数值权重的大小，例如：十进制数<code>123</code>，<code>1</code>的位权是<code>100</code>，<code>2</code>的位权是<code>10</code>，<code>3</code>的位权是<code>1</code>。二进制数<code>1011</code>，从左至右<code>1</code>、<code>0</code>、<code>1</code>、<code>1</code>的位权依次是<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>。常用的数制有<strong>二</strong>、<strong>八</strong>、<strong>十</strong>、<strong>十六</strong>四种进制，书写时可以在相应数值尾部添加字母<strong>B</strong>、<strong>O</strong>、<strong>D</strong>、<strong>H</strong>或者下标<strong>2</strong>、<strong>8</strong>、<strong>10</strong>、<strong>16</strong>进行标识，计算机<strong>传输和保存数据</strong>通常使用的是<strong>二进制</strong>。</p>
<h3 id="码制">码制</h3>
<p>码制是计算机存储、传输数据所使用的编码规则；其中原码、反码、补码是计算机设备保存数值类型数据的编码方式，ASCII 与 Unicode 属于保存字符类型数据的编码格式；而 BCD 编码、格雷码则主要用于设备之间的数据<strong>传输以及转换</strong>。</p>
<blockquote>
<p>BCD 码的优点在于格式转换容易，十进制数值表达精度较高；缺点是增加了电路进行算术运算的复杂度，并且存储效率较低。</p>
</blockquote>
<h3 id="数字系统">数字系统</h3>
<p>数字系统设计大致分为三个方面</p>
<ul>
<li>系统设计
<ul>
<li>系统设计是将一个数字系统划分为多个子系统进行设计。</li>
</ul></li>
<li>逻辑设计
<ul>
<li>逻辑设计是将多个逻辑功能块互联实现特定功能</li>
</ul></li>
<li>电路设计</li>
</ul>
<p>数字系统的中许多子系统以开关电路的形式存在，开关电路具有一个或多个输入端，一个或多个输出端，输入输出端都取离散值的电路。开关电路一般使用门电路来描述，使用布尔代数进行分析。开关电路有两种——组合电路和时序电路。</p>
<p>开关电路分类：</p>
<ul>
<li>组合电路
<ul>
<li>组合电路中输出值仅与当前输入值有关</li>
<li>组合电路的基本构成是逻辑门，逻辑设计就是将逻辑门相互连接起来以便将电路的输入信号转化为预期的输出信号。</li>
</ul></li>
<li>时序电路
<ul>
<li>时序电路中输出值不仅与当前输入值有关，也与之前的输入值有关；可以认为时序电路具有记忆功能</li>
<li>时序电路的基本存储元件（存储之前的值）是触发器，触发器与逻辑门一起组成时序电路——如计数器和寄存器。</li>
</ul></li>
</ul>
<h3 id="布尔代数">布尔代数</h3>
<p>逻辑设计课程中我们使用二值布尔代数来设计开关电路。我们使用布尔变量来表示电路的输入和输出，其中布尔变量代表逻辑电路中的两种不同状态——</p>
<p>普通代数中的<strong>交换律</strong>和<strong>结合律</strong>同样可以在布尔代数中使用。</p>
<p>布尔代数中的交换律表明开关的位置（出现次序）不会影响最终结果，结合律表明开关导通的次序不会影响最终结果。</p>
<p>在布尔代数中，分配律有两种形式：</p>
<ul>
<li><p>一种是普通的分配律：<span class="math inline">\(X(Y+Z)=XY+XZ\)</span></p>
<p>​ 与运算可以分配在或运算上</p>
<p>​ 去和括号内相乘</p></li>
<li><p>另一种被称作第二分配律：<span class="math inline">\(X+(YZ)=(X+Y)(X+Z)\)</span></p>
<p>​ 或运算可以分配在与运算上</p>
<p>​ 去和括号内相加</p></li>
</ul>
<p>很多布尔代数表达式可以使用一个更简单的表达式替换，每个布尔代数表达式</p>
<h2 id="数字电路概念">数字电路概念</h2>
<h3 id="高阻态">高阻态</h3>
<p>高阻抗状态（<em>High impedance</em>）表示电路中的某个节点具有相对电路中其它点更高的阻抗，电路分析时通常将高阻态作为开路理解。即可以将其视为输出/输入电阻极大，极限状态可以认为是悬空（<em>断路</em>）的状态，高阻态通常使用字母<strong>Z</strong>表示。</p>
<h3 id="三态门">三态门</h3>
<p>数字电路中的三态逻辑（<em>Three-state logic</em>）是指其输出既可以是代表<code>0</code>和<code>1</code>的高低电平，也可以是其特有的高阻抗状态（<em>相当于隔断状态，电阻极大，类似于开路</em>）。</p>
<p>具有高电平、低电平、高阻态三种状态的元器件称为三态器件，三态器件都通过一个控制使能端 B 来控制整个三态门电路的通断。当使能端高电平有效时，三态器件可以正常的<code>0</code>或<code>1</code>输出，当使能端低电平无效时，三态电路将会输出高阻态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">输入端 A</th>
<th style="text-align: left;">使能端 B</th>
<th style="text-align: left;">输出端 C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>X</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>Z</code></td>
</tr>
</tbody>
</table>
<h3 id="组合时序逻辑电路">组合/时序逻辑电路</h3>
<ul>
<li><strong>组合逻辑电路</strong>（<em>Combinational Logic Circuit</em>），其任一时刻的稳态输出仅与该时刻输入的变量取值有关，而与该时刻之前输入的变量取值无关。组合电路主要由各种逻辑门（<code>半加器</code>、<code>全加器</code>、<code>半减器</code>、<code>全减器</code>、<code>数据选择器</code>、<code>数据分配器</code>、<code>编码器</code>、<code>译码器</code>）组成，电路中没有记忆元件和反馈线。</li>
<li><strong>时序逻辑电路</strong>（<em>Sequential Logic Circuit</em>）任意时刻的稳态输出不仅取决于当前输入，还与前一时刻输入的状态有关，换而言之，时序逻辑电路必须拥有特定的储存元件来保存前一次的输入状态。因此，时序逻辑电路除包含有组合逻辑电路以外，还必须含拥有存储信息能力的电路（<code>触发器</code>、<code>寄存器</code>、<code>计数器</code>）。</li>
</ul>
<h3 id="gpio">GPIO</h3>
<p><strong>通用输入输出</strong>（<em>General-purpose input/output</em>），功能类似于 8051 单片机的 P0 到 P3 口，引脚输出的高低电平可由开发人员读写相应寄存器进行控制。该接口有时也称为<strong>总线扩展器</strong>，当开发板接口不够用时，可以通过转接板将其扩展为<code>I²C</code>、<code>SPI</code>等其它串行接口。</p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCv笔记</title>
    <url>/2022/03/30/11-27-50/</url>
    <content><![CDATA[<h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR 8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或 -1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如 <span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>， <strong><a href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong> 等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span> 中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数 <code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span> 转换，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于 <span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在 <span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较 <span class="math inline">\(OpenCV\)</span> 值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span> 图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在 $ HSV$ 中，比在 <span class="math inline">\(BGR\)</span> 颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span> 图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a href="https://www.stackoverflow.com/">stackoverflow.com</a> 中发现的一个常见问题。它非常简单，你可以使用相同的函数<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的 <span class="math inline">\(BGR\)</span> 值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$ 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和 <span class="math inline">\([H+10, 255,255]\)</span> 为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整 <span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong> 和 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为 <span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span> 用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span> 提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code> 函数。详情请查看 <span class="math inline">\(matplotlib\)</span> 文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a> 接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span> 是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv.imread(r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;,0)</span><br><span class="line">kernel = np.ones((2,1),np.uint8)</span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line">#erosion = cv.erode(img,kernel,iterations = 1)</span><br><span class="line">cv.imshow(&#x27;res&#x27;,closing)</span><br><span class="line">k = cv.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span> 的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span> 的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 函数，其中 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 是 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a> 被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为 <span class="math inline">\(127\)</span> 的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span> 阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span> 实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span> 的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad \&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2 \frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span> 的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在 <span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span> 有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong> 来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示： <span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span> 操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong> 或 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong> 完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个 <span class="math inline">\(3x3\)</span> 标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数 <code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span> 内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong> 完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是 $ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了 <span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$ 取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong> 创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong> 取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。2</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span> 的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong> 在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a href="https://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">2</span>,<span class="number">2</span>),np.uint8)</span><br><span class="line"><span class="comment">#closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span></span><br><span class="line"><span class="comment">#erosion = cv.erode(img,kernel,iterations = 1)</span></span><br><span class="line"><span class="comment">#dilation = cv.dilate(img,kernel,iterations = 1)</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,opening)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong> 等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是 <span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span> 的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut 算法的交互式前景提取</h3>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理与接口技术</title>
    <url>/2022/03/05/16-32-26/</url>
    <content><![CDATA[<h1 id="微机原理与接口技术">微机原理与接口技术</h1>
<h2 id="基本概念">基本概念</h2>
<p>微型计算机简称微机，是微机原理这门课程的主要研究范围。</p>
<p>首先我们先对微型计算机有一个初步的认识。</p>
<h4 id="电脑微型计算机系统">电脑——微型计算机系统</h4>
<p>电脑是我们熟悉的事物，我们家用的台式电脑和笔记本电脑都是属于<strong>个人电脑（Personal Computer）</strong>，简称为PC。个人电脑PC是一个<strong>通用微型计算机系统（）</strong>。其中，“通用”暗示了“专用”计算机系统的存在，而“微型”暗示了“大型”计算机系统的存在。其中还有值得注意的是计算机系统中的“系统”二字，因为这暗示了在计算机之上还存在一个更加宏观的概念。</p>
<p>计算机根据规格和能力区分的话可以粗略分作超级计算机，大型计算机，小型计算机和微型计算机。其中超算和微机可能是我们日常生活中常常能听到的词语，前者出现在新闻里面，比如天河二号；后者出现在我们们的日常生活中，也就是我们的电脑（主机）。</p>
<p>经典的电脑硬件配置包括鼠标，键盘，显示器和电脑主机，虽然笔记本发展后大多数笔记本都配备有触控板作为鼠标的代替，但是鼠标依旧是更受欢迎的计算机<strong>外设（Peripherals）</strong>。除了鼠标，键盘和显示器也是最经典的外设，但是对于完全不了解电脑构造却经常使用电脑的人来说，或许会认为显示器是计算机，尤其是一体机的存在使得这个错误更容易犯下。但是，计算机，顾名思义是计算的机器，它的功能并不会包括“显示”。根据输入，计算机会得到输出，但是这个输出不是我们可以直接看到的“显示”，“显示”的功能来自一个密布发光单元的显示器，显示器可以将计算机的输出变成屏幕上的文字或者图片为我们“显示”出来。</p>
<p>外设不是计算机，真正的计算机是我们通常称为“电脑主机”的的部分，在台式机中，它是显示器旁边的长方体的箱子；在笔记本中，它一般在你的键盘的下面。</p>
<p>计算机（个人计算机）和外设，配合上电源，便组成了微型计算机系统的硬件部分。完整的微型计算机系统不仅包括硬件，还包括软件。后者不是我们在微机原理课程中重点的关注的内容，但是理解软件部分是微型计算机系统不可缺少的部分却很重要。</p>
<p>微型计算机系统的软件部分包括<strong>系统软件</strong>和<strong>应用软件</strong>，系统软件中我们最熟悉的就是操作系统，如Windows和MacOS；而像Office或者浏览器等软件则是应用程序即应用软件。</p>
<p>==总结：家用电脑整体称作<strong>微型计算机系统（）</strong>，这个系统分为硬件和软件两大部分，其中软件部分包括系统软件和应用软件；硬件部分包括电源、外设和最重要的微型计算机（电脑主机）。接下来我们重点介绍微型计算机的内部结构。==</p>
<h4 id="微型计算机">微型计算机</h4>
<p><strong>微型计算机（）</strong>内部结构可概括为四部分：</p>
<ul>
<li>CPU（这个肯定耳熟了，稍后会进一步介绍）</li>
<li>存储器（比较复杂，稍后重点介绍）</li>
<li>总线（bus）：总线就是连接计算机内部部件的导线</li>
<li>输入输出接口电路：与外设连接的导线</li>
</ul>
<p>相信即便是最不了解电脑的小白也听说过CPU的大名。CPU中的字母C表示Center，是中心的意思，表明CPU是计算机的中心。计算机中的一切一切都是围绕着CPU转圈的。这样重要且复杂的部件，我们肯定要单独拿出来讲：下一节微处理器，就是对CPU的详细介绍。</p>
<p>计算机的本质是计算，无论是使用计算机显示文本或是图形，播放音乐或是视频，计算机本身都只是在快速做着最简单的运算。我们从很小的时候便学习开始做运算了，我们知道，做运算首先我们需要纸笔记录下数字，然后可能还需要将结果记录在另一张纸上（比如你的试卷）。计算机中也存在大量的数字，我们称作数据（data），它们存在计算机的存储器中。除数据外，计算中我们需要知道算数的方法，比如老师对我们说，将两个数字相乘，我们就做乘法。计算机也存在类似的东西，称作指令（code）。众所周知，计算机使用二进制，也就是计算机中不存在文字，甚至不存在数字2，我们在计算机中只有0和1。因此计算机中指令和数据都是由0和1进行表示的。在计算机经典结构——冯·诺伊曼结构中，指令和数字不加区分的放在存储器中；而在另一种改进过的计算机结构——哈佛结构中，指令放在指令存储器中而数据放在数据存储器中。这种分开存放的优势在于可以使数据和指令的存取同时进行，我们将在后面进一步看到这样做的重要意义。</p>
<p>目前我们已经知道了，存储器存储着数据和指令。处理数据是计算机无时无刻都在做的事情，而指令则告诉计算机该怎样处理数据。那么接下来的问题是：我们需要一个什么样的存储器呢？</p>
<p>简单来说，我们需要一个好的存储器。一般来说，我们关注存储器的如下3个特点</p>
<ol type="1">
<li>存储器是一个存储结构，既要存，还要取
<ul>
<li>存——要求能存住，机器断电（掉电）后能不能一直保存</li>
<li>取——主要看速度，取出来自然是越快越好</li>
</ul></li>
<li>最后就是作为商品，我们还是要考虑成本的，成本太高买不起就不行了。</li>
</ol>
<p>综上，我们需要一个价格便宜，能掉电存储且读取速度快的存储器。</p>
<p>可惜的是，现实中没有那么完美的存储器（至少目前），虽然根据不同的原理人们制作出的低成本且掉电存储的快闪存储器Flash（就是很多人U盘用的那个），但是它传输速度慢；另一方面人们制作出了静态随机存储器SRAM，虽然便宜还传输快，但是掉电不保存。虽然除了上述两种还有一些类型的存储器，但是也都有其缺点。为了协调速度、容量和成本三个方面，人们设计出了三级存储结构：<strong>高速缓存存储器</strong>、<strong>内存储器（主存）</strong>和<strong>外存储器（辅存）</strong>。</p>
<p>高速缓存存储器存在于主存与CPU之间的一级存储器，容量小但是速度很快，接近于CPU的速度。</p>
<p>内存储器是CPU读取数据和指令的地方，如果数据在外存储器中，CPU将先把数据从外存储器移至内存储器中然后再处理数据。</p>
<p>外存储器就是我们平时说的电脑的固态硬盘，手里拿的U盘和已经淘汰了的光盘。</p>
<p>三级存储结构帮助我们再速度、容量和成本三个方面达到一个平衡。但是未来如果有更好的存储手段，能同时满足上述三点，或许我们就将创造全新的存储器结构，主存和辅存也将会像光盘一样被淘汰掉。</p>
<hr>
<p>微型计算机的分类——按微型计算机的结构形式分类。</p>
<ul>
<li>单片机</li>
<li>单板机</li>
<li>多板机</li>
</ul>
<p>对于数码爱好者，尤其是那些对于台式机组装机器充满兴趣的人都不会对多板机这个概念感到困惑。在台式机中存在一个叫主板或是叫母板的东西。典型的主板能提供一系列接合点，供我们非常熟悉名字的例如处理器、显卡、硬盘驱动器、存储器、对外设备等设备的接合。</p>
<p>多板机是在一块主板上提供了多个扩展插槽，并使用总线将各个部分进行连接，最终将一切封装在一个机箱里面。在组装的开始，我们有一堆板子，在组装完成后，我们有一台电脑。</p>
<p>单板机的思路与多板机不同，单板机将一台电脑用到的所用功能集成在一块电路板上，在购买单板机时我们直接买到的就是一台电脑，而不需要再进行组装。当然，鉴于单板机性能弱一般用于实验室和简单的控制场所，所以单板机所在的电路板可能会进一步连接在其他的电路板上。但是，无论外部还会连接什么，重点是，在一小块电路板上我们有了一台基础功能完备的电脑。这里值得一提的是，对于电子设计爱好者，很可能听说过Arduino和树莓派的大名，这里要说明，Arduino和树莓派都属于单板机。</p>
<p>单片机也被称作微控制器，这个名字基本对单片机定了性质。单片机通常是用来做控制的，常常用于工业，在实验室也经常见到它的身影。单片机将CPU和存储器……其实就是上面提到的微型计算机中该有的那些东西，集成在了一个芯片上面。通常来讲，你对商店老板说来来些单片机，那你将收到的是一些黑色塑料外壳包着的下方有许多金属引脚的小东西。与Arduino和树莓派，一个芯片既不能直接连接一个LED控制它的亮灭，也不能直接烧录程序。单片机正常执行控制需要建立一个最小工作系统，然后才能进行控制。如果想了解更具体些，<a href>这里</a>会有你想知道的。</p>
<p>==总结一下：微型计算机由CPU和存储器组成，内部有总线连接，向外有输入输出电路进行扩展。计算机的本职工作是做计算，计算需要指令和数据，根据指令数据的存储方式的不同可以将微型计算机分为冯·诺伊曼结构和哈佛结构。计算机可以分为单片机、单板机和多板机。将计算机放在一个芯片上是单片机，放在一个电路板上是单板机，多个板子各司其职组装在一起形成电脑叫多板机。==</p>
<h4 id="微处理器">微处理器</h4>
<p>微处理器（microprocessor）也称中央处理单元（central processing unit），是微型计算机的核心部件。</p>
<p>前面我们已将提过，计算机的本职工作是做计算。计算需要两方面内容——数据和指令。前者就相当于给你数字2和3，后者就相当于告诉你对2和3做乘法。对于CPU来说不止但肯定有下述三个功能：</p>
<ul>
<li>进行基本的算数和逻辑运算（如果想要知道电路是如何做运算的，<a href>这里</a>会找到答案的）</li>
<li>暂存少量数据（这是好理解的，毕竟我们计算式也要先把数字写在草稿纸上）</li>
<li>执行指令（值得注意的是指令是需要译码的）</li>
</ul>
<h3 id="嵌入式系统">嵌入式系统</h3>
<p>上文我们以通用计算机系统为例，沿着“微型计算机系统-&gt;微型计算机-&gt;微（型）处理器”三个层次描述了微机的基本概念。最后我们注意微机的另一大类，即平行于通用计算机系统的，名为嵌入式系统的专用计算机系统。</p>
<p>嵌入式系统也是微型计算机系统，上面描述的通用计算机系统包含的内容，在嵌入式系统中也同样有所体现。但是嵌入式系统的关键词在于“专用”。专用意味着嵌入式系统为某一具体的应用问题而生，不需要具备通用计算机系统的全部内容。例如，嵌入式系统中可能不会连接鼠标键盘等外设，而且不会具备完整的系统软件。</p>
<h2 id="arm微处理器">ARM微处理器</h2>
<p>ARM微处理器最重要的特性是其英文名称</p>
<h4 id="arm-微处理器的工作状态">ARM 微处理器的工作状态</h4>
<ul>
<li>ARM 状态：处理器执行32位的 ARM 指令集，即执行字方式的 ARM 指令</li>
<li>Thumb 状态：处理器执行16位的 Thumb 指令集，即执行半字方式的 ARM 指令</li>
</ul>
<p>ARM 微处理器在两种工作模式下都有切换处理器工作状态的指令，但是在 ARM 处理器开始执行代码时处理器应处于 ARM 状态。</p>
<h4 id="arm-微处理器的工作模式">ARM 微处理器的工作模式</h4>
<ul>
<li>用户模式</li>
<li>特权模式
<ul>
<li>系统模式</li>
<li>异常模式
<ul>
<li>管理模式</li>
<li>快速中断模式</li>
<li>外部中断模式</li>
<li>数据访问中止模式</li>
<li>未定义指令中止模式</li>
</ul></li>
</ul></li>
</ul>
<p>工作模式可以通过软件改变，也可以通过外部中断和处理器异常来改变。并且每一种模式下可以使用的寄存器是不同的。</p>
<h4 id="arm-处理器支持的数据类型和存储格式">ARM 处理器支持的数据类型和存储格式</h4>
<h5 id="数据类型">数据类型</h5>
<p>在处理器中数据类型是这样分类的，分成下面三种类型：</p>
<ul>
<li>字节类型</li>
<li>半字类型</li>
<li>字类型</li>
</ul>
<p>数据操作都是以字为单位的（这里课本写：ARM 指令是一个字长而 Thumb 指令是半字长；但不是说操作都是以字为单位并且都是一样长吗？？？），而从存储器读写的数据则可以按上述三种不同的数据类型进行读写。</p>
<p>对存储器按字或者半字类型进行读取时，需要进行对齐操作；对数据进行字节传输时不需要对齐。</p>
<blockquote>
<p>一条指令（指的是机器码）由操作码（opcode）和操作数（operand）构成。操作数可以是1个，也可以是多个，甚至可以没有。操作码则是每一条指令都必须有。操作码表示该指令要做什么动作，例如跳转，加减等等。操作数则表示操作对象，操作数可能还会分为目的操作数和源操作数。操作数当然是一个数字，该操作数可以由多种来源，例如寄存器，存储器或者立即数。本节介绍的处理器的寻址方式就是讨论指令中操作数的来源问题。</p>
</blockquote>
<h5 id="存储格式">存储格式</h5>
<blockquote>
<p>指令编码中，用来说明操作数来源和操作数构成存储器地址的方法，叫做寻址方式，英文为Addressing Mode。寻址方式是由处理器的指令编码直接决定的，是处理器体系架构的一部分，所以我们一般叫做xxx处理器寻址方式，例如8086寻址方式，MIPS寻址方式。寻址方式是学习任何一种汇编语言的起点。</p>
</blockquote>
<p>ARM 存储器的最大寻址空间为4 GB。</p>
<p>存储器可以看作是一个从零开始线性递增的一个容器，容器的基本单位为字节。</p>
<p>数据以字为单位存储在存储器中，这意味着一个（字）数据将存放在存储器的四个基本单位中。</p>
<p>数据在存储器中的存储方式有两种，区分两种存储方式的关键在于一个字的四个字节在存储器中哪一个存在高位哪一个存在低位：</p>
<ul>
<li>大端格式：数据的高字节位存储在存储器的低地址中</li>
<li>小端格式：数据的低字节位存储在存储器的低地址中</li>
</ul>
<p>大小端的存储方式可以通过外部引脚和内部寄存器的配置来进行选择，选择要在使用前进行配置，开始使用后只能选择一种存储器数据存储方式。</p>
<h4 id="arm-处理器的寄存器">ARM 处理器的寄存器</h4>
<p>ARM 寄存器：</p>
<ul>
<li>定义：寄存器是 CPU 内部用来暂时存放参与运算的数据和运算结果的小型存储区域</li>
<li>特征：传输数据的速度非常快</li>
<li>分类：
<ul>
<li>通用寄存器：保存数据和地址</li>
<li>状态寄存器：标识 CPU 的工作状态及程序的运行状态</li>
</ul></li>
<li>经典 ARM 寄存器在物理上共有37个32位寄存器组成
<ul>
<li>31个通用寄存器</li>
<li>6个状态寄存器</li>
</ul></li>
</ul>
<h4 id="arm-处理器的io组织">ARM 处理器的I/O组织</h4>
<p>I/O 是 CPU 与外部设备之间通信的桥梁</p>
<p>对 I/O 端口物理地址进行编址的方式有两种：</p>
<ul>
<li><p>独立编址方式：I/O映射方式，x86采用</p>
<p>I/O 端口地址与内存单元地址分开独立编址，I/O 端口地址不占用内存空间的地址范围，需要专门的I/O 指令和控制逻辑</p></li>
<li><p>统一编址方式：内存映射方式，ARM采用</p>
<p>I/O 端口地址与内存单元地址混在一起：将内存的一部分划分出来作为I/O 地址空间。</p></li>
</ul>
<h2 id="cortex-m4-微处理器">Cortex-M4 微处理器</h2>
<h4 id="cortex-m4-微处理器的工作状态">Cortex-M4 微处理器的工作状态</h4>
<h4 id="cortex-m4-微处理器的工作模式">Cortex-M4 微处理器的工作模式</h4>
<h4 id="cortex-m4-微处理器的寄存器组织">Cortex-M4 微处理器的寄存器组织</h4>
<ul>
<li>存在于：寄存器存在于处理器的内核之中</li>
<li>作用：执行数据处理和控制</li>
<li>分类：16个32位寄存器
<ul>
<li>通用寄存器组</li>
<li>特殊功能寄存器</li>
</ul></li>
<li>与经典的 ARM 微处理器对比：Cortex-M4 微处理器的寄存器较少</li>
<li>通用寄存器详解：
<ol type="1">
<li><span class="math inline">\(R0-R7\)</span>：
<ul>
<li>统称：低组寄存器</li>
<li>访问指令：32位指令和大多数16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R8-R12\)</span>：
<ul>
<li>统称：高组寄存器</li>
<li>访问指令：32位指令和少量16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R13\)</span>：
<ul>
<li>统称：堆栈指针寄存器</li>
<li>系统可以同时支持两个堆栈，</li>
</ul></li>
</ol></li>
</ul>
<h4 id="cortex-m4-微处理器的存储组织">Cortex-M4 微处理器的存储组织</h4>
<h1 id="摘抄">摘抄：</h1>
<p>RISC使用的是load-store结构。load-store结构的本质，在于RISC技术的CPU只处理（指逻辑，算术运算处理）寄存器中的数据。相反，X86却能够直接处理存储器中的数据。</p>
<p><a href="https://nieyong.github.io/wiki_cpu/index.html">index (nieyong.github.io)</a></p>
<h1 id="stm32启动程序分析">STM32启动程序分析</h1>
<p><strong>1.程序的内存分配</strong></p>
<p>一个由C/C 编译的程序占用的内存分为以下几个部分：</p>
<p><strong>栈区（stack）：</strong>由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p><strong>堆区（heap）：</strong>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。</p>
<p><strong>全局区（静态区）（static）：</strong>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>
<p><strong>文字常量区：</strong>常量字符串就是放在这里的，程序结束后由系统释放。</p>
<p><strong>程序代码区：</strong>存放函数体的二进制代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> *p2; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">//123456\0在常量区，p3在栈上。 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">//分配得来得10和20字节的区域就在堆区。 </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里要强调一点：传递指针只占4字节，如果传递的是结构体，就会占用结构大小空间。</span></span><br><span class="line"><span class="comment">//提示：在函数嵌套,递归时，系统仍会占用栈空间。</span></span><br><span class="line"><span class="comment">//虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果忘记了释放堆内存，那么将会造成内存泄漏，甚至致命的潜在错误。</span></span><br></pre></td></tr></table></figure>
<p>Q&amp;A</p>
<p>Q:为什么驱动文件是汇编语言写而不是C语言? A:汇编语言处理一些更加底层的工作，如设置堆栈空间等，这一点C这个"高级语言"无法做到。</p>
<p>Q:启动程序阶段，CPU对启动文件是从上向下足以读取吗？ A:编译之前的是源程序，编译之后的指令的机器码以地址进行排列。实际上按地址逐一进行读取，要看源码的组织结构。</p>
<p>Q:用户通过Keil软件配置堆栈空间和自己定义堆栈有什么区别？ A:</p>
<p>时钟系统就是CPU的脉搏，像人的心跳一样，重要性不言而喻。由于STM32本身十分复杂，外设非常多，但并不是所有的外设都需要系统时钟那么高的频率，比如看门狗以及RTC只需要几十k的时钟即可。并且，同一个电路，时钟越快功耗越快，同时抗电磁干扰能力也就越弱，所以较为复杂的MCU都是采用多时钟源的方法来解决这些问题。</p>
<p>startup_stm32f10x_cl.s（启动文件） → SystemInit() → SetSysClock () → SetSysClockTo72()</p>
<p>查看MDK的文档，会发现有这么一句说明：It is automatically created by the linker when it sees a definition of main()。简单点来说，当编译器发现定义了main函数，那么就会自动创建__main。</p>
<p>程序经过汇编启动代码，执行到__main()，之后会执行两个大的函数：</p>
<p>__scatterload()：负责把RW/RO输出段从装载域地址复制到运行域地址，并完成了ZI运行域的初始化工作。</p>
<p>__rt_entry():负责初始化堆栈，完成库函数的初始化，<strong>最后自动跳转向main()函数</strong>。</p>
<p>注意：有些应用中会要求在进入main函数之前先初始化一些外设或者变量区，如：初始化时钟、初始化SDRAM。在初始化他们的时候一定不要使用全局变量，部分库函数，HAL库。因为在__main之前，全局变量还没有初始化，使用会异常，甚至发生内存错误。<strong>因此建议使用寄存器来初始化。</strong></p>
<p>https://blog.csdn.net/shenghuaDay/article/details/71643767</p>
<p>r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。</p>
<p>r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。</p>
<p>r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色.在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。</p>
<p>r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。</p>
<p>r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复</p>
<p>r15 是程序计数器 PC。它不能用于任何其它用途。</p>
<p>注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11</p>
<p>所谓启动，一般来说就是指我们下好程序后，重启芯片时，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存。用户可以通过设置BOOT1和BOOT0引脚的状态，来选择在复位后的启动模式。</p>
<p>STM32上电或者复位后，代码区始终从0x00000000开始，三种启动模式其实就是将各自存储空间的地址映射到0x00000000中。</p>
<p>（1）从Flash启动，将主Flash地址0x08000000映射到0x00000000，这样代码启动之后就相当于从0x08000000开始。</p>
<p>（2）从RAM启动，将RAM地址0x20000000映射到0x00000000,这样代码启动之后就相当于从0x20000000开始。</p>
<p>（3）从系统存储器启动。首先控制BOOT0 BOOT1管脚，复位后，STM32与上述两种方式类似，从系统存储器地址0x1FFF F000开始执行代码。系统存储器存储的其实就是STM32自带的bootloader代码，在bootloader中提供了UART1的接口，通过此接口可以将用户所需的程序代码下载到主Flash中，下载完毕后，此时程序代码已经存储在主Flash当中，这时切换启动模式（从主Flash启动），复位后所执行的就是刚刚下载到Flash中的代码了。</p>
<p>在STM32中，一般都会有一个片上的Flash和SRAM。Flash用于烧录我们编译后生成的目标代码，SRAM则用于栈空间和保存全局变量， 它们分别对应图1中地址空间的Code段和SRAM段。此外STM32中的Flash一般都映射在0x0800 0000的地址上的， 因此为了保证向量表写在0x0800 0000的位置上，我们必须保证生成的目标代码中一开始就是向量表的内容</p>
<figure>
<img src="/2022/03/05/16-32-26/image-20220502134455259-16514702975521.png" alt="image-20220502134455259"><figcaption aria-hidden="true">image-20220502134455259</figcaption>
</figure>
<figure>
<img src="/2022/03/05/16-32-26/image-20220502134540053-16514703414583.png" alt="image-20220502134540053"><figcaption aria-hidden="true">image-20220502134540053</figcaption>
</figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">--cpu Cortex-M4.fp.sp *.o </span><br><span class="line">--strict --scatter &quot;.\Objects\project.sct&quot; </span><br><span class="line">--summary_stderr --info summarysizes --map --xref --callgraph --symbols </span><br><span class="line">--info sizes --info totals --info unused --info veneers </span><br><span class="line"> --list &quot;.\Listings\project.map&quot; </span><br><span class="line">-o .\Objects\project.axf </span><br></pre></td></tr></table></figure>
<h3 id="arm寻址方式">ARM寻址方式：</h3>
<h4 id="寄存器间接寻址">寄存器间接寻址：</h4>
<p>把寄存器当作存储器的指针。</p>
<p><img src="/2022/03/05/16-32-26/image-20220507083936948-16518839785891.png" alt="image-20220507083936948" style="zoom:50%;"></p>
<h1 id="体系结构架构">体系结构——架构</h1>
<p>架构由指令集和操作空间（寄存器和存储器）组成</p>
<p>计算机中使用的单词叫指令，计算机使用的词汇表叫指令集</p>
<p>指令包含操作码和操作数，操作数来自于存储器，寄存器和指令本身</p>
<p>ARM架构将每条指令表示为一个32位的字，微处理器是一个可以读入并执行机器语言的指令的数字电路系统</p>
<p>ARM设计的四个准则：</p>
<ul>
<li>规范性支持简单设计</li>
<li>加快常见功能</li>
<li>越小设计越快</li>
<li>好的设计需要折中方法</li>
</ul>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>双轮自平衡小车制作指南</title>
    <url>/2022/02/25/19-20-54/</url>
    <content><![CDATA[<h1 id="双轮自平衡小车制作指南">双轮自平衡小车制作指南</h1>
<h3 id="整体介绍">整体介绍</h3>
<p>这将会是我制作自平衡小车的一个开始，本文的目标在于设计一个简单的自平衡小车，实现自平衡站立和行进。作品将依托于开源硬件平台Arduino，使用C语言进行程序开发。</p>
<p>双轮小车与四轮小车不同，双轮小车本身是一个欠稳定系统。将一个双轮小车直立着放在地面上时，小车难以站立，而是会向前或者向后倾倒。若要使小车维持稳定站立，我们需要引入一个控制系统。当小车将要向前倾倒时，控制电机带动轮胎向前移动，便阻止了小车前倾；同理可知小车后倾时可以向后移动阻止后倾，从而实现小车的平衡。</p>
<p>为了实现上述的控制，首先我们需要实时获取小车的“姿态”，即小车向前倾倒还是向后倾倒，以及倾倒的程度（一般使用角度来表示这个倾倒的程度）。“姿态”的获取需要使用可以测量加速度和角加速度的传感器，这种传感器被称作惯性测量单元 (IMU)，惯性测量单元获取的数据可以帮助我们获取小车“姿态”。</p>
<p>第二步是依据小车的“姿态”，控制电机活动，具体的控制内容包括电机的转速和转向。</p>
<h3 id="材料准备">材料准备</h3>
<p>实现一个最基础的平衡小车需要以下组件：</p>
<ul>
<li>微控制器：Arduino Nano 开发板</li>
<li>惯性测量单元 (IMU) ：MPU6050模块</li>
<li>电机：
<ul>
<li>N20减速直流电机（带霍尔编码器，详细参数见后文）</li>
<li>双母头电机端子线（型号：ZH1.5MM）</li>
<li>端子线贴片插座（型号：ZH1.5MM）</li>
</ul></li>
<li>电源：
<ul>
<li>7.4V锂电池</li>
<li>AMS1117降压电源模块（5V）</li>
<li>USB-Typec母头（带PCB板）</li>
</ul></li>
<li>外壳：3D打印外壳</li>
<li>电路板：立创EDA设计原理图和PCB板</li>
<li>其他：
<ul>
<li>N20减速直流电机配套固定架和D字轴轮胎</li>
<li>螺丝螺母</li>
<li>面包板和杜邦线（学习和测试时使用，实际小车中不使用）</li>
<li></li>
</ul></li>
</ul>
<h3 id="arduino-nano-介绍">Arduino Nano 介绍</h3>
<h4 id="初始arduino">初始Arduino</h4>
<p>Arduino是一款开源的嵌入式硬件开发平台，不仅包括了众多型号的开发板，而且包括了一个集成开发环境（IDE）辅助开发者编程，烧录和通信。Arduino本身提供了许多标准库，这些库的封装程度高，因此用户不必去关心寄存器配置而是可以通过库函数的调用来实现各种功能。Arduino作为一个受欢迎的开源平台，在互联网上可以找到大量的资料和例程进行学习。除了上文提到的标准库之外，Arduino还有各种用户针对不同外设写的库，可以在Arduino中轻松的获取和使用。Arduino本身还提供有图形化编程选项，即便是不会编程的非专业人士也可以快速上手。Arduino帮助我们从嵌入式硬件开发底层的细节中挣脱出来，把注意力放在控制本身这件事上。而且，鉴于本文的希望依托于一个可靠的开源平台且尽可能构造一个简单的自平衡小车，因此Arduino平台成为了我的首选。</p>
<p>进行电子设计时，我们首先要确定控制核心的选择。在这里我们选择了Arduino里面的Nano开发板进行开发。下图是Nano的模型图/引脚图。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162323982.png" alt="image-20220226162323982" style="zoom:67%;"></p>
<p>第一次接触硬件设计的人可能看到这张图会感到很复杂且不知所措。因此接下来我们将会通过一些实验来认识Nano。在结束这一章时再次回来看这张图片，或许你就会感到亲切了。</p>
<h4 id="实验1控制">实验1——控制</h4>
<p>Ardino是一块开源的嵌入式硬件平台，这句话对于初学者来说可能会是一个巨大的困扰，因为嵌入式是何意义，向初学者“正确”的解释清楚这件事并不容易。但是，不理解这段话并不影响我们去使用Arduino Nano来进行一些小开发。我们只需要牢牢记住一件事，那就是Nano是一个微控制器，微就是微小的意思，Nano就是个小型的控制器。控制器就是用来做控制的。接下来我们先从一个简单的实验入手，使用这个控制器去做一些控制。</p>
<p>首先我们先理解控制的概念，我们会希望控制什么呢？可能有人说，控制机器人！或者是控制一个遥控飞机飞行！是的，这些是控制，但是这种难度的控制并不适合一个初学者去学习。其实，控制无处不在，比如，我们按下开关，就可以打开灯，开关就是一个控制器，控制着灯的亮灭。现在，让我们把开关换成Nano，用它来控制一个LED小灯的亮灭。</p>
<p>实验需要准备：</p>
<ul>
<li>Arduino Nano开发板（焊接好排针），Arduino IDE，Micro USB接口的数据线</li>
<li>面包板和杜邦线（双公头）</li>
<li>LED灯和电阻</li>
</ul>
<p>首先，按照下图的方法连接电路。</p>
<p>然后打开Arduino IDE：用数据线将Nano与电脑相连接，选择相应的型号的开发板和端口，在编辑器中写入代码，然后点击编译并烧录，具体操作如下图：</p>
<p>图中代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED = <span class="number">7</span>;               <span class="comment">// 给D7引脚重命名为LED</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(LED, OUTPUT);        <span class="comment">// 将名为LED的引脚设置为（数字）输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED, HIGH);       <span class="comment">// 向LED引脚进行写入“高”，表示输出高电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">  digitalWrite(LED, LOW);        <span class="comment">// 向LED引脚进行写入“低”，表示输出低电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述操作后，就能看到LED亮一秒，灭一秒了。</p>
<p>使用模拟量（analogWrite(Pin,Value)函数的本质是PWM驱动）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte GND = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> byte LED = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(GND, OUTPUT);</span><br><span class="line">  pinMode(LED, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  analogWrite(GND, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i = i + <span class="number">50</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    analogWrite(LED, i);</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  analogWrite(LED, <span class="number">0</span>);</span><br><span class="line">  delay(<span class="number">1500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实验2通信">实验2——通信</h4>
<h4 id="实验3">实验3——</h4>
<h3 id="电机基础">电机基础</h3>
<h4 id="了解直流电机">了解直流电机</h4>
<p>学习和使用电机之前，我们首先要对电机的基本原理有一定的认识。最基础的电机的是我们在中学阶段就学习过的直流电机。直流电机是一个放在磁场中的导线转子，当有直流电流过导线转子时，转子便受力旋转。直流电机通入直流后转子转速很快，但是其扭矩——或者说转动的力度，很小。但是为了能带动轮胎转动实现小车行进，我们需要转子拥有较大的扭矩。于是我们有了减速直流电机。减速直流电机相比于直流电机多了一个减速箱。减速箱内部有许多齿轮，转子转动带动减速箱内部的齿轮转动，这一过程将导致转轴转速降低而扭矩提高，因此我们称其为减速电机。减速电机中最重要的参数是减速比。减速比的大小等于减速箱外的转轴转一圈时直流电机转子转过的圈数。我们使用的N20电机就是一个减速直流电机。</p>
<p>驱动直流电机的方法非常简单，只需要在电机的两个端子上接上正负电压，电机便开始转动。若是交换两端子上的电压，则电机会沿于之前相反的方向转动。对于装有编码器的N20电机来说，标注为M1和M2的端子为直流电机的端子。</p>
<p>为了更全面的理解电机，我们应该了解另一种常见的电机类型——步进电机，以便在其他时候遇到的话不至于与现在所学的电机相混淆。步进电机是一种可以顾名思义的东西，只不过大多数人在最开始想到的含义可以不太正确。步进电机不是专指用来前进或者行进的电机，毕竟很显然的是，只要外界轮子，直流电机也可以前进。步进电机这个名字来源于电机的内部构造，转子在脉冲信号输入下发生一步一步的转动，这种一步一步的转动的效果有点像钟表的秒针，每一秒在表盘上走一小步，一步一步的旋转，最终一分钟后旋转了一圈。如果我们加快这一过程，这样电机就不再是做一顿一顿的运动了，而是一个连续不断的快速的旋转。</p>
<p>步进电机只是转子旋转的原理和直流电机不同，但是依然可以在步进电机外接入减速箱。这两个电机的定语是两种平行的分类方式，这点不要混淆。</p>
<p>我们回到上文的直流电机，如果想要了解更多关于步进电机的知识，可以在搜索引擎上搜索“步进电机”，在这里我只是做简单的介绍。</p>
<p>直流电机有两个端子，施加正负电压即可驱动马达转动，交换正负电压就可以改变马达转向。前者非常简单，只需要提供一个外接直流电源，或者使用Nano的5V引脚和GND引脚就可以驱动电机转动，手动改变电流源极性或者使用微控制器调整输出电压信号都可以改变马达转向。但是如开篇我们所说的，我们需要同时控制电机转速和转向。为此，我们需要学习使用一种要脉冲宽度调制（Pulse-width modulation）的技术来控制电机的转速。下面我们就来详细地了解一下PWM技术，并且使用Nano来控制电机的转速和转向。</p>
<h4 id="脉冲宽度调制pwm">脉冲宽度调制（PWM）</h4>
<h5 id="pwm简介">PWM简介*</h5>
<p>TODO</p>
<h5 id="在arduino中使用pwm">在Arduino中使用PWM</h5>
<p>TODO</p>
<h4 id="编码器">编码器</h4>
<p>TODO</p>
<h3 id="mpu6050">MPU6050</h3>
<h4 id="原始数据">原始数据</h4>
<p>双轮自平衡小车使用的惯性测量单元 (IMU) 是MPU6050，包含一个三轴的加速度传感器和一个三轴的陀螺仪。加速度传感器可以获取运动的物体在三个坐标轴方向上的加速度，陀螺仪可以获取绕坐标轴旋转的物体的角加速度。</p>
<p>对于双轮自平衡小车，我们需要其在一个坐标轴方向上的角度信息。从小车侧面看，仅有可能向左右两个方向倾倒，而不会向前后倾倒，并且小车的静止和行进都是在地面这个水平面进行，因此不需要关心Z轴上的变化。因此，设计一个自平衡小车，我们只需要关注其绕X轴或是绕Y轴的角度（取决于模块的放置方式）问题即可。</p>
<p>在本次设计中，我将按照下图的方式放置MPU6050，因此我们关注的是绕X轴的角度变化。</p>
<figure>
<img src="/2022/02/25/19-20-54/照片预览_2022-02-27-16459370460521.svg" alt="照片预览_2022-02-27"><figcaption aria-hidden="true">照片预览_2022-02-27</figcaption>
</figure>
<p>为了实时获取小车的角度信息，我们需要同时使用加速度传感器和陀螺仪。单独测试MPU6050模块时，可以将将MPU6050模块的VCC引脚接Nano的5V引脚，MPU6050模块的GND引脚接Nano的GND引脚。接入电源后模块便能实时产生六个数据（实际数据比六个多，还包括温度数据，这里不进行介绍），我们使用<span class="math inline">\(I^2C\)</span>通信方式进行MPU6050模块和Nano之间的通信。进行<span class="math inline">\(I^2C\)</span>通信时，首先要将MPU6050模块的SCL引脚与Nano的SCL引脚相连，MPU6050模块的SDA引脚与Nano的SDA引脚相连。但是，这里存在一个问题是，在Nano的PCB板上我们找不到名为SCL与SDA的引脚。这时候我们就要回到文章开头的那张Nano引脚图了。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162741791.png" alt="image-20220226162741791" style="zoom: 50%;"></p>
<p>在图中我们可以看到Nano的A4引脚外面写着SDA，A5引脚外写着SCL，其实这是表示引脚的公用，即A4引脚既能做一个单纯的模拟引脚使用，也可以作为SDA引脚使用。因此，为了将MPU6050中产生的数据导入到Nano中，我们MPU6050模块的SDA引脚与Nano的A4引脚相连，SCL与A5相连。连接好之后，我们就可以通过代码来进行程序读取了。</p>
<p>使用Arduino进行<span class="math inline">\(I^2C\)</span>通信一般需要用到“Wire.h”这个标准库，使用“Wire.h”我们首先要将它包含进来。使用时，首先要进行初始化，与串口通信相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要读取MPU6050中的数据，我们需要知道其地址，然后进行数据传输，具体的代码操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//配置MPU6050的加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x1C</span>);</span><br><span class="line">  Wire.write(<span class="number">0x00</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本阶段的目标在于读取MPU6050中的原始数据，包括三个坐标方向上的加速度信息和三个方向上的角加速度信息。为了存储这些读取来的数据，我们设置了6个浮点数类型的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX, GyroY, GyroZ;</span><br></pre></td></tr></table></figure>
<p>来存储数据，之所以是变量数据类型而不是数组，因为这6个信息是实时测量值，在loop()这个函数中每一列都会获取当下的这六个数据，并立即进行处理，通过数学运算获取实时的角度信息，而下一刻的角度信息则有下一刻的六个数据计算得来。loop()函数中实时获取六个数据的方法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//读取加速度的值：</span></span><br><span class="line">  <span class="comment">//开启加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//读取角加速度的值：</span></span><br><span class="line">  <span class="comment">//开启角加速度模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取角加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码中，以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br></pre></td></tr></table></figure>
<p>为例，在MPU6050中直接读取的数据为<span class="math inline">\(AccX*16384.0\)</span>，之所以这里要将<span class="math inline">\(16384.0\)</span>这个数字除掉，其实是在进行单位转换，将加速度的单位转化为<span class="math inline">\(g\)</span>，这里的<span class="math inline">\(g=9.8\)</span>其实就是重力加速度。这里之所以将加速度的单位统一为重力加速度，是因为从原理上看，加速度计测量加速度原理就是以重力加速度为参考求出来的，所以一般将加速度的单位设为重力加速度。</p>
<p>使用上述代码</p>
<h4 id="数字滤波器">数字滤波器</h4>
<p>TODO</p>
<p>一阶互补滤波器（仅roll值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C address</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX = <span class="number">-1.5</span>,GyroErrorX = <span class="number">-0.25</span>,rollError = <span class="number">-3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">19200</span>);</span><br><span class="line">  Wire.begin();                      <span class="comment">// Initialize comunication</span></span><br><span class="line">  Wire.beginTransmission(MPU);       <span class="comment">// Start communication with MPU6050 // MPU=0x68</span></span><br><span class="line">  Wire.write(<span class="number">0x6B</span>);                  <span class="comment">// Talk to the register 6B</span></span><br><span class="line">  Wire.write(<span class="number">0x00</span>);                  <span class="comment">// Make reset - place a 0 into the 6B register</span></span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);        <span class="comment">//end the transmission</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// === Read acceleromter data === //</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>); </span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Y-axis value</span></span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Z-axis value</span></span><br><span class="line">  accAngleX = (<span class="built_in">atan</span>(AccY / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(AccX, <span class="number">2</span>) + <span class="built_in">pow</span>(AccZ, <span class="number">2</span>))) * <span class="number">180</span> / PI) - AccErrorX;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// === Read gyroscope data === //</span></span><br><span class="line">  previousTime = currentTime;</span><br><span class="line">  currentTime = millis();</span><br><span class="line">  elapsedTime = (currentTime - previousTime) / <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroX = GyroX - GyroErrorX;</span><br><span class="line">  gyroAngleX = gyroAngleX + GyroX * elapsedTime;</span><br><span class="line">  </span><br><span class="line">  roll = <span class="number">0.96</span> * gyroAngleX + <span class="number">0.04</span> * accAngleX -rollError;</span><br><span class="line">  Serial.println(roll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pid控制">PID控制</h3>
<p>TODO</p>
<h3 id="d建模制作小车外壳">3D建模——制作小车外壳</h3>
<p>TODO</p>
<h3 id="pcb设计制作小车电路板">PCB设计——制作小车电路板</h3>
<p>与使用面包板进行测试不同，绘制PCB板时使用的连线在打印PCB后就会固定下来，因此我们必须在编程时调用相应的引脚，这样才不会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HC06</span></span><br><span class="line"><span class="comment">//TX-&gt;Nano_Rx</span></span><br><span class="line"><span class="comment">//RX-&gt;Nano_TX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050</span></span><br><span class="line"><span class="comment">//SCL-&gt;Nano_A5</span></span><br><span class="line"><span class="comment">//SDA-&gt;Nano_A4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050 仅计算Roll时需要的变量如下</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX,GyroErrorX,rollError;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//小车直行代码</span></span><br><span class="line">  analogWrite(L1_M1,<span class="number">255</span>);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,<span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录一个可以使用的卡尔曼滤波器，直接使用下面的代码可以使用串口绘图器绘制出Roll的角度变化，打开绘图器时Roll的值记作0，然后表现为相对偏移，这个滤波器效果还不错，至少比那个一阶互补滤波器强，但是感觉相应速度不是很快。</p>
<p>主函数：</p>
<p>Kalman Filter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println(GetValue());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">  	fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建标签："Kalman.cpp"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kalman::Kalman() </span><br><span class="line">&#123;</span><br><span class="line">  Q_angle = <span class="number">0.001f</span>;</span><br><span class="line">  Q_bias = <span class="number">0.003f</span>;</span><br><span class="line">  R_measure = <span class="number">0.03f</span>;</span><br><span class="line"></span><br><span class="line">  angle = <span class="number">0.0f</span>;</span><br><span class="line">  bias = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span> </span><br><span class="line">&#123;</span><br><span class="line">  rate = newRate - bias;</span><br><span class="line">  angle += dt * rate;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] += dt * (dt * P[<span class="number">1</span>][<span class="number">1</span>] - P[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>][<span class="number">0</span>] + Q_angle);</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] += Q_bias * dt;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> S = P[<span class="number">0</span>][<span class="number">0</span>] + R_measure;</span><br><span class="line">  <span class="type">float</span> K[<span class="number">2</span>];</span><br><span class="line">  K[<span class="number">0</span>] = P[<span class="number">0</span>][<span class="number">0</span>] / S;</span><br><span class="line">  K[<span class="number">1</span>] = P[<span class="number">1</span>][<span class="number">0</span>] / S;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> y = newAngle - angle;</span><br><span class="line">  angle += K[<span class="number">0</span>] * y;</span><br><span class="line">  bias += K[<span class="number">1</span>] * y;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> P00_temp = P[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="type">float</span> P01_temp = P[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] -= K[<span class="number">0</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= K[<span class="number">0</span>] * P01_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= K[<span class="number">1</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] -= K[<span class="number">1</span>] * P01_temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setAngle</span><span class="params">(<span class="type">float</span> angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;angle = angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRate</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;rate;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_angle = Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_bias = Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;R_measure = R_measure;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQangle</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQbias</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRmeasure</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;R_measure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新建标签"Kalman.h"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Kalman_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Kalman_h_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kalman</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    Kalman();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAngle</span><span class="params">(<span class="type">float</span> angle)</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQangle</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQbias</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRmeasure</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    <span class="type">float</span> Q_angle;</span><br><span class="line">    <span class="type">float</span> Q_bias;</span><br><span class="line">    <span class="type">float</span> R_measure;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> angle;</span><br><span class="line">    <span class="type">float</span> bias;</span><br><span class="line">    <span class="type">float</span> rate;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> P[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Kalman_Filter(Adxl_angle, Gyro_sensor); <span class="comment">//卡尔曼融合获取angle</span></span><br><span class="line">Input = angle;</span><br><span class="line">myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PID_v1.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Setpoint, Input, Output;</span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line">  PID <span class="title function_">myPID</span><span class="params">(&amp;Input, &amp;Output, &amp;Setpoint,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>, DIRECT)</span>; <span class="comment">//PID对象声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  setupPID();  <span class="comment">//PID初始化</span></span><br><span class="line">    </span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line">  </span><br><span class="line">  Input = GetValue();</span><br><span class="line">  myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">  Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Drive</span><span class="params">(<span class="type">float</span> Output)</span></span><br><span class="line">&#123;    </span><br><span class="line">  analogWrite(L1_M1,Output);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,Output);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setupPID</span><span class="params">()</span>&#123;</span><br><span class="line">  Input = <span class="number">0</span>;</span><br><span class="line">  Setpoint = <span class="number">17</span>;  <span class="comment">//我的小车自平衡角度为17</span></span><br><span class="line">  myPID.SetSampleTime(<span class="number">100</span>);  <span class="comment">//控制器的采样时间100ms</span></span><br><span class="line">  <span class="comment">//myPID.SetOutputLimits(0, 2000); </span></span><br><span class="line">  myPID.SetMode(AUTOMATIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>记录</title>
    <url>/2022/03/15/15-32-05/</url>
    <content><![CDATA[<h1 id="fpga">FPGA</h1>
<h3 id="时序约束">时序约束</h3>
<ol type="1">
<li>如通信实验，时钟频率比较高的实验，需要进行时序约束</li>
<li>当占用芯片的逻辑资源多的时候，需要使用时序约束：因为FPGA在布线时会优先考虑面积</li>
</ol>
<p>时钟约束用来描述设计人员对于时序的要求，包括时钟频率和输入输出延时</p>
<p>D触发器</p>
<p>arduino 机械臂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myservo_1;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_2;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_3;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line"><span class="type">int</span> pos_1 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_2 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_3 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.attach(<span class="number">12</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">    myservo_2.attach(<span class="number">11</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">      myservo_3.attach(<span class="number">10</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_1 = <span class="number">0</span>; pos_1 &lt;= <span class="number">10</span>; pos_1 ++) &#123; <span class="comment">// 0°到180°</span></span><br><span class="line">    <span class="comment">// in steps of 1 degree</span></span><br><span class="line">    myservo_1.write(pos_1);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">for</span> (pos_2 = <span class="number">0</span>; pos_2 &lt;= <span class="number">60</span>; pos_2 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_2.write(pos_2);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_3 = <span class="number">0</span>; pos_3 &lt;= <span class="number">30</span>; pos_3 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_3.write(pos_3);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_1.write(<span class="number">-5</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////  for (pos_1 = 0; pos_1 &lt;= 120; pos_1 ++) &#123; // 0°到g180°</span></span><br><span class="line"><span class="comment">////    // in steps of 1 degree</span></span><br><span class="line"><span class="comment">////    myservo_1.write(pos_1);              // 舵机角度写入</span></span><br><span class="line"><span class="comment">////    delay(5);                       // 等待转动到指定角度</span></span><br><span class="line"><span class="comment">////  &#125;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字电路中的逻辑值">数字电路中的逻辑值：</h3>
<ul>
<li>逻辑 0：表示低电平，相当于电路 GND。</li>
<li>逻辑 1：表示高电平，相当于电路 VCC。</li>
<li>逻辑 X：表示未知，高或低。</li>
<li>逻辑 Z：表示高阻态，悬空状态</li>
</ul>
<h3 id="verilog-中的数字表示">Verilog 中的数字表示：</h3>
<p>“（数字的二进制）位宽 + 进制（缩写） + 数值”来表示一个数字。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制0101的表示</span></span><br><span class="line"><span class="number">4&#x27;b0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制2的表示，数字2的二进制表示为0010占4位</span></span><br><span class="line"><span class="number">4&#x27;d2</span></span><br></pre></td></tr></table></figure>
<p>Verilog 的默认二进制位宽为32位，默认的进制为十进制。</p>
<p>当二进制数字位数多的时候可以使用下划线增加可读性，编译时下划线会被去掉。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16&#x27;b1001_1010_1010_1001</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符">标识符：</h4>
<p>Verilog 的标识符可以用于定义模块名、端口名和信号名。</p>
<p>Verilog 的命名规则与 C 语言变量名的命名规则基本相同：只有一点，可以在命名中包含$符号。</p>
<p>标识符规则：</p>
<ul>
<li></li>
</ul>
<p>标识符推荐写法：</p>
<ul>
<li>不建议大小写混合</li>
<li>普通内部信号全部小写</li>
<li>信号命名体现含义</li>
<li>使用下划线区分词</li>
<li>采用前后缀：比如时钟可以采用：clk_50，clk_cpu</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>三种数据类型：</p>
<ul>
<li><p>寄存器数据类型：实际电路物理模型</p>
<ul>
<li><p>抽象数据存储单元，可以通过赋值语句改变寄存器储存的值</p></li>
<li><p>关键字：reg，默认初始值为 X 不确定</p></li>
<li><p>```verilog // reg + [位宽：31:0 指32位位宽，高位在前] + 标识符名称（寄存器名称） reg [31:0] delay_cnt; //延时计数使用的寄存器 reg key_reg; //没给位宽时默认位宽为1 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  + reg 类型的数据只能在 always 语句和 initial 语句中被赋值</span><br><span class="line"></span><br><span class="line">  + 如果 always 中带有时钟信号即过程语句描述的是时序逻辑，则寄存器对应为触发器</span><br><span class="line"></span><br><span class="line">  + 如果 always 中不带有时钟信号即过程语句描述的是组合逻辑，则寄存器对应为硬件连线</span><br><span class="line"></span><br><span class="line">  + </span><br><span class="line"></span><br><span class="line">+ 线网数据类型：实际电路物理模型</span><br><span class="line"></span><br><span class="line">+ 参数数据类型：给编译器用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 图像处理</span><br><span class="line"></span><br><span class="line">OV7725摄像头</span><br><span class="line"></span><br><span class="line">主控器控制OV7725时采用SCCB协议读写其寄存器，而它输出图像时则使用VGA或QVGA时序， 其中VGA在输出图像分辨率为480*640时采用，QVGA是Quarter VGA，其输出分辨率为240*320， 这些时序跟控制液晶屏输出图像数据时十分类似。</span><br><span class="line"></span><br><span class="line">OV7725传感器输出图像时，一帧帧地输出，在帧内的数据一般从左到右，从上到下， 一个像素一个像素地输出(也可通过寄存器修改方向)，见图 [摄像头数据输出](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id20) 。</span><br><span class="line"></span><br><span class="line">![摄像头数据输出](记录/OV7725012.jpg)</span><br><span class="line"></span><br><span class="line">例如，见图 [像素同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id21) 和图 [QVGA帧图像同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#qvga) ， 若我们使用D2-D9数据线，图像格式设置为RGB565，&lt;img src=&quot;记录/image-20220326130518483.png&quot; alt=&quot;image-20220326130518483&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">```verilog</span><br><span class="line">//RGB数据转换为YCBCR</span><br><span class="line">//因为FPGA处理除法是比较耗费资源的，所以我们团队采用左移右移以替代乘除法。处理整形数据可以将数据整体左移八位，再进行计算，最后在右移回去即可。</span><br><span class="line"></span><br><span class="line">Y’ = 0.257R’ + 0.504G’ + 0.098*B’ + 16</span><br><span class="line">Cb’ = -0.148R’ - 0.291G’ + 0.439*B’ + 128</span><br><span class="line">Cr’ = 0.439R’ - 0.368G’ - 0.071*B’ + 128</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>进行数据输出时，D2-D9数据线在PCLK在上升沿阶段维持稳定， 并且会在1个像素同步时钟PCLK的驱动下发送1字节的数据信号，所以2个PCLK时钟可发送1个RGB565格式的像素数据。 当HREF为高电平时，像素数据依次传输，每传输完一行数据时，行同步信号HREF会输出一个电平跳变信号间隔开当前行和下一行的数据； 一帧的图像由N行数据组成，当VSYNC为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC会输出一个电平跳变信号。</p>
<p><img src="/2022/03/15/15-32-05/image-20220326132950059.png" alt="image-20220326132950059" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rows=<span class="number">200</span></span><br><span class="line">cols=<span class="number">300</span></span><br><span class="line">num=<span class="number">2000</span> <span class="comment">#随机像素点的个数</span></span><br><span class="line">img=np.zeros((rows,cols,<span class="number">3</span>),np.uint8)</span><br><span class="line">pos1=np.random.randint(<span class="number">200</span>,size=(num,<span class="number">1</span>)) <span class="comment">#行位置随机数组</span></span><br><span class="line">pos2=np.random.randint(<span class="number">300</span>,size=(num,<span class="number">1</span>)) <span class="comment">#列</span></span><br><span class="line"><span class="comment">#随机位置处设置像素点值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">0</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">1</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">2</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">如果在OpenCV中处理图像，是BGR的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I=numpy.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=numpy.uint8) </span><br><span class="line"><span class="comment">#图片I大小为3*3，灰度值全为0，也就是黑色图像</span></span><br><span class="line">I=cv2.cvtColor(I,cv2.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#此时图像I变成了三个通道的每个像素点的值都为0</span></span><br><span class="line"><span class="comment">#有27个像素值，HSV色彩空间也是同样的方式，只是只是通道数不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emptyImage = np.zeros(img.shape, np.uint8)</span><br><span class="line">cv2.imshow(<span class="string">&quot;EmptyImage&quot;</span>, emptyImage) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">Strawberry=cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line"><span class="comment">#Strawberry=cv2.imread(&quot;strawberry.jpg&quot;)</span></span><br><span class="line">Lower = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">Upper = np.array([<span class="number">40</span>, <span class="number">40</span>, <span class="number">255</span>])</span><br><span class="line">Binary = cv2.inRange(Strawberry, Lower, Upper)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>, Binary)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\fruits.jpg&#x27;</span>)</span><br><span class="line">fruit = cv2.cvtColor(fruit,cv2.COLOR_BGR2YUV)</span><br><span class="line">Y,U,V = cv2.split(fruit)</span><br><span class="line">Blueberry = cv2.inRange(U,<span class="number">130</span>,<span class="number">255</span>)</span><br><span class="line">Strawberry = cv2.inRange(V,<span class="number">170</span>,<span class="number">255</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;blueberry&quot;</span>,Blueberry)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>,Strawberry)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line">skin1 = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OSTU&quot;</span>, skin1)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cr_otsu1</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;YCrCb颜色空间的Cr分量+Otsu阈值分割</span></span><br><span class="line"><span class="string">    :param image: 图片路径</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"></span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">_, skin = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image raw&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image raw&quot;</span>, img)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image CR&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, skin)</span><br><span class="line"></span><br><span class="line">dst = cv2.bitwise_and(img, img, mask=skin)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;seperate&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;seperate&quot;</span>, dst)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="灰度化">灰度化</h3>
<p>转换色彩空间：</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\name_of_picture&#x27;</span>)</span><br><span class="line">img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"><span class="comment">#img_YUV = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span></span><br><span class="line"><span class="comment">#img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img_ycbcr)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>以RGB格式的彩图为例，通常灰度化采用的方法主要有：</p>
<p>方法1：<span class="math inline">\(Gray=(R+G+B)/3\)</span></p>
<p>方法2：<span class="math inline">\(Gray=max(R,G,B)\)</span></p>
<p>方法3：<span class="math inline">\(Gray=0.299R+0.587G+0.114B\)</span>（这种参数考虑到了人眼的生理特点）</p>
<p>所谓阈值处理，就是给定一个阈值，当像素值比指定阈值大或小时做相关的操作。==这个字念yu，不是fa==，方法签名为:<code>cv2.threshold(src,thresh,maxval,type,dst=None)</code>,需要将的是OpenCV中提供的几种type：</p>
<ul>
<li>cv2.THRESH_BINARY：若像素值大于阈值，则置为maxval；否则置0</li>
<li>cv2.THRESH_BINARY_INV：THRESH_BINARY的反转</li>
<li>cv2.THRESH_TRUNC：若像素值大于阈值，则置为阈值；否则不变</li>
<li>cv2.THRESH_TOZERO：小于阈值的部分置为0；其他不变</li>
<li>cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">_, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY_INV)</span><br><span class="line">_, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TRUNC)</span><br><span class="line">_, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO)</span><br><span class="line">_, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO_INV)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#固定阈值的二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>选则合适的阈值筛选不同的色块，链接下文轮廓识别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自适应阈值二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th3)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="腐蚀">腐蚀</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;i.png&quot;</span>)</span><br><span class="line">img_noise = copy.deepcopy(img)</span><br><span class="line"><span class="comment"># add some noise to original image</span></span><br><span class="line">rows, cols = img_noise.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">	i = random.randint(<span class="number">0</span>, rows - <span class="number">1</span>)</span><br><span class="line">	j = random.randint(<span class="number">0</span>, cols - <span class="number">1</span>)</span><br><span class="line">	img_noise[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), dtype=np.uint8)</span><br><span class="line">erosion = cv2.erode(img_noise, kernel)</span><br><span class="line">dilation = cv2.dilate(erosion, kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;rectangle.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_contours_of_binary_image</span>():</span><br><span class="line">	im = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>)</span><br><span class="line">	imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">	ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">		<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">	res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">   	img_show(res)</span><br><span class="line">    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>轮廓检测能用代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">kernel = np.ones((<span class="number">1</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, anchor=(<span class="number">2</span>, <span class="number">0</span>), iterations=<span class="number">5</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>能看懂的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调节二值化的阈值可以描出不同的色块</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">100</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="二值化">二值化</h3>
<p>二值图也就是黑白图。将灰度图转换成黑白图的过程，就是二值化。二值化的一般算法是：</p>
<p><span class="math inline">\(g={0,f≤t1,f&gt;t}\)</span></p>
<p>其中t被称为阀值。阀值的确定方法有下面几种。</p>
<h2 id="otsu法大津法或最大类间方差法">Otsu法（大津法或最大类间方差法）</h2>
<p>来自霓虹国的大津展之为这种波谷找到了一个合适的数学表达，并于 1979 年发表论文[2]。这个二值化方法称为<strong>大津算法（Otsu’s method）</strong>。</p>
<p>大津算法就是，<strong>从 1 到 255 一个个数字试，找到一个数字能够把两个波峰切开</strong>，让两个波峰内部的类内方差之和最小。类内方差之和就是，单独求这两个波峰各自的方差，乘上波峰的占比权重，然后加起来。</p>
<p>这个数字就能最好的把图像分开，<strong>对应的就是双峰直方图中的波谷</strong>。这个算法最多只需遍历两次直方图数组，速度飞快，至今仍被广泛应用。</p>
<p>图像比较复杂的时候，我们对大津算法稍加扩展也可以完成分割。对大津算法的多级推广成为<strong>多大津算法（multi Otsu method） [3]</strong>。</p>
<p>*这里提到的是局部阈值的基本方法，对于实际使用中常见的其他局部阈值方法，请参阅<strong>Chow-Kaneko 自适应阈值法 [4]</strong>。</p>
<p>局部阈值的应用非常广泛，特别是对白纸黑字的处理非常有效。光学字符识别（OCR）和二维码扫描的算法中，很多都用了局部阈值操作。比如下面这张受光不均的二维码。</p>
<p>该算法是一种动态阈值分割算法。它的主要思想是按照灰度特性将图像划分为背景和目标2部分（这里我们将f≤t的部分称为背景，其他部分称为目标。），选取门限值，使得背景和目标之间的方差最大。</p>
<blockquote>
<p>注：Nobuyuki Otsu（大津展之），东京大学博士，先后在筑波大学和东京大学担任教授。</p>
</blockquote>
<p>其步骤如下：</p>
<p>1.建立图像灰度直方图。</p>
<p>2.计算背景和目标的出现概率。</p>
<p><span class="math inline">\(pA=∑i=0tpi,pB=∑i=t+1L−1pi=1−pA\)</span></p>
<p>其中，A和B分别表示背景部分和目标部分。</p>
<p>3.计算A和B两个区域的类间方差。</p>
<p><span class="math inline">\(公式ωA=∑i=0tipipA,ωB=∑i=t+1L−1ipipB(公式1)\)</span></p>
<p>公式1分别计算A和B区域的平均灰度值；</p>
<p>公式<span class="math inline">\(ω0=pAωA+pBωB=∑i=0L−1ipi\)</span>(公式2)</p>
<p>公式2计算灰度图像全局的灰度平均值；</p>
<p>公式<span class="math inline">\(σ2=pA(ωA−ω0)2+pB(ωB−ω0)2\)</span>(公式3)</p>
<p>公式3计算A、B两个区域的类间方差。</p>
<p>4.针对每一个灰度值，计算类间方差。选择方差最大的灰度值，作为阀值t。</p>
<p>下面是几个在使用opencv作轮廓检测时需要注意的点：</p>
<ul>
<li>为了更精确地提取轮廓，请使用二值图。也就是说，在使用轮廓提取函数前，请将源图片运用阈值进行<code>二值化(cv2.threshold())</code>或者采用<code>Canny边缘检测</code>。</li>
<li>findContours 函数会修改源图片，如果希望在轮廓检测后继续使用源图片，务必提前保存在另一个变量中。</li>
<li>在OpenCV中，轮廓检测视作从黑色背景中提取白色的物体，所以，在结果中，白色表示物体，黑色表示背景。</li>
</ul>
<p><em>提取轮廓的步骤大概会是这样子：</em></p>
<ol type="1">
<li>读取源图片，并转化为灰度图</li>
<li>运用threshold将灰度图片二值化（也可以使用Canny边缘检测）</li>
<li>使用<code>findContours()函数</code>找到所有的轮廓</li>
<li>使用<code>drawContours()函数</code>将轮廓画出来</li>
</ol>
<p>https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</p>
<h2 id="图像处理">图像处理</h2>
<h3 id="形态学">形态学</h3>
<h4 id="膨胀">膨胀</h4>
<h5 id="简介">简介</h5>
<p>膨胀是数学形态学的两种基本运算之一，腐蚀是另一种基本运算。它通常应用于二值图像，但也有适用于灰度图像的版本。该算子对二值图像的基本作用是逐渐扩大前景像素(通常为白色像素)区域的边界。因此，前景像素的区域会增大，而这些区域内的孔会变小。</p>
<h5 id="它是如何运作的">它是如何运作的</h5>
<p>这个描述的有用背景在词汇表的数学形态学部分给出。</p>
<p>膨胀运算符接受两段数据作为输入。首先是要放大的图像。第二个是一组坐标点(通常很小)，称为结构元素(也称为内核)。正是这个构造元素决定了输入图像的精确膨胀效果。</p>
<p>二值图像膨胀的数学定义如下：</p>
<p>设X为输入二值图像对应的欧几里德坐标集，K为构造元素的坐标集。</p>
<p>Kx表示K的平移使其原点在x处。</p>
<p>那么X乘以K的膨胀就是所有点X的集合使得Kx与X的交点非空。</p>
<p>除了与输入图像相关联的一组坐标的导出方式之外，灰度膨胀的数学定义是相同的。此外，这些坐标是三维的，而不是二维的。</p>
<p>作为二元扩张的一个例子</p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电子专业资料共享计划</title>
    <url>/2022/03/23/15-24-59/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>我也曾很努力地收集各种课程资料，但到最后，某些重要信息的得到却往往依然是纯属偶然。这种状态时常令我感到后怕与不安。我也曾在课程结束后终于有了些许方法与总结，但这些想法无处诉说，最终只能把花费时间与精力才换来的经验耗散在了漫漫的遗忘之中。</p>
<p>我为这一年一年，这么多人孤军奋战的重复劳动感到不平。</p>
<p>我希望能够将这些隐晦的、不确定的、口口相传的资料和经验，变为公开的、易于获取的和大家能够共同完善、积累的共享资料。</p>
<p>我希望只要是前人走过的弯路，后人就不必再走。这是我的信念，也是我建立这个项目的原因。</p>
</blockquote>
<p>注：如果您对本篇博客的目的存在疑问，请阅读<a href="https://qsctech.github.io/zju-icicles/">此文</a>。</p>
<h3 id="加入我们">加入我们：</h3>
<p><strong>如果您有意愿加入该计划，请注册wolai账号并在<a href="https://www.wolai.com/aPVPDQTgKUnVaE9JQzKudx">此处</a>进行编辑，请选择文章最后一部分的”推荐模板“，并复制在其上面，然后将副标题改做”来自xxx的推荐“，结束后在评论区评论以联系我去将内容发布在博客内。</strong></p>
<h1 id="河南大学迈阿密学院电子信息专业培养计划及其课本">河南大学迈阿密学院电子信息专业培养计划及其课本</h1>
<h3 id="大一上学期">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 1 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>3 Longman Academic Writing Series</em><br> （无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 1 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>中国近现代史纲要</td>
<td>《中国近现代史纲要 （2018年版）》</td>
</tr>
<tr class="even">
<td>形式与政策</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>大学体育（一）College Physical Education I</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><a href="https://kdocs.cn/l/cbVej03YO5yb?f=201"><em>Elementary Linear Algebra</em><br></a>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td><em>Thinking Like an Engineer</em><br>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>编程导论（Introduction to Programming）</td>
<td><em>C++ Pregramming program Design Including Data Structures</em><br>（无中文版和答案）</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 2 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td>The Everyday Writer 6th Edition <br>（无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td>《流畅英语口语教程 第二册》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 2 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>思想道德修养与法律基础</td>
<td>《思想道德修养与法律基础 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（二）College Physical Education II</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 下》<br>参考答案</td>
</tr>
<tr class="odd">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td><em>Engineering Circuit Analysis</em><br>《工程电路分析 中文版》<br></td>
</tr>
<tr class="even">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td><em>Electric Circuit Ninth Edition</em><br>《电路 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>电路实验</td>
<td>“教师讲义 + 教学课件”</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 3 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>Technical Writing A Practical Guide for Engineers, Scientists, and Nontechnical Professionals by Phillip A. Laplante</em><br>无中文版</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 3 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>马克思主义基本原理概论</td>
<td>《马克思主义基本原理概论 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（三）College Physical Education III</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td><em>A Textbook on Ordinary Differential Equations</em><br>（无中文版和参考答案）<br>参考书：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="odd">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>数据结构（Data Structures）</td>
<td>《数据结构（C语言版）》<br><em>Data Structures Using C</em><br>参考资料：<a href="https://www.bilibili.com/video/BV1Fv4y1f7T1">视频课</a></td>
</tr>
<tr class="even">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="odd">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共两门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 4 智慧版》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 4 智慧版》</td>
</tr>
<tr class="even">
<td>大学体育（四）（College Physical Education IV）</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td><em>Probability, Statistics, and Random Processes For Electrical Engineerin</em><br>《机率与统计 第三版 中文版 台版》<br><a href>参考答案</a><br>参考资料：《概率论与数理统计 (第四版)》</td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>《信号与系统（郑君里）第三版 上》<br>参考书籍：<br>《信号与系统（郑君里）第三版 下》<br>《信号与系统（奥本海姆）第二版》</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td><em>Fundamentals Of Logic Design Seven Edition</em><br>《逻辑设计基础 中文版》<br>参考答案</td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>ARM：《微机原理与接口技术 第三版 基于ARM Cortex-M4 田辉》<br><em>Practical Microcontroller Engineering with ARMÂ­ Technology by Ying Bai<br></em>参考资料：x86：《微型计算机原理与接口技术》</td>
</tr>
<tr class="even">
<td><del>电子电路CAD （Electronic Circuit CAD）</del></td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期">大三上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td><em>Signal &amp; System</em><br>《中文版 信号与系统 奥本海姆》</td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td><em>Field and Wave Electromagnetics by David K. Cheng</em><br>《电磁场与电磁波 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td><em>Semiconductor physics and devices basic principles by Donald A. Neamen</em><br>《半导体物理与器件 中文版》</td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td><em>The 8051 Microcontroller A Systems Approach (Mazidi, Muhammad AliMcKinlay, Rolin DMazidi etc.)</em> <br>《8051单片机系统》<br>《单片机原理及接口技术 第5版》</td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td><em>Verilog HDL - A Guide To Digital Design And Synth<br></em>《Verilog HDL 数字设计与综合》</td>
</tr>
<tr class="even">
<td>创新项目实践（一）Practice of Innovation Project I</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期">大三下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td><del>《嵌入式系统设计——基于STM32CubeMX与HAL库》</del></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin<br></em>《通信系统 中文版》<br>《通信原理 第七版》</td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin</em><br>参考答案</td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td>《电力电子技术》<br>参考答案</td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td><em>Digital integrated circuits a design perspective</em><br>《数字集成电路——电路系统与设计 中文版》</td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td><em>Design of Analog CMOS Integrated Circuits by Behzad Razavi</em><br>《数字集成电路：电路、系统与设计第2版》<br></td>
</tr>
<tr class="odd">
<td>创新项目实践（二）Practice of Innovation Project II</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐">电子专业课程书籍课程资源推荐</h1>
<h2 id="来自邱金羽的推荐">——来自邱金羽的推荐</h2>
<h3 id="大一上学期-1">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td>课本讲的挺不错<br>入学前可以看一下 <span class="math inline">\(3Blue1Brown\)</span> 的数学频道，微积分对应为：《<a href="https://www.bilibili.com/video/BV1qW411N7FU">微积分的本质</a>》<br>国内常用教材为：《高等数学》<br>推荐一个写微积分比较好的知乎文章：《<a href="https://www.zhihu.com/column/c_1249046061567741952">Re:从零开始的数学世界生活</a>》，里面包括微积分、线性代数和概率论的知识</td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><span class="math inline">\(3Blue1Brown\)</span> 的数学频道：《<a href="https://www.bilibili.com/video/BV1ys411472E">线性代数的本质</a>》</td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td>无</td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td>工程学导论教学内容：Excal + Matlab + 编程基础 + CAD基础<br>Excal要求很低，会使用基本函数就行<br>Matlab很值得学习，主要包括基本的语法和绘图操作，建议跟着官网的教程学习：<a href="https://matlabacademy.mathworks.com/details/matlab-onramp/gettingstarted">Matlba Courses</a><br>Matlab学习中实现一些小项目可以帮助自己去理解，善用谷歌搜索和官网文档解决问题<br>对电子来说编程基础与编程导论课程内容重复<br>CAD基础，课时很少，简单了解</td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td>推荐网课：《<a href="https://www.bilibili.com/video/BV1Ls411w7rx?spm_id_from=..search-card.all.click">C语言程序设计</a>》<br>推荐书籍：《C Primer Plus 中文版》（这本书适合作为工具书使用，其中代码写的比较规范，适合跟着敲练习）<br> 《C Primer Plus 中文版》</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-1">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td>同上</td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td>大物二：声热光，相对没大物三的电磁重要</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>大物实验课比较水</td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td>Matlab绘图：如果大一学的好，现在应该不需要再学了<br>推荐一些博客：<br>《<a href="http://cighao.com/2016/04/11/draw-picture-with-matlab-001-line-style/">matlab 画图</a>》<br>《<a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4220232.html">MATLAB学习笔记</a>》</td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td>强烈推荐看完整个《电路》课本，里面很多知识很重要</td>
</tr>
<tr class="even">
<td>电路实验</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-1">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td>可以参考国内教材：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td>电磁部分比较难，需要认真学</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>比较水</td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td>强烈推荐使用此视频入门数据结构：<a href="https://www.bilibili.com/video/BV1Fv4y1f7T1">深入浅出数据结构 - 顶尖程序员图文讲解</a><br>课程较难，需要认真学习</td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td>可以使用此课程进行半导体器件的入门，比较生动：《<a href="https://www.bilibili.com/video/BV1qt411m7Vm">可汗学院-半导体器件</a>》<br>强烈推荐使用此课程进行学习《<a href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>与理论课不匹配</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-1">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td>强烈推荐使用此课程进行学习《<a href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>有一点匹配</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-1">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-1">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐-1">电子专业课程书籍课程资源推荐</h1>
<h2 id="推荐模板">——推荐模板</h2>
<h3 id="大一上学期-2">大一上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td></td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td></td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-2">大一下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td></td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电路实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-2">大二上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-2">大二下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-2">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-2">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>资料分享</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/30/16-02-06/</url>
    <content><![CDATA[<h1 id="微机原理实验报告">微机原理实验报告</h1>
<h2 id="课程实验1">课程实验1</h2>
<h3 id="stm32仿真开发环境的构建与简单汇编程序的编写">——STM32仿真开发环境的构建与简单汇编程序的编写</h3>
<h3 id="实验报告内容">实验报告内容</h3>
<ol type="1">
<li>实验目标与任务
<ol type="1">
<li>掌握MDK-ARM开发平台的使用，包括程序编写/调试/编译等。</li>
<li>掌握ARM的基本汇编指令，能够理解并编写简单的汇编程序实现某些功能。</li>
</ol></li>
<li>实验内容
<ol type="1">
<li>STM32F407启动代码实现与分析。</li>
<li>编写简单汇编程序：
<ol type="1">
<li>找到3个数字中最大的数字并将结果存储在R0中</li>
<li>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0.</li>
<li>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</li>
</ol></li>
</ol></li>
<li>实验步骤</li>
</ol>
<h3 id="实验报告">实验报告</h3>
<h4 id="mdk-arm开发平台的使用">MDK-ARM开发平台的使用</h4>
<h5 id="安装软件">安装软件</h5>
<p>使用到的软件：</p>
<ul>
<li><p>MDK-ARM（微控制器开发工具）</p></li>
<li><p>Protues（电子仿真工具）</p>
<p>MDK-ARM</p></li>
</ul>
<p>uVision是由keil公司开发的集成开发环境（IDE），可以进行代码编辑，文件管理，程序的编译调试等。</p>
<p>目前uVision的版本有uVision2、uVision3、uVision4、uVision5。</p>
<p>我们常说的keil4指的是uVision4，keil5指的是uVision5。</p>
<p>每一个uVision版本下都有4个独立的软件：C51、C251、C166、ARM。</p>
<p>uVision ARM就是MDK，或者可以称为MDK-ARM。这一款软件主要支持ARM7，ARM9，Cortex等ARM内核。</p>
<p>MDK-ARM中中包含PACK工具</p>
<p><img src="/2022/04/30/16-02-06/image-20220501135651588-16513846164571.png" alt="image-20220501135651588" style="zoom: 50%;"></p>
<p>PACK工具可以打开.pack文件，双击下载后文件夹中的 “Keil.STM32F4xx_DFP.2.14.0.pack” 文件，选择默认安装路径，即可完成导入。</p>
<h5 id="新建工程">新建工程</h5>
<p>打开 MDK-ARM，选择 Project -&gt; New uVision Project</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140158387-16513849197395.png" alt="image-20220501140158387" style="zoom:50%;"></p>
<p>选择工程存储路径，并给工程起一个名字。</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140436221-16513850782177.png" alt="image-20220501140436221" style="zoom:50%;"></p>
<p>在弹出的选项卡的搜索框中搜索 “STM32F407”，点击加号，选择具体型号 “STM32F407ZET”</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140958609.png" alt="image-20220501140958609" style="zoom:50%;"></p>
<p>STM32 微控制器命名规则如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141117834-16513854807739.png" alt="image-20220501141115297" style="zoom: 33%;"></p>
<p>为了导入启动程序，在新弹出的选项卡中做如下操作：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141406536-165138564869011.png" alt="image-20220501141406536" style="zoom:50%;"></p>
<p>即可得到启动程序</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141447804-165138568967813.png" alt="image-20220501141447804" style="zoom:50%;"></p>
<h5 id="编译程序">编译程序</h5>
<p>直接编译程序，会报错，如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141621369-165138578336915.png" alt="image-20220501141621369" style="zoom:50%;"></p>
<p>错误为，没有找到 <code>main()</code> 函数</p>
<p>因此，需要创建一个.c文件来补充 <code>main()</code> 函数：</p>
<p>首先创建一个新文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141803519-165138588563917.png" alt="image-20220501141803519" style="zoom:33%;"></p>
<p>保存文件为.c文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142026434.png" alt="image-20220501142026434" style="zoom:33%;"></p>
<p>将.c文件加入到工程文件：在 Source Group 1 文件夹上右键，选择 Add Existing Fiels to Group 'Source Group 1' ...</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142117084-165138607853919.png" alt="image-20220501142117084" style="zoom:33%;"></p>
<p>选项卡中选择文件并添加，然后点击 close 关闭</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142207067.png" alt="image-20220501142207067" style="zoom:33%;"></p>
<p>编译成功：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142435430-165138627702721.png" alt="image-20220501142435430" style="zoom:67%;"></p>
<h5 id="程序debug">程序Debug</h5>
<p>在没有器件的情况下无法直接对程序进行Debug，因此需要使用模拟器来仿真，需要进行一定的配置</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142555008-165138635699523.png" alt="image-20220501142555008" style="zoom:50%;"></p>
<p>配置方式在课本P91页：</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220501142851518-165138653354225.png" alt="image-20220501142851518"><figcaption aria-hidden="true">image-20220501142851518</figcaption>
</figure>
<p>具体操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DARMSTM.DLL</span><br><span class="line">-pSTM32F407ZETx</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220501143156502.png" alt="image-20220501143156502" style="zoom:50%;"></p>
<p>再次点击Debug即可进入Debug模式：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501143314055-165138679821227.png" alt="image-20220501143314055" style="zoom:50%;"></p>
<h4 id="stm32f407启动代码分析">STM32F407启动代码分析</h4>
<h5 id="整体分析">整体分析：</h5>
<p>对于STM32F407启动代码整体的一个描述在 startup_stm32fxxx_xx.s 文件的顶部注释中有着解释，内容如下：</p>
<blockquote>
<p>;* Description: STM32F407xx devices vector table for MDK-ARM toolchain. ;* This module performs: ;* - Set the initial SP ;* - Set the initial PC == Reset_Handler ;* - Set the vector table entries with the exceptions ISR address ;* - Branches to __main in the C library (which eventually calls main()). ;* After Reset the CortexM4 processor is in Thread mode, priority is Privileged, and the Stack is set to Main.</p>
</blockquote>
<p>含义为：</p>
<ul>
<li>设置堆栈指针 <code>SP = _initial_sp</code></li>
<li>设置程序寄存器 <code>PC = Reset_Handler</code></li>
<li>使用例外ISR设置向量表项</li>
<li>配置系统时钟</li>
<li>配置外部 SRAM 用亍程序变量等数据存储(可选)</li>
<li>调用C库中的 <code>__main()</code> 函数，最终调用 <code>main()</code> 函数</li>
</ul>
<h5 id="源代码解释">源代码解释：</h5>
<ol type="1">
<li><p>开辟栈 <em>(STACK)</em> 空间，用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。 <span class="math display">\[
\sf{通知编译器链接\rightarrow分配一片栈空间\rightarrow记录栈顶地址}
\]</span></p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EQU</code></td>
<td style="text-align: left;"><code>EQU</code>是一个伪指令，起作用是定义一个符号，这类似于C语言中的 <code>#define</code> ；<code>EQU</code>可以使用“*”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AREA</code></td>
<td style="text-align: left;">用于定义一个新的段（代码段或数据段），并说明段的相关属性。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SPACE</code></td>
<td style="text-align: left;">用于分配一定数量的内存空间并初始化为0；<code>SPACE</code>跟在<code>AREA</code>后面，用于给新定义的段分配合适大小的内存；SPACE后要跟随数字，指明初始化内存空间的大小；可以使用“%”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ALIGN</code></td>
<td style="text-align: left;">编译器指令，对指令或数据存放地址进行对齐（一般跟一个立即数，缺省为4字节）</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line">;定义一个符号，其中0x400为1KB；此处含义为设置栈空间大小为1KB</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">;新定义一个段名为STACK的段，不进行初始化，属性为可读，2^3=8字节对齐</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">;栈本体，这里指令是分配栈大小  </span><br><span class="line">__initial_sp</span><br><span class="line">;标号，表示该地址（这里是末尾，即栈顶地址）</span><br></pre></td></tr></table></figure></li>
<li><p>开辟堆（HEAP）空间，主要用于动态内存分配，也就是说用 <code>malloc()</code>, <code>calloc()</code>等函数分配的变量空间在堆上： <span class="math display">\[
\sf{通知编译器链接\rightarrow记录堆头地址\rightarrow分配一片堆空间\rightarrow记录堆尾地址}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br></pre></td></tr></table></figure></li>
<li><p>独立的过渡代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRESERVE8 ;指定当前文件的栈按 8B 对齐</span><br><span class="line">THUMB ;表示后面的指令兼容 Thumb 指令集（ARM以前的16位指令集）</span><br></pre></td></tr></table></figure>
<p>这里有一篇<a href="http://www.cnblogs.com/reload/archive/2013/06/27/3159053.html">文章</a>，详细解释了为什么要设置 <code>PRESERVE8</code>。</p></li>
<li><p>向量表：内核在异常时会访问这个表地址，并根据异常类型查表，按表跳转到异常处理函数执行。</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EXPORT</code></td>
<td style="text-align: left;">声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DCD</code></td>
<td style="text-align: left;">以字为单位分配内存，要求4字节对齐且初始化该内存<br><code>DCD</code> 的功能是申请（1个或多个）字地址，并赋初值。每行 <code>DCD</code> 都会生成一个4字节的二进制代码（中断服务代码入口地址）</td>
</tr>
</tbody>
</table>
<p>向量表的位置在代码段的最前面。具体物理地址由连接器的配置参数（IROM1 的地址决定, keil target 中可修改）。如果程序在 Flash 运行， 则中断向量表默认的起始地址是 <code>0x08000000</code>。</p>
<p><code>0x08000000</code> 是flash的首地址, 可以看到从 flash 的首地址开始，依次存储sp指针，Reset_Handler 中断地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">;新定义一个段名为RESRT的段，DATA说明本段用于定义数据段，属性为只读</span><br><span class="line"></span><br><span class="line">;下述语句将3个标号申明为可外部引用，主要提供给连接器用于链接库文件或其他文件。</span><br><span class="line"></span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">;定义一个标号 __Vectors 代表向量表的起始地址</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">;定义一个标号 __Vectors_End 代表向量表的结束地址</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">;定义一个标号 __Vectors_Size 代表向量表的地址长度</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。76-172行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">   </span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line">;向量表的地址长度 __Vectors_Size 可以由 __Vectors_End - __Vectors 得到</span><br></pre></td></tr></table></figure></li>
<li><p>各种中断处理程序 <code>xxx_Handler</code></p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>PROC</code></td>
<td>定义子程序，与<code>ENDP</code>成对使用，表示子程序结束 同义词 <code>FUNCTION</code></td>
</tr>
<tr class="even">
<td><code>WEAK</code></td>
<td>编译器特性。弱定义，优先使用外部文件定义的标号。<br><code>WEAK</code> 声明其它的同名标号优先于该标号被引用，就是说如果外面声明了同样的标号，会优先调用在外部定义的</td>
</tr>
<tr class="odd">
<td><code>EXPORT</code></td>
<td>声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td><code>IMPORT</code></td>
<td>声明标号来自外部文件，类似于C <code>extern</code></td>
</tr>
<tr class="odd">
<td><code>B</code></td>
<td>跳转到一个标号</td>
</tr>
</tbody>
</table>
<p>先指示编译器汇编一个新的代码段，名为 <code>|.text|</code>，只读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA    |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>
<p>除复位中断外的其它的函数默认跳转到中断后，在原地死循环。</p>
<p>复位程序，也就是默认上电复位后执行的程序</p>
<blockquote>
<p>B：后面跟一个标签，标签直接对应一个地址，B的作用是跳转的标签指示的地址 BX：后面跟一个寄存器，寄存器里面保存地址，BX的作用是跳转到寄存器里面存放的地址 BL：后面跟一个标签，BL跳转到标签指示的地址，并且保存下一条指令地址到R14（即链接寄存器P33） BLX：后面跟一个寄存器，寄存器里面保存地址，并且保存下一条指令地址到R14（即链接寄存器P33）</p>
<p><code>B &#123;条件&#125; 目标地址</code> 条件可选，立即跳转执行。（不返回程序），<code>B .</code> 是死循环while(1);的用法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">;利用PROC、ENDP这一对伪指令把程序分为若干个过程，使程序结构更加清晰</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">;WEAK这个声明很重要，它可以让我们在 C 文件中的任意地方，放置中断服务程序，只要保证 C 函数的名字和向量表中的名字一致即可</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>
<p>其他异常处理程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">;!此处省略大量相似语法的代码。200-232行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">;B &#123;条件&#125; 目标地址 条件可选，立即跳转执行。（不返回程序），B . 是死循环while(1);的用法</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">Default_Handler PROC</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">;!此处省略大量相似语法的代码。242-319行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。324-401行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>用户堆栈和堆初始化</p>
<ul>
<li>if
<ul>
<li>如果使用了微库（MicroLib），就直接导出堆栈地址符号</li>
</ul></li>
<li>else
<ul>
<li>导入外部程序<code>__use_two_region_memory</code>并马上执行调用</li>
<li>并导出子程序符号<code>__user_initial_stackheap</code>给外部程序调用</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;**********************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;**********************************************************************</span><br><span class="line">; 如果定义了 MICROLIB （微库，keil target 中设置），那么程序执行else后的语句</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line">;***************END OF FIEL***************</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="启动流程总结">启动流程总结</h5>
<ol type="1">
<li>分配堆栈</li>
<li>向量表</li>
<li>中断/异常处理函数
<ol type="1">
<li>复位程序（上电复位默认执行的函数）
<ol type="1">
<li>SystemInit()</li>
<li>__main()</li>
</ol></li>
<li>其他异常处理程序</li>
</ol></li>
<li>导出堆栈信息等给外部使用</li>
</ol>
<h5 id="stm32-总体启动顺序">STM32 总体启动顺序</h5>
<p><code>.s启动文件</code> -&gt; <code>中断处理函数外部定义</code> -&gt; <code>SystemInit()</code> -&gt; <code>SetSysClock</code> -&gt; <code>__main</code> -&gt; <code>main()</code></p>
<h5 id="全部代码展示">全部代码展示</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;******************** (C) COPYRIGHT 2017 STMicroelectronics ********************</span><br><span class="line">;* File Name          : startup_stm32f407xx.s</span><br><span class="line">;* Author             : MCD Application Team</span><br><span class="line">;* Description        : STM32F407xx devices vector table for MDK-ARM toolchain. </span><br><span class="line">;*                      This module performs:</span><br><span class="line">;*                      - Set the initial SP</span><br><span class="line">;*                      - Set the initial PC == Reset_Handler</span><br><span class="line">;*                      - Set the vector table entries with the exceptions ISR address</span><br><span class="line">;*                      - Branches to __main in the C library (which eventually</span><br><span class="line">;*                        calls main()).</span><br><span class="line">;*                      After Reset the CortexM4 processor is in Thread mode,</span><br><span class="line">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class="line">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class="line">;*******************************************************************************</span><br><span class="line">; </span><br><span class="line">;* Redistribution and use in source and binary forms, with or without modification,</span><br><span class="line">;* are permitted provided that the following conditions are met:</span><br><span class="line">;*   1. Redistributions of source code must retain the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer.</span><br><span class="line">;*   2. Redistributions in binary form must reproduce the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer in the documentation</span><br><span class="line">;*      and/or other materials provided with the distribution.</span><br><span class="line">;*   3. Neither the name of STMicroelectronics nor the names of its contributors</span><br><span class="line">;*      may be used to endorse or promote products derived from this software</span><br><span class="line">;*      without specific prior written permission.</span><br><span class="line">;*</span><br><span class="line">;* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span><br><span class="line">;* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span><br><span class="line">;* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span><br><span class="line">;* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span><br><span class="line">;* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span><br><span class="line">;* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><br><span class="line">;* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span><br><span class="line">;* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span><br><span class="line">;* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><br><span class="line">;* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line">; </span><br><span class="line">;*******************************************************************************</span><br><span class="line"></span><br><span class="line">; Amount of memory (in bytes) allocated for Stack</span><br><span class="line">; Tailor this value to your application needs</span><br><span class="line">; &lt;h&gt; Stack Configuration</span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;·</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog                                        </span><br><span class="line">                DCD     PVD_IRQHandler                    ; PVD through EXTI Line detection                        </span><br><span class="line">                DCD     TAMP_STAMP_IRQHandler             ; Tamper and TimeStamps through the EXTI line            </span><br><span class="line">                DCD     RTC_WKUP_IRQHandler               ; RTC Wakeup through the EXTI line                       </span><br><span class="line">                DCD     FLASH_IRQHandler                  ; FLASH                                           </span><br><span class="line">                DCD     RCC_IRQHandler                    ; RCC                                             </span><br><span class="line">                DCD     EXTI0_IRQHandler                  ; EXTI Line0                                             </span><br><span class="line">                DCD     EXTI1_IRQHandler                  ; EXTI Line1                                             </span><br><span class="line">                DCD     EXTI2_IRQHandler                  ; EXTI Line2                                             </span><br><span class="line">                DCD     EXTI3_IRQHandler                  ; EXTI Line3                                             </span><br><span class="line">                DCD     EXTI4_IRQHandler                  ; EXTI Line4                                             </span><br><span class="line">                DCD     DMA1_Stream0_IRQHandler           ; DMA1 Stream 0                                   </span><br><span class="line">                DCD     DMA1_Stream1_IRQHandler           ; DMA1 Stream 1                                   </span><br><span class="line">                DCD     DMA1_Stream2_IRQHandler           ; DMA1 Stream 2                                   </span><br><span class="line">                DCD     DMA1_Stream3_IRQHandler           ; DMA1 Stream 3                                   </span><br><span class="line">                DCD     DMA1_Stream4_IRQHandler           ; DMA1 Stream 4                                   </span><br><span class="line">                DCD     DMA1_Stream5_IRQHandler           ; DMA1 Stream 5                                   </span><br><span class="line">                DCD     DMA1_Stream6_IRQHandler           ; DMA1 Stream 6                                   </span><br><span class="line">                DCD     ADC_IRQHandler                    ; ADC1, ADC2 and ADC3s                            </span><br><span class="line">                DCD     CAN1_TX_IRQHandler                ; CAN1 TX                                                </span><br><span class="line">                DCD     CAN1_RX0_IRQHandler               ; CAN1 RX0                                               </span><br><span class="line">                DCD     CAN1_RX1_IRQHandler               ; CAN1 RX1                                               </span><br><span class="line">                DCD     CAN1_SCE_IRQHandler               ; CAN1 SCE                                               </span><br><span class="line">                DCD     EXTI9_5_IRQHandler                ; External Line[9:5]s                                    </span><br><span class="line">                DCD     TIM1_BRK_TIM9_IRQHandler          ; TIM1 Break and TIM9                   </span><br><span class="line">                DCD     TIM1_UP_TIM10_IRQHandler          ; TIM1 Update and TIM10                 </span><br><span class="line">                DCD     TIM1_TRG_COM_TIM11_IRQHandler     ; TIM1 Trigger and Commutation and TIM11</span><br><span class="line">                DCD     TIM1_CC_IRQHandler                ; TIM1 Capture Compare                                   </span><br><span class="line">                DCD     TIM2_IRQHandler                   ; TIM2                                            </span><br><span class="line">                DCD     TIM3_IRQHandler                   ; TIM3                                            </span><br><span class="line">                DCD     TIM4_IRQHandler                   ; TIM4                                            </span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; I2C1 Event                                             </span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; I2C1 Error                                             </span><br><span class="line">                DCD     I2C2_EV_IRQHandler                ; I2C2 Event                                             </span><br><span class="line">                DCD     I2C2_ER_IRQHandler                ; I2C2 Error                                               </span><br><span class="line">                DCD     SPI1_IRQHandler                   ; SPI1                                            </span><br><span class="line">                DCD     SPI2_IRQHandler                   ; SPI2                                            </span><br><span class="line">                DCD     USART1_IRQHandler                 ; USART1                                          </span><br><span class="line">                DCD     USART2_IRQHandler                 ; USART2                                          </span><br><span class="line">                DCD     USART3_IRQHandler                 ; USART3                                          </span><br><span class="line">                DCD     EXTI15_10_IRQHandler              ; External Line[15:10]s                                  </span><br><span class="line">                DCD     RTC_Alarm_IRQHandler              ; RTC Alarm (A and B) through EXTI Line                  </span><br><span class="line">                DCD     OTG_FS_WKUP_IRQHandler            ; USB OTG FS Wakeup through EXTI line                        </span><br><span class="line">                DCD     TIM8_BRK_TIM12_IRQHandler         ; TIM8 Break and TIM12                  </span><br><span class="line">                DCD     TIM8_UP_TIM13_IRQHandler          ; TIM8 Update and TIM13                 </span><br><span class="line">                DCD     TIM8_TRG_COM_TIM14_IRQHandler     ; TIM8 Trigger and Commutation and TIM14</span><br><span class="line">                DCD     TIM8_CC_IRQHandler                ; TIM8 Capture Compare                                   </span><br><span class="line">                DCD     DMA1_Stream7_IRQHandler           ; DMA1 Stream7                                           </span><br><span class="line">                DCD     FMC_IRQHandler                    ; FMC                                             </span><br><span class="line">                DCD     SDIO_IRQHandler                   ; SDIO                                            </span><br><span class="line">                DCD     TIM5_IRQHandler                   ; TIM5                                            </span><br><span class="line">                DCD     SPI3_IRQHandler                   ; SPI3                                            </span><br><span class="line">                DCD     UART4_IRQHandler                  ; UART4                                           </span><br><span class="line">                DCD     UART5_IRQHandler                  ; UART5                                           </span><br><span class="line">                DCD     TIM6_DAC_IRQHandler               ; TIM6 and DAC1&amp;2 underrun errors                   </span><br><span class="line">                DCD     TIM7_IRQHandler                   ; TIM7                   </span><br><span class="line">                DCD     DMA2_Stream0_IRQHandler           ; DMA2 Stream 0                                   </span><br><span class="line">                DCD     DMA2_Stream1_IRQHandler           ; DMA2 Stream 1                                   </span><br><span class="line">                DCD     DMA2_Stream2_IRQHandler           ; DMA2 Stream 2                                   </span><br><span class="line">                DCD     DMA2_Stream3_IRQHandler           ; DMA2 Stream 3                                   </span><br><span class="line">                DCD     DMA2_Stream4_IRQHandler           ; DMA2 Stream 4                                   </span><br><span class="line">                DCD     ETH_IRQHandler                    ; Ethernet                                        </span><br><span class="line">                DCD     ETH_WKUP_IRQHandler               ; Ethernet Wakeup through EXTI line                      </span><br><span class="line">                DCD     CAN2_TX_IRQHandler                ; CAN2 TX                                                </span><br><span class="line">                DCD     CAN2_RX0_IRQHandler               ; CAN2 RX0                                               </span><br><span class="line">                DCD     CAN2_RX1_IRQHandler               ; CAN2 RX1                                               </span><br><span class="line">                DCD     CAN2_SCE_IRQHandler               ; CAN2 SCE                                               </span><br><span class="line">                DCD     OTG_FS_IRQHandler                 ; USB OTG FS                                      </span><br><span class="line">                DCD     DMA2_Stream5_IRQHandler           ; DMA2 Stream 5                                   </span><br><span class="line">                DCD     DMA2_Stream6_IRQHandler           ; DMA2 Stream 6                                   </span><br><span class="line">                DCD     DMA2_Stream7_IRQHandler           ; DMA2 Stream 7                                   </span><br><span class="line">                DCD     USART6_IRQHandler                 ; USART6                                           </span><br><span class="line">                DCD     I2C3_EV_IRQHandler                ; I2C3 event                                             </span><br><span class="line">                DCD     I2C3_ER_IRQHandler                ; I2C3 error                                             </span><br><span class="line">                DCD     OTG_HS_EP1_OUT_IRQHandler         ; USB OTG HS End Point 1 Out                      </span><br><span class="line">                DCD     OTG_HS_EP1_IN_IRQHandler          ; USB OTG HS End Point 1 In                       </span><br><span class="line">                DCD     OTG_HS_WKUP_IRQHandler            ; USB OTG HS Wakeup through EXTI                         </span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                                      </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI  </span><br><span class="line">                DCD     0                                 ; Reserved				                              </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line"></span><br><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler  PROC</span><br><span class="line">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line"></span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler             [WEAK]         </span><br><span class="line">                EXPORT  RTC_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  FLASH_IRQHandler                  [WEAK]                                         </span><br><span class="line">                EXPORT  RCC_IRQHandler                    [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI0_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI1_IRQHandler                  [WEAK]                                             </span><br><span class="line">                EXPORT  EXTI2_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI3_IRQHandler                  [WEAK]                                           </span><br><span class="line">                EXPORT  EXTI4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  DMA1_Stream0_IRQHandler           [WEAK]                                </span><br><span class="line">                EXPORT  DMA1_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream2_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream3_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream4_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  ADC_IRQHandler                    [WEAK]                         </span><br><span class="line">                EXPORT  CAN1_TX_IRQHandler                [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN1_RX1_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_SCE_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  EXTI9_5_IRQHandler                [WEAK]                                    </span><br><span class="line">                EXPORT  TIM1_BRK_TIM9_IRQHandler          [WEAK]                  </span><br><span class="line">                EXPORT  TIM1_UP_TIM10_IRQHandler          [WEAK]                </span><br><span class="line">                EXPORT  TIM1_TRG_COM_TIM11_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM1_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  TIM2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM3_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM4_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C2_EV_IRQHandler                [WEAK]                                            </span><br><span class="line">                EXPORT  I2C2_ER_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  SPI1_IRQHandler                   [WEAK]                                           </span><br><span class="line">                EXPORT  SPI2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  USART1_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART2_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART3_IRQHandler                 [WEAK]                                         </span><br><span class="line">                EXPORT  EXTI15_10_IRQHandler              [WEAK]                                  </span><br><span class="line">                EXPORT  RTC_Alarm_IRQHandler              [WEAK]                  </span><br><span class="line">                EXPORT  OTG_FS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  TIM8_BRK_TIM12_IRQHandler         [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_UP_TIM13_IRQHandler          [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_TRG_COM_TIM14_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM8_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream7_IRQHandler           [WEAK]                                          </span><br><span class="line">                EXPORT  FMC_IRQHandler                    [WEAK]                                             </span><br><span class="line">                EXPORT  SDIO_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  TIM5_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  SPI3_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  UART4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  UART5_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  TIM6_DAC_IRQHandler               [WEAK]                   </span><br><span class="line">                EXPORT  TIM7_IRQHandler                   [WEAK]                    </span><br><span class="line">                EXPORT  DMA2_Stream0_IRQHandler           [WEAK]                                  </span><br><span class="line">                EXPORT  DMA2_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream2_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream3_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream4_IRQHandler           [WEAK]                                 </span><br><span class="line">                EXPORT  ETH_IRQHandler                    [WEAK]                                         </span><br><span class="line">                EXPORT  ETH_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  CAN2_TX_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX1_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_SCE_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  OTG_FS_IRQHandler                 [WEAK]                                       </span><br><span class="line">                EXPORT  DMA2_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream7_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  USART6_IRQHandler                 [WEAK]                                           </span><br><span class="line">                EXPORT  I2C3_EV_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  I2C3_ER_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  OTG_HS_EP1_OUT_IRQHandler         [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_EP1_IN_IRQHandler          [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  OTG_HS_IRQHandler                 [WEAK]                                      </span><br><span class="line">                EXPORT  DCMI_IRQHandler                   [WEAK]                                                                                 </span><br><span class="line">                EXPORT  HASH_RNG_IRQHandler               [WEAK]</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">                </span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line">TAMP_STAMP_IRQHandler                  </span><br><span class="line">RTC_WKUP_IRQHandler                                </span><br><span class="line">FLASH_IRQHandler                                                       </span><br><span class="line">RCC_IRQHandler                                                            </span><br><span class="line">EXTI0_IRQHandler                                                          </span><br><span class="line">EXTI1_IRQHandler                                                           </span><br><span class="line">EXTI2_IRQHandler                                                          </span><br><span class="line">EXTI3_IRQHandler                                                         </span><br><span class="line">EXTI4_IRQHandler                                                          </span><br><span class="line">DMA1_Stream0_IRQHandler                                       </span><br><span class="line">DMA1_Stream1_IRQHandler                                          </span><br><span class="line">DMA1_Stream2_IRQHandler                                          </span><br><span class="line">DMA1_Stream3_IRQHandler                                          </span><br><span class="line">DMA1_Stream4_IRQHandler                                          </span><br><span class="line">DMA1_Stream5_IRQHandler                                          </span><br><span class="line">DMA1_Stream6_IRQHandler                                          </span><br><span class="line">ADC_IRQHandler                                         </span><br><span class="line">CAN1_TX_IRQHandler                                                            </span><br><span class="line">CAN1_RX0_IRQHandler                                                          </span><br><span class="line">CAN1_RX1_IRQHandler                                                           </span><br><span class="line">CAN1_SCE_IRQHandler                                                           </span><br><span class="line">EXTI9_5_IRQHandler                                                </span><br><span class="line">TIM1_BRK_TIM9_IRQHandler                        </span><br><span class="line">TIM1_UP_TIM10_IRQHandler                      </span><br><span class="line">TIM1_TRG_COM_TIM11_IRQHandler  </span><br><span class="line">TIM1_CC_IRQHandler                                               </span><br><span class="line">TIM2_IRQHandler                                                           </span><br><span class="line">TIM3_IRQHandler                                                           </span><br><span class="line">TIM4_IRQHandler                                                           </span><br><span class="line">I2C1_EV_IRQHandler                                                         </span><br><span class="line">I2C1_ER_IRQHandler                                                         </span><br><span class="line">I2C2_EV_IRQHandler                                                        </span><br><span class="line">I2C2_ER_IRQHandler                                                           </span><br><span class="line">SPI1_IRQHandler                                                          </span><br><span class="line">SPI2_IRQHandler                                                           </span><br><span class="line">USART1_IRQHandler                                                       </span><br><span class="line">USART2_IRQHandler                                                       </span><br><span class="line">USART3_IRQHandler                                                      </span><br><span class="line">EXTI15_10_IRQHandler                                            </span><br><span class="line">RTC_Alarm_IRQHandler                            </span><br><span class="line">OTG_FS_WKUP_IRQHandler                                </span><br><span class="line">TIM8_BRK_TIM12_IRQHandler                      </span><br><span class="line">TIM8_UP_TIM13_IRQHandler                       </span><br><span class="line">TIM8_TRG_COM_TIM14_IRQHandler  </span><br><span class="line">TIM8_CC_IRQHandler                                               </span><br><span class="line">DMA1_Stream7_IRQHandler                                                 </span><br><span class="line">FMC_IRQHandler                                                            </span><br><span class="line">SDIO_IRQHandler                                                            </span><br><span class="line">TIM5_IRQHandler                                                            </span><br><span class="line">SPI3_IRQHandler                                                            </span><br><span class="line">UART4_IRQHandler                                                          </span><br><span class="line">UART5_IRQHandler                                                          </span><br><span class="line">TIM6_DAC_IRQHandler                            </span><br><span class="line">TIM7_IRQHandler                              </span><br><span class="line">DMA2_Stream0_IRQHandler                                         </span><br><span class="line">DMA2_Stream1_IRQHandler                                          </span><br><span class="line">DMA2_Stream2_IRQHandler                                           </span><br><span class="line">DMA2_Stream3_IRQHandler                                           </span><br><span class="line">DMA2_Stream4_IRQHandler                                        </span><br><span class="line">ETH_IRQHandler                                                         </span><br><span class="line">ETH_WKUP_IRQHandler                                </span><br><span class="line">CAN2_TX_IRQHandler                                                           </span><br><span class="line">CAN2_RX0_IRQHandler                                                          </span><br><span class="line">CAN2_RX1_IRQHandler                                                          </span><br><span class="line">CAN2_SCE_IRQHandler                                                          </span><br><span class="line">OTG_FS_IRQHandler                                                    </span><br><span class="line">DMA2_Stream5_IRQHandler                                          </span><br><span class="line">DMA2_Stream6_IRQHandler                                          </span><br><span class="line">DMA2_Stream7_IRQHandler                                          </span><br><span class="line">USART6_IRQHandler                                                        </span><br><span class="line">I2C3_EV_IRQHandler                                                          </span><br><span class="line">I2C3_ER_IRQHandler                                                          </span><br><span class="line">OTG_HS_EP1_OUT_IRQHandler                           </span><br><span class="line">OTG_HS_EP1_IN_IRQHandler                            </span><br><span class="line">OTG_HS_WKUP_IRQHandler                                </span><br><span class="line">OTG_HS_IRQHandler                                                   </span><br><span class="line">DCMI_IRQHandler                                                                                                             </span><br><span class="line">HASH_RNG_IRQHandler</span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">           </span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line"></span><br><span class="line">;************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单汇编程序实现">简单汇编程序实现</h3>
<h4 id="三数中寻找最大数">三数中寻找最大数</h4>
<h5 id="题目要求">题目要求：</h5>
<p>找到3个数字中最大的数字并将结果存储在R0中。</p>
<h5 id="代码展示">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Rebuild started: Project: Project_1</span><br><span class="line">*** Using Compiler &#x27;V6.16&#x27;, folder: &#x27;D:\MDK\ARM\ARMCLANG\Bin&#x27;</span><br><span class="line">Rebuild target &#x27;Target 1&#x27;</span><br><span class="line">assembling startup_stm32f407xx.s...</span><br><span class="line">compiling system_stm32f4xx.c...</span><br><span class="line">linking...</span><br><span class="line">.\Objects\Project_1.axf: Error: L6320W: Ignoring --entry command. Cannot find argument &#x27;Reset_Handler&#x27;.</span><br><span class="line">.\Objects\Project_1.axf: Warning: L6320W: Ignoring --first command. Cannot find argument &#x27;__Vectors&#x27;.</span><br><span class="line">Not enough information to list image symbols.</span><br><span class="line">Not enough information to list load addresses in the image map.</span><br><span class="line">Finished: 2 information, 1 warning and 1 error messages.</span><br><span class="line">&quot;.\Objects\Project_1.axf&quot; - 1 Error(s), 1 Warning(s).</span><br><span class="line">Target not created.</span><br><span class="line">Build Time Elapsed:  00:00:00</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231919016-165185037825611.png" alt="image-20220506231919016" style="zoom:50%;"></p>
<p>课本代码会报错，因此修正代码课本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">					</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231830620-16518503124549.png" alt="image-20220506231830620" style="zoom:50%;"></p>
<h5 id="结果展示">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506232317154-165185059873513.png" alt="image-20220506232317154" style="zoom:50%;"></p>
<h4 id="n个数相加">N个数相加</h4>
<h5 id="题目要求-1">题目要求：</h5>
<p>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0。</p>
<h5 id="代码展示-1">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N				EQU		10</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">				</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		</span><br><span class="line">		LDR		R0,	=N</span><br><span class="line">		MOV		R1,	#0</span><br><span class="line">loop</span><br><span class="line">		ADD		r1, r0</span><br><span class="line">		SUBS	r0,	#1</span><br><span class="line">		BNE		loop</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-1">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506213516914-16518441195105.png" alt="image-20220506213516914" style="zoom:50%;"></p>
<h4 id="十六进制转asic码">十六进制转ASIC码</h4>
<h5 id="题目要求-2">题目要求：</h5>
<p>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</p>
<h5 id="代码实现">代码实现：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		MOV 	R3,0x0A</span><br><span class="line">		CMP		R3,#9</span><br><span class="line">		BLE		Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-2">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506212809459.png" alt="image-20220506212809459" style="zoom:50%;"></p>
<p><img src="/2022/04/30/16-02-06/image-20220506213109858-16518438733371-16518438752213.png" alt="image-20220506213109858" style="zoom:50%;"></p>
<h2 id="课程实验2">课程实验2</h2>
<h3 id="使用stm32f401ve控制led">——使用STM32F401VE控制LED</h3>
<h3 id="实验报告内容-1">实验报告内容</h3>
<ol type="1">
<li><p>实验目标与任务</p>
<ol type="1">
<li>掌握STM32F40x的GPIO输入输出的使用。</li>
<li>主寄存器方法，库函数方法设置GPIO。</li>
<li>了解如何使用STM32CubeMX构建初始代码。</li>
</ol></li>
<li><p>实验内容</p>
<ol type="1">
<li><p>开关控制LED灯。当按下按钮时，对应的LED灯亮500ms，然后熄灭。</p>
<p><img src="/2022/04/30/16-02-06/image-20220507073550593-16518801528251.png" alt="image-20220507073550593" style="zoom:50%;"></p></li>
<li><p>要求:需要详细的步骤，包括proteus仿真电路和程序。</p></li>
</ol></li>
<li><p>实验步骤</p></li>
</ol>
<h3 id="实验报告-1">实验报告</h3>
<p>1000 0001 1110 0101 1010 0100 1000 1010</p>
<p>100 1101 0010</p>
<p>1001 1010 0100 1010</p>
<p>我现在参考的一本讲解arm体系结构的书，上面介绍了一些机器码的知识，但是我看书上是这样写的<img src="/2022/04/30/16-02-06/image-20220507113552993.png" alt="image-20220507113552993"></p>
<p>但是我在编译的时候出现的是这样的</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220507113625448.png" alt="image-20220507113625448"><figcaption aria-hidden="true">image-20220507113625448</figcaption>
</figure>
<p>我猜测可能是使用的指令集不同，可能书上使用的是ARM指令集，但是因为我在代码中有写THUMB，所以我应该使用的是Thumb指令集，但是Thumb指令集是16位的，这个MOV...指令是32位的，所以我猜测是Thumb指令集，但是我去网上搜不到相关的信息，我现在比较困惑这个MOV对应的二进制数不同是因为指令集的原因呢还是汇编编译器的原因呢？</p>
]]></content>
  </entry>
</search>
