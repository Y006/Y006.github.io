<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VScode配置笔记</title>
    <url>/2022/02/20/22-32-35/</url>
    <content><![CDATA[<h2 id="vscode配置笔记">VScode配置笔记</h2>
<ol type="1">
<li><p>下载并安装编译器MinGW：https://bit.ly/mingw10</p></li>
<li><p>将MinGW的bin文件路径添加到系统环境变量中</p></li>
<li><p>在cmd中运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br></pre></td></tr></table></figure>
<p>检测是否成功配置路径</p></li>
<li><p>安装VScode：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p></li>
<li><p>“设置”中输入"run in terminal"<img src="/2022/02/20/22-32-35/image-20210907225325312.png" alt="image-20210907225325312"></p></li>
<li><p>安装插件”Code Runner“和”C/C++“；选装”Chinese (Simplified) Language Pack for Visual Studio Code“</p></li>
<li><p>为了正确地在文本编辑器上敲除中文，需要给文本编辑器设置合适的编码方式：<img src="/2022/02/20/22-32-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20210916093752004.png" alt="image-20210916093752004"></p>
<p>点红框，选择“通过编码重新打开”，输入编码方式即可。</p>
<p>打开cmd，查看“属性”可得知终端的编码方式</p>
<p><img src="/2022/02/20/22-32-35/image-20210916093952277.png" alt="image-20210916093952277" style="zoom:25%;"></p>
<p>终端的编码方式需要与编辑器的编码方式匹配</p>
<p>在终端输入：“chcp 65001”可以切换代码页到使用UTF8。</p></li>
<li><p>想要正确识别别人代码中的中文，需要“设置”中输入"<strong>files.autoGuessEncoding</strong>"<img src="/2022/02/20/22-32-35/image-20210907225635399.png" alt="image-20210907225635399"></p></li>
<li><p>设置自动保存：“设置“中输入”<strong>auto save</strong>“，选择"afterDelay"选项</p></li>
<li><p>設置自動格式化：“设置”中输入“<strong>editor.formatOnType</strong>”，选择True“</p></li>
<li><p>”ctrl+k“配合”ctrl+t“可快速切换主题</p></li>
<li><p>”ctrl+“是放大</p></li>
<li><p>单行注释：“Ctrl + /”；块注释：“Alt+Shift+A”</p></li>
<li><p>多文件编译：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#code in CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output in Chinese</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -fexec-charset=GB2312&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="补充终端shell命令">补充：终端（shell）命令</h2>
<p>不区分大小写。</p>
<p>tab键补全内容，再次点击切换内容</p>
<h3 id="文件跳转">文件跳转</h3>
<p>磁盘跳转</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:</span></span><br></pre></td></tr></table></figure>
<p>显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
<p>树形显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>
<p>进入下一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件名（有空格的夹引号，平时使用tab补全就好）</span><br></pre></td></tr></table></figure>
<p>进入上一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd..</span><br></pre></td></tr></table></figure>
<p>退回磁盘根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Homework</title>
    <url>/2022/02/24/11-07-35/</url>
    <content><![CDATA[<h2 id="homework">Homework</h2>
<h3 id="home-work">1-Home work</h3>
<p>1.d 2.c 3.a 4.a</p>
<h3 id="home-work-1">2-Home work</h3>
<p>1.b 2.c</p>
<ol start="3" type="1">
<li>Differentiate between insulator, semiconductor and conductor?
<ul>
<li>Insulator : Don't allow the current to pass through.</li>
<li>Semiconductor : have a conductivity between conductors and insulators.</li>
<li>Condctior : Allow the current and heat to pass through.</li>
</ul></li>
<li>What is forbidden energy gap?
<ul>
<li>The bandgap btewenn conduction band and valence band is called forbidden energy gap.</li>
</ul></li>
<li>How does the band gap indicate whether or not your substance is an insulator, semiconductor or conductor?
<ul>
<li>The bandgap of the insulator is very high;</li>
<li>The bandgap of the semiconductor is low;</li>
<li>There is no band gap in the conductor</li>
</ul></li>
</ol>
<h3 id="home-work-2">3-Home work</h3>
<ol type="1">
<li><p>Define doping?</p>
<ul>
<li>The process by which an impurity is added to a semiconductor is known as Doping.</li>
</ul></li>
<li><p>What is difference between a pentavalent atom and a trivalent impurity?</p>
<ul>
<li>They have different numbers of outermost electrons.</li>
<li>Pentavalent atoms have 5 valence electrons; Trivalent atoms have 3 valence electrons.</li>
</ul></li>
<li><p>How is an n-type semiconductor formed? Is N-type material electrically neutral? Comment.</p>
<ul>
<li>N-type semiconductors are formed by adding pentavalent impurity.</li>
<li>N-type material is electrically neutral.</li>
</ul></li>
<li><p>How is an p-type semiconductor formed?</p>
<ul>
<li>N-type semiconductors are formed by adding trivalent impurity.</li>
</ul></li>
<li><p>What is difference between intrinsic and extrinsic semiconductor?</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
</ul></li>
<li><p>c</p></li>
</ol>
<h3 id="home-work-3">4-Home work</h3>
<ol type="1">
<li>Calculate.</li>
<li>Calculate.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-4">5-Home work</h3>
<ol type="1">
<li><p>Calculate.</p></li>
<li><p>Describe the Avalanche and Zener breakdown mechanism in diode.</p>
<ul>
<li><p>Avalanche breakdown:</p>
<p>If high reverse bias voltage is applied to a lightly doped diode, then the minority carriers will move to the PN junction with high velocity and collide with atoms in the depletion region and break the covalent bond.This cumulative process eventually leads current increase suddenly in the device. The phenomena is called avalanche breakdown.</p></li>
<li><p>Zener breakdown:</p>
<p>The depletion width in heavily doped diodes is very narrow, which develops high electric field across the depletion region under reverse voltage. In this case, the covalent bond is disrupted in the depletion region and more and more electrons are liberated. So the current increases repidly in the diode. The phenomena is called Zener breakdown.</p>
<p>The depletion widthe is very narrow in heavily doped diodes, resulting in a large electric field in the depletion region when reverse voltage is applied</p></li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Differentiate between Zener diode and PN junction normal diode. Also, explain how Zener breakdown differs from Avalanche breakdown.</p>
<ul>
<li><p>Compared with ordinary diodes, Zener diodes are heavily doped diodes, and Zener diodes work in the state of reverse breakdown.</p></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>lightly doped.</li>
<li>Depletion width is wide.</li>
<li>Electric field is weaker in the depletion region as compared to Zener breakdown.</li>
<li>Breakdown voltage is more than 8 V.</li>
<li>Avalanche breakdown occurs due to collision of electron with atoms in the depletion region.</li>
</ol></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>highly doped.</li>
<li>Depletion width is thin.</li>
<li>Electric field is stronger in the depletion region as compared to Avalanche breakdown.</li>
<li>Breakdown voltage is between 5V to 8V.</li>
<li>Zener breakdown occurs Due to rupture of covalent bond in the depletion region since electric field is very strong.</li>
</ol></li>
</ul></li>
</ol>
<h3 id="home-work-5">6-Home work</h3>
<ol type="1">
<li>Draw:
<ul>
<li><span class="math inline">\(AC \Rightarrow Transform \Rightarrow Rectifier \Rightarrow Filter \Rightarrow Regulator \Rightarrow DC\)</span></li>
</ul></li>
<li>Explain the basic circuit operation of half wave rectifier.
<ul>
<li>In half wave rectifier circuit, when the AC voltage is positive, the diode is forward biased so the current will pass through the circuit. when the AC voltage is negatve, the diode is reverse biased and the current can't pass through the circuit. Hence only positive half of the signal can pass through the circuit and the other half is zero.</li>
</ul></li>
<li>Calcution.</li>
</ol>
<h3 id="home-work-6">7-Home work</h3>
<ol type="1">
<li>Why half-wave rectifiers are generally not used in dc power supply？
<ul>
<li>Its efficiency is low and its ripple factor is high.</li>
</ul></li>
<li>Define ripple in a rectifier circuit.
<ul>
<li>The AC harmonics in DC are called ripple. And we have full wave rectifier as an substitute.</li>
</ul></li>
<li>Calculate.</li>
<li>Draw.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-7">8-Home work</h3>
<ol type="1">
<li>What are the bias voltage that need to be applied to an NPN transistor such that the transistor is biased in the forward active mode？
<ul>
<li>The input voltage should exceed cut-in voltage and make transisitor biased in the forward active region.</li>
</ul></li>
<li>What is the necessity of biasing a transistor circuit.State different types.
<ul>
<li>To achieve faithful amplification, the input voltage should exceed cut-in voltage and the transistor should be in the active region, so we need biasing to set the operating point.</li>
<li>Fixed bias, Emitter bias, collector feedback bias and voltage divider bias.</li>
</ul></li>
<li>Define common base,common emitter and common current gain.
<ul>
<li>Equation.</li>
</ul></li>
<li>Define the Parameters that define a load line.define Q-point and it's significance in details. （i）Q-point region near cut off point （ii）Q-point near saturation region （iii）Q-point in the middle of the load line
<ul>
<li>The load line is jointly determined by Vcc and Rc, and the Q point is at the midpoint of the load line</li>
<li>if the Q point is close to the saturation area or the cut-off area, the output signal will be clipped</li>
<li>and if it is in the amplification area, a stable waveform can be output</li>
</ul></li>
<li>Mention the parameters that can cause shift in Q point in transistor circuit.
<ul>
<li><span class="math inline">\(I_B\)</span> and <span class="math inline">\(R_C\)</span></li>
</ul></li>
<li>Define Thermal Runaway in transistor and how to mitigate
<ul>
<li>Negative feedback and heat sink.</li>
</ul></li>
</ol>
<h2 id="assignment">Assignment</h2>
<ol type="1">
<li><p>Define intrinsic and extrinsic semiconductor. Also describe need of trivalent and pentavalent imurities in semiconductor.</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
<li>N-type semiconductors are formed by adding pentavalent imurities and P-type semiconductors are formed by adding trivalent imurities.</li>
</ul></li>
<li><p>Explain P-N junction under no-bias, forward bias and reverse bias conditions.</p>
<ul>
<li>The concentration gradient lets the PN junction forms a diffusion current, resulting in a built-in electric field. When the built-in electric field and the concentration gradient reach equilibrium, the diffusion stops and a depletion layer is formed.</li>
<li>When the PN junction is forward biased, the depletion width reduce and the balance between the built-in electric field and the concentration gradient is destroyed. The diffusion current continues to flow from the N-side to the P-side.</li>
<li>When the PN junction is reverse biased, the depletion width increase and diffusion current is further suppressed. Only drift current exists when reverse biased.</li>
</ul></li>
<li><p>Define Knee voltage, reverse saturation current and Breakdown voltage.</p>
<ul>
<li>Knee voltage: The forword bias voltage at which current increase through diode rapidly.</li>
<li>Reverse saturation current: Current due to minority carrier drift during reverse bias.</li>
<li>Breakdown voltage: The reverse bias voltage at which current increase through diode rapidly.</li>
</ul></li>
<li><p>Explain the basic concept of mass-action law in semiconductor and <strong>Calculate</strong>.</p>
<ul>
<li>The product of electron and hole concentrations in thermal equilibrium is equal to the square of the intrinsic carrier concentration</li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Describe the current flow mechanism in NPN transistor. Also compare the input and output characteristics of C-B,C-E and C-C.</p>
<ul>
<li><p>Transistor is used as an amplofying device when EB is forward biased and CB is reverse biased. When EB is forward biased, the electrons move from E into C through B, which formed the emitter current. The hole move from B into E and the hole move from wire into the B formed the base current. The electrons move form E into the C and the reverse current due to the reverse bias of CB formed the collector current.</p></li>
<li><table>
<thead>
<tr class="header">
<th></th>
<th>CB</th>
<th>CC</th>
<th>CE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入电阻</td>
<td>minimum</td>
<td>maximum</td>
<td>medium</td>
</tr>
<tr class="even">
<td>输出电阻</td>
<td>same to CE</td>
<td>minimum</td>
<td>same to CB</td>
</tr>
<tr class="odd">
<td>放大情况</td>
<td>only amplified voltage</td>
<td>only amplified current</td>
<td>both</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>What is the necessity of biasing in a transistor. State different types biasing in detail.</p>
<ul>
<li>Find operating points for faithful amplification.</li>
<li>Fixed bias:
<ul>
<li>include R_B, R_C and V_{CC}, simple but unstable.</li>
</ul></li>
<li>Emitter bias:
<ul>
<li>Introduce an additional R_E and makes it more stable.</li>
</ul></li>
<li>Voltage divider bias:
<ul>
<li>A voltage divider resistor is used for a more stable effect.</li>
</ul></li>
</ul></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><ol type="a">
<li>Explain the basic construction, operation and characteristics of N-channel JFET. Also explain the input and output transfer characteristics. If we apply positive VGS to the JFET what will happen with the device?</li>
<li>Draw.</li>
</ol>
<ul>
<li>The main body of an n-channel JFET is an N-type semiconductor, and P-type semiconductors are embedded on both sides to form an n-channel. The top of the N-channel is the drain, the bottom is the source, and the left and right P-type semiconductors are connected to the gate.</li>
<li>The gate controls the voltage across this drain and source</li>
<li>The most important feature is the high input impedance</li>
</ul></li>
<li><p>Compare BJT and JFET.</p>
<ul>
<li><table>
<thead>
<tr class="header">
<th>比较内容</th>
<th>BJT</th>
<th>JFET</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>construction</td>
<td>NPN &amp; PNP</td>
<td>N-channal &amp; P-channal</td>
</tr>
<tr class="even">
<td>current carrier</td>
<td>majorities diffusion<br>minorities drift</td>
<td>majorities diffusion</td>
</tr>
<tr class="odd">
<td>Input</td>
<td>current</td>
<td>voltage</td>
</tr>
<tr class="even">
<td>contralled virable</td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(g_m\)</span></td>
</tr>
<tr class="odd">
<td>sensitivity to the temperature</td>
<td>high</td>
<td>low</td>
</tr>
<tr class="even">
<td>stability</td>
<td>bad</td>
<td>good</td>
</tr>
<tr class="odd">
<td>input resistance</td>
<td>small</td>
<td>large</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><ol type="a">
<li>Describe the operation and charcteristics of the inverting and Non-inverting amplifier.</li>
<li>Draw.</li>
</ol>
<ul>
<li>The amplifier which has 180 degrees out of phase output with respect to input is known as an inverted amplifier,</li>
<li>whereas the amplifier which has the o/p in phase with respect to i/p is known as a non-inverting amplifier.</li>
</ul></li>
<li><p>What is the concept of virtual ground?</p>
<ul>
<li>A node of a circuit that is maintained at a steady reference potential, without being connected directly to the reference potential.</li>
</ul></li>
</ol>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/11/16-23-37/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>信号与系统</title>
    <url>/2022/02/27/16-42-18/</url>
    <content><![CDATA[<h2 id="x信号">x信号</h2>
<h3 id="常见的奇异信号">常见的奇异信号</h3>
<p>奇异信号：函数中包含不连续点或其微分与积分有不连续点的函数，统称为奇异函数，也就是奇异信号。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>函数表达式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f(t)\)</span>：单位斜变信号</td>
<td><span class="math inline">\(f(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ t &amp; t\ge0 \\ \end{cases}\)</span></td>
</tr>
<tr class="even">
<td>$ u(t)$：单位阶跃信号</td>
<td><span class="math inline">\(u(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ 1 &amp; t&gt;0 \\ \end{cases}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</td>
<td><span class="math inline">\(\begin{cases} \begin{aligned} &amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\ &amp;\delta(t) = 0\quad while(t\not=0) \end{aligned} \end{cases}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</td>
<td><span class="math inline">\(\delta(t)&#39;=\frac{d\delta(t)}{dt}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="ft单位斜变信号"><span class="math inline">\(f(t)\)</span>：单位斜变信号</h4>
<p>单位斜变信号的“单位”体现在其非零部分的斜率为 <span class="math inline">\(1\)</span> 。</p>
<p>函数表达式： <span class="math display">\[
f(t) = 
\begin{cases}
0 &amp;     t&lt;0     \\\\
t &amp;     t\ge0   \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后： <span class="math display">\[
f(t-t_0) = 
\begin{cases}
0       &amp;       t&lt;t_0           \\\\
t-t_0   &amp;       t\ge t_0        \\
\end{cases}
\]</span></p>
<h4 id="ut单位阶跃信号">$ u(t)$：单位阶跃信号</h4>
<p>函数表达式：</p>
<p>由表达式可知 <span class="math inline">\(t=0\)</span> 处函数未定义，可以将 <span class="math inline">\(t=0\)</span> 处函数值定义为 <span class="math inline">\(u(0)=\frac{1}{2}\)</span>。 <span class="math display">\[
u(t) = 
\begin{cases}
0   &amp;       t&lt;0     \\\\
1   &amp;       t&gt;0     \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后（或认为阶跃延时 <span class="math inline">\(t\)</span> 后），有： <span class="math display">\[
u(t-t_0) = 
\begin{cases}
0   &amp;       t&lt;t_0       \\\\
1   &amp;       t&gt;t_0       \\
\end{cases}
\]</span></p>
<h4 id="deltat单位冲激函数"><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</h4>
<p>狄拉克（Dirac）定义方式： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\
&amp;\delta(t) = 0\quad while(t\not=0)
\end{aligned}
\end{cases}
\]</span> 狄拉克（Dirac）定义表明：</p>
<ol type="1">
<li>除了坐标轴零点处，其余位置单位冲激函数的函数值均为 <span class="math inline">\(0\)</span> 。</li>
<li>单位冲激函数仅在一点处取值，而其面积（积分）为 <span class="math inline">\(1\)</span> ，由此可知单位冲激函数为长度为 <span class="math inline">\(1\)</span> 的线段：表示中我们使用长度为 <span class="math inline">\(1\)</span> 的向量来表示，方向与 <span class="math inline">\(y\)</span> 轴正半轴方向相同。</li>
</ol>
<h4 id="deltat冲激偶函数"><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</h4>
<p>由符号可知冲激偶函数为冲激函数的导数。</p>
<h4 id="常见奇异信号之间的关系">常见奇异信号之间的关系：</h4>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{df(t)}{dt}=u(t)\\\\
&amp;\frac{du(t)}{dt}=\delta(t)\\\\
&amp;\delta(t)&#39;=\frac{d\delta(t)}{dt}
\end{aligned}
\end{cases}
\]</span></p>
<h4 id="单位冲激函数-deltat-的简单性质">单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 的简单性质：</h4>
<ol type="1">
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 具有<strong>抽样特性</strong>（也称“筛选”特性），<span class="math inline">\(\delta(t)\)</span> 可以用来筛选出信号中某一时刻的值（函数值），具体操作如下： <span class="math display">\[
\int_{-\infty}^{\infty}\delta(t-t_0)f(t)dt=f(t_0)
\]</span> 解释：对于任意一个信号 <span class="math inline">\(f(t)\)</span> ，我们使用 <span class="math inline">\(\delta(t)\)</span> 可以筛选出目标的函数值 <span class="math inline">\(f(t_0)\)</span> 。</p></li>
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 是一个偶函数，即 <span class="math inline">\(\delta(t)=\delta(-t)\)</span></p></li>
</ol>
<h3 id="线性时不变系统lti">线性时不变系统——LTI</h3>
<ol type="1">
<li><p>理解线性：</p>
<ol type="1">
<li>满足叠加性和均匀性</li>
</ol></li>
<li><p>理解时不变特性：即系统本身的参数不随时间发生改变</p></li>
<li><p>线性时不变系统还具有的特性：</p>
<ol type="1">
<li><p>微分特性：微分特性由线性和时不变性共同得出，内容为：</p>
<p>若激励信号 <span class="math inline">\(e(t)\)</span> 可使系统产生响应信号 <span class="math inline">\(r(t)\)</span>，则</p>
<ul>
<li>激励 <span class="math inline">\(\frac{de(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{dr(t)}{dt}\)</span></li>
<li>激励 <span class="math inline">\(\frac{d^2e(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{d^2r(t)}{dt}\)</span>，其余高阶求导同理</li>
<li>激励 <span class="math inline">\(\int^t_0e(\tau)d\tau\)</span> 可产生响应 <span class="math inline">\(\int^t_0r(\tau)d\tau\)</span></li>
</ul></li>
<li><p>因果特性：因果特性描述了激励信号与响应信号之间的联系，因果特性表明：<span class="math inline">\(t_0\)</span> 时刻的响应只与<span class="math inline">\(t=t_0\)</span> 和 <span class="math inline">\(t&lt;t_0\)</span> 时刻的输入有关，即激励和响应有着因果关系，只有有激励才会有响应。</p></li>
</ol></li>
</ol>
<h3 id="分析lti">分析LTI</h3>
<p>系统建模就是使用数学工具例如方程或者微分方程来建立模型。</p>
<ol type="1">
<li>系统的数学描述方法可以分为两大类：</li>
</ol>
<ul>
<li>输入输出描述法——该方法注重系统激励和响应之间的关系，不关心系统内部变量情况
<ul>
<li>这种方法在数学上表现为一元<span class="math inline">\(n\)</span>阶微分方程</li>
</ul></li>
<li>状态变量描述法
<ul>
<li>可以给出系统响应</li>
<li>提供系统内部各变量的情况</li>
<li>可以用于多输入多输出系统的分析</li>
<li>这种方法在数学上表现为<span class="math inline">\(n\)</span>元联立一阶微分方程</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>使用数学方法描述了一个系统后，我们就需要一些求解方法来求解系统模型，求解方法大体上也可以分为两类：</li>
</ol>
<ul>
<li>时域分析——时域分析是指在时间域上分析系统；前文可知系统可以简单理解为一个以时间为自变量的函数或函数族，时间域分析就是直接分析这个以时间变量作为自变量的函数。
<ul>
<li>时域分析分析输入输出法描述的系统模型时：
<ul>
<li>可以使用经典的常系数微分方程和差分方程</li>
<li>也可以使用算子符号来简化上面的微分方程和差分方程</li>
<li>卷积是分析线性系统时域的重要数学工具</li>
</ul></li>
<li>时域分析分析状态变量法描述的系统模型时：
<ul>
<li>需要求解矩阵方程</li>
</ul></li>
</ul></li>
<li>变换域分析——变换域是指将时变函数中的自变量：时间变量变换成其他变量函数。变换域分析使得时域分析中复杂的微分积分运算变成了代数运算，将复杂的卷积运算变成了乘法运算</li>
</ul>
<h3 id="电系统的lti数学模型建立">电系统的LTI数学模型建立</h3>
<p>构成电系统的LTI模型表现为微分方程式</p>
<p>构成此类方程式的依据是电系统网络的两类约束特性：</p>
<ul>
<li>电元器件约束特性——电子元器件的伏安特性
<ul>
<li>欧姆定律：
<ul>
<li><span class="math inline">\(V_R(t)=Ri_R(t)\)</span></li>
<li><span class="math inline">\(V_L(t)=L\frac{di(t)}{dt}\)</span></li>
<li><span class="math inline">\(V_C(t)=\frac{1}{C}\int_{-\infty}^ti_C{(\tau)}d\tau\)</span></li>
</ul></li>
</ul></li>
<li>网络拓扑结构——网络结构决定的电流电压关系
<ul>
<li>基尔霍夫定律：
<ul>
<li><span class="math inline">\(\sum i(t)=0\)</span></li>
<li><span class="math inline">\(\sum v(t)=0\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>线性时不变系统的时域分析，微分方程的一般形式： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 上式可以缩写为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 特殊形式，例如我们可以整理约束关系得到下式： <span class="math display">\[
\frac{d^3r(t)}{dt^3}+7\frac{d^2r(t)}{dt^2}+16\frac{dr(t)}{dt}+12r(t)=e(t)
\]</span> 微分方程的全解由齐次解 <span class="math inline">\(r_h(t)\)</span> 和特解 <span class="math inline">\(r_h(t)\)</span> )组成，即： <span class="math display">\[
r(t)=r_h(t)+r_h(t)
\]</span> 解法：</p>
<ol type="1">
<li>求齐次解 <span class="math inline">\(r_h(t)\)</span>：</li>
</ol>
<ul>
<li><p>令 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0\)</span>，该式称为齐次方程</p></li>
<li><p>将 <span class="math inline">\(r(t)=Ae^{\alpha t}\)</span> 代入齐次方程得 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\alpha^{i}=0\)</span>，称为特征方程</p></li>
<li><p>根据特征方程可以得齐次解 <span class="math inline">\(r_h(t)\)</span> 为</p>
<ul>
<li><p>特征方程没有重根：<img src="/2022/02/27/16-42-18/image-20220326234840139-16483097818622.png" alt="image-20220326234840139" style="zoom: 40%;"></p></li>
<li><p>特征方程有重根：<img src="/2022/02/27/16-42-18/image-20220326234918784-16483097790591.png" alt="image-20220326234918784" style="zoom: 40%;"></p></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>求特解 <span class="math inline">\(r_h(t)\)</span>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>激励函数 <span class="math inline">\(e(t)\)</span></th>
<th>响应函数 <span class="math inline">\(r(t)\)</span> 的特解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E\)</span></td>
<td><span class="math inline">\(B\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^p\)</span></td>
<td><span class="math inline">\(B_1t^p+B_2t^{p-1}+···+B_pt+B_{p+1}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(e^{\alpha t}\)</span></td>
<td><span class="math inline">\(Be^{\alpha t}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(cos(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(sin(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^pe^{\alpha t}cos(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(t^pe^{\alpha t}sin(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>求待定系数 <span class="math inline">\(A\)</span>：</p></li>
</ol>
<h3 id="拉普拉斯变换">拉普拉斯变换</h3>
<p>形态上，拉普拉斯变换做了这样一件事： <span class="math display">\[
f(t)\xrightarrow{\sf{拉普拉斯变换}}F(s)
\]</span> 或者说： <span class="math display">\[
f(t)\xrightarrow{\mathscr{L}\{f(t)\}}F(s)
\]</span> 从形态上讲，拉普拉斯变换将一个以时间 <span class="math inline">\(t\)</span> 为自变量的函数变换成了一个以频率 <span class="math inline">\(s\)</span> 为自变量的函数。</p>
<p>拉普拉斯变换将函数从时域变换到了频域，其实就是信号的自变量发生了变化。</p>
<p>意义：拉普拉斯变换可以将时域内的微分方程变换成频域内的代数方程，降低计算难度并且从频域再次回到时域时保证解不变。</p>
<p><span class="math inline">\(\mathscr{L}\{f(t)\}\)</span> 拉氏变换的定义为： <span class="math display">\[
\mathscr{L}\{f(t)\}=\int_{0}^{\infty}f(t)\cdot e^{-st}dt
\]</span> 注意事项：</p>
<ol type="1">
<li>进行拉氏变换的 <span class="math inline">\(f(t)\)</span> 是否存在的问题：
<ul>
<li>首先是初等函数都能进行拉氏变换</li>
<li>默认在线性电路分析中均使用能够进行拉氏变换的电源进行系统的激励</li>
</ul></li>
<li>上述拉氏变换也可以称作单边拉氏变换，此变换忽略了 <span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span></li>
<li><span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span> 可以通过初始条件来考虑</li>
</ol>
<p>分类：</p>
<p>学习拉普拉斯变换将拉普拉斯变换分为函数变换和算子变换</p>
<ul>
<li>函数变换：研究初等函数的拉氏变换</li>
<li>算子变换：研究一般函数的拉氏变换</li>
</ul>
<h4 id="算子变换">算子变换：</h4>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>拉氏变换</th>
<th><span class="math inline">\(\mathscr{L}\{f(t)\}=F(s)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乘以常数</td>
<td><span class="math inline">\(\mathscr{L}\{Kf(t)\}=KF(s)\)</span></td>
</tr>
<tr class="even">
<td>加减运算</td>
<td><span class="math inline">\(\mathscr{L}\{f(t_1)+f(t_2)-f(t_3)\}=F(s_1)+F(s_2)-F(s_3)\)</span></td>
</tr>
<tr class="odd">
<td>微分运算</td>
<td>一重微分：<span class="math inline">\(\mathscr{L}\{\frac{df(t)}{dt}\}=sF(s)-f(0^-)\)</span><br><span class="math inline">\(n\)</span> 重微分：<span class="math inline">\(\mathscr{L}\{\frac{d^nf(t)}{dt^n}\}=s^nF(s)-s^{n-1}f(0^-)-\sum_{i=2}^{n}s^{n-i}\frac{d^{i-1}f(0^-)}{dt^{i-1}}\)</span></td>
</tr>
<tr class="even">
<td>积分运算</td>
<td><span class="math inline">\(\mathscr{L}\{\int_{0^-}^{t}f(t)dt\}=F(s)/s\)</span></td>
</tr>
<tr class="odd">
<td>时域平移特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(t-a)\cdot u(t-a)\}=e^{-as}\cdot F(s),\quad a&gt;0\)</span><br><span class="math inline">\(\mathscr{L}\{e^{-as}\cdot F(s)\}=F(s+a)\)</span></td>
</tr>
<tr class="even">
<td>尺度变换特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(at)\}=\frac{1}{a}F\left(\frac{s}{a}\right),\quad a&gt;0\)</span></td>
</tr>
</tbody>
</table>
<h3 id="傅里叶分析简介">傅里叶分析简介</h3>
<p>傅里叶定理表明，任何一个角频率为<span class="math inline">\(\omega_0\)</span>的周期函数都可以表示为无穷多个频率为<span class="math inline">\(\omega_0\)</span>整数倍的正弦函数与余弦函数之和。</p>
<p>对于一个周期函数<span class="math inline">\(f(t)\)</span>，若满足Dirichlet条件，则该周期函数可以展开成傅里叶级数，即： <span class="math display">\[
\begin{aligned}
    &amp;if\quad f(t)=f(t+T)\\\\
    &amp;then\quad f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) +  \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
        &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
    &amp;if \quad f(t)=f(-t)\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\;\,\\\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
        &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=0 \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p>展开式中<span class="math inline">\(a_0\)</span>称为直流分量，其值等于函数<span class="math inline">\(f(t)\)</span>的平均值；<span class="math inline">\(a_n\)</span>与<span class="math inline">\(b_n(n\not=0)\)</span>是交流分量的幅值 <span class="math display">\[
f(t)=f(t+T)\Rightarrow
f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) + \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
\]</span></p>
<p><span class="math display">\[
\begin{array}{c|c|c}
    \begin{aligned}
    &amp;general\quad condition\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
            &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
            &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) sin(n\omega_0t) \,dt \\
        \end{aligned}
    }
    \end{aligned}
    &amp;
    \begin{aligned}
        &amp;if \quad f(t)=f(-t)\\
        &amp;\boxed
        {
            \begin{aligned}
                &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
                &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
                &amp;b_n=0 \\
            \end{aligned}
}
    \end{aligned}
    &amp; 
    \begin{aligned}
    &amp;if \quad f(t)=-f(-t)\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=0\\
            &amp;a_n=0\\
            &amp;b_n=\frac{4}{T}\int^{T/2}_{0} f(t) sin(n\omega_0t) \,dt  \\
        \end{aligned}
}
    \end{aligned}\\
\end{array}\\
\]</span></p>
<p><span class="math display">\[
P_{1\Omega}=F_{rms}^2=a_0^2+\frac{1}{2}\displaystyle\sum_{n=1}^{\infty}(a_n^2+b_n^2)
\]</span></p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>写给电子专业同学的C语言教程</title>
    <url>/2022/02/27/16-41-11/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理实验绘图</title>
    <url>/2022/02/25/06-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="标准程序">标准程序</h2>
<h3 id="数据标识标准">数据标识标准</h3>
<blockquote>
<p>实验测量数据统一使用measure的首字母m做下标表示</p>
<p>标准数据使用standard的首字母s做下标表示</p>
<p>通过拟合方程计算得出的结果使用calculate的首字母c做下标表示</p>
</blockquote>
<h3 id="相对误差计算程序">相对误差计算程序</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入测量值Xm=&#x27;</span>;</span><br><span class="line">Xm = input(prompt);</span><br><span class="line">prompt = <span class="string">&#x27;请输入标准值Xs=&#x27;</span>;</span><br><span class="line">Xs = input(prompt);</span><br><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">RelEor =<span class="built_in">abs</span>((Xm-Xs)/Xs)*<span class="number">100</span>;</span><br><span class="line">R=<span class="built_in">round</span>(RelEor,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;计算得相对误差为:&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([num2str(R),<span class="string">&#x27;%&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="描点作图">描点作图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="求平均值">求平均值</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];y</span><br><span class="line">Xm_mean=<span class="built_in">mean</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="一元线性回归">一元线性回归</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=[<span class="number">-1.875</span>,<span class="number">-1.474</span>,<span class="number">-1.262</span>,<span class="number">-0.709</span>,<span class="number">-0.586</span>];</span><br><span class="line">Ym=[<span class="number">8.214</span>,<span class="number">7.408</span>,<span class="number">6.879</span>,<span class="number">5.490</span>,<span class="number">5.196</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="绘图">绘图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">title(<span class="string">&quot;标题&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;X轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;Y轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="隐函数族图像绘制">隐函数族图像绘制</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">z</span> = <span class="title">z</span><span class="params">(x,y,k)</span></span></span><br><span class="line">z = <span class="number">0.5</span>*x^<span class="number">2</span>+<span class="number">3</span>*x*y+<span class="number">0.5</span>*y^<span class="number">2</span>-k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%k限定着函数族的范围</span></span><br><span class="line">k = <span class="number">-10</span>;</span><br><span class="line"><span class="keyword">while</span> k &lt; <span class="number">10</span></span><br><span class="line">    k = k + <span class="number">1</span>;</span><br><span class="line">    ezplot(@(x,y)z(x,y,k));</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="实验数据处理">实验数据处理</h2>
<h3 id="非线性负组电路元件伏安特性">非线性负组电路元件伏安特性</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">Ym=[<span class="number">-0.002</span>,<span class="number">-0.011</span>,<span class="number">-0.031</span>,<span class="number">-0.046</span>,<span class="number">-0.072</span>,<span class="number">-0.140</span>,<span class="number">-0.618</span>,<span class="number">-0.731</span>,<span class="number">-0.894</span>,<span class="number">-1.148</span>,<span class="number">-1.582</span>,<span class="number">-1.672</span>,<span class="number">-1.688</span>,<span class="number">-1.748</span>,<span class="number">-1.901</span>,<span class="number">-2.068</span>,<span class="number">-2.250</span>,<span class="number">-2.677</span>,<span class="number">-2.926</span>,<span class="number">-3.206</span>,<span class="number">-3.888</span>,<span class="number">-4.311</span>,<span class="number">-4.806</span>,<span class="number">-6.106</span>,<span class="number">-6.276</span>,<span class="number">-6.493</span>,<span class="number">-6.618</span>,<span class="number">-6.803</span>,<span class="number">-7.195</span>,<span class="number">-8.105</span>,<span class="number">-8.656</span>,<span class="number">-9.267</span>,<span class="number">-9.962</span>,<span class="number">-10.353</span>,<span class="number">-10.766</span>,<span class="number">-11.214</span>,<span class="number">-11.214</span>,<span class="number">-11.533</span>,<span class="number">-11.645</span>,<span class="number">-11.893</span>,<span class="number">-12.094</span>,<span class="number">-12.146</span>,<span class="number">-12.273</span>,<span class="number">-12.352</span>,<span class="number">-12.457</span>];</span><br><span class="line">R=[<span class="number">300</span>,<span class="number">600</span>,<span class="number">900</span>,<span class="number">1000</span>,<span class="number">1100</span>,<span class="number">1200</span>,<span class="number">1300</span>,<span class="number">1305</span>,<span class="number">1310</span>,<span class="number">1315</span>,<span class="number">1320</span>,<span class="number">1325</span>,<span class="number">1330</span>,<span class="number">1350</span>,<span class="number">1400</span>,<span class="number">1450</span>,<span class="number">1500</span>,<span class="number">1600</span>,<span class="number">1650</span>,<span class="number">1700</span>,<span class="number">1800</span>,<span class="number">1850</span>,<span class="number">1900</span>,<span class="number">2000</span>,<span class="number">2010</span>,<span class="number">2020</span>,<span class="number">2030</span>,<span class="number">2040</span>,<span class="number">2060</span>,<span class="number">2100</span>,<span class="number">2120</span>,<span class="number">2140</span>,<span class="number">2160</span>,<span class="number">2170</span>,<span class="number">2180</span>,<span class="number">2190</span>,<span class="number">2200</span>,<span class="number">2700</span>,<span class="number">3000</span>,<span class="number">4000</span>,<span class="number">5000</span>,<span class="number">6000</span>,<span class="number">8000</span>,<span class="number">10000</span>,<span class="number">15000</span>];</span><br><span class="line">I=Ym./R;</span><br><span class="line">Xm=I;</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);<span class="comment">%数据点图</span></span><br><span class="line">title(<span class="string">&quot;非线性负组电路元件伏安特性&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;电流(A)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;电压(V)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="弦线上波的传播规律">弦线上波的传播规律</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定张力和线密度</span></span><br><span class="line">f=[<span class="number">70</span> <span class="number">90</span> <span class="number">110</span> <span class="number">130</span> <span class="number">150</span> <span class="number">180</span>];</span><br><span class="line">lamt=[<span class="number">1.22</span> <span class="number">0.9122</span> <span class="number">0.74</span> <span class="number">0.6136</span> <span class="number">0.5264</span> <span class="number">0.449</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(lamt);</span><br><span class="line">Ym=<span class="built_in">log</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(频率)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(频率)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173254618.png" alt="image-20211106173254618" style="zoom:33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">-0.935900</span>x+<span class="number">4.421856</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.998356</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.1989</span>   <span class="number">-0.0919</span>   <span class="number">-0.3011</span>   <span class="number">-0.4884</span>   <span class="number">-0.6417</span>   <span class="number">-0.8007</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">    <span class="number">4.2485</span>    <span class="number">4.4998</span>    <span class="number">4.7005</span>    <span class="number">4.8675</span>    <span class="number">5.0106</span>    <span class="number">5.1930</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定频率和线密度</span></span><br><span class="line">T=[<span class="number">2.45</span> <span class="number">7.34</span> <span class="number">12.23</span> <span class="number">17.12</span> <span class="number">22.02</span> <span class="number">26.91</span>];</span><br><span class="line">lamt=[<span class="number">0.449</span> <span class="number">0.6850</span> <span class="number">0.8934</span> <span class="number">1.032</span> <span class="number">1.148</span> <span class="number">1.2662</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(T);</span><br><span class="line">Ym=<span class="built_in">log</span>(lamt);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(周期)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(周期)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173033589.png" alt="image-20211106173033589" style="zoom: 33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">0.435631</span>x+<span class="number">-1.209052</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.997443</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8961</span>    <span class="number">1.9933</span>    <span class="number">2.5039</span>    <span class="number">2.8402</span>    <span class="number">3.0920</span>    <span class="number">3.2925</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.8007</span>   <span class="number">-0.3783</span>   <span class="number">-0.1127</span>    <span class="number">0.0315</span>    <span class="number">0.1380</span>    <span class="number">0.2360</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="磁滞曲线">磁滞曲线</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.2</span>:<span class="number">3</span>;</span><br><span class="line">&gt;&gt; y1=[<span class="number">-1.4</span>,<span class="number">-1.2</span>,<span class="number">-1.1</span>,<span class="number">-1.0</span>,<span class="number">-0.9</span>,<span class="number">-0.8</span>,<span class="number">-0.6</span>,<span class="number">-0.3</span>,<span class="number">0</span>,<span class="number">0.4</span>,<span class="number">0.7</span>,<span class="number">1.1</span>,<span class="number">1.4</span>,<span class="number">1.8</span>,<span class="number">1.9</span>,<span class="number">2.0</span>];</span><br><span class="line">&gt;&gt; y2=[<span class="number">1.4</span> <span class="number">1.3</span> <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.7</span> <span class="number">1.7</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.9</span> <span class="number">2.0</span> <span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x,y2)</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y2)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y1)</span><br><span class="line"></span><br><span class="line">title(<span class="string">&quot;磁滞曲线&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/25/06-07-35/Users\qjy\Desktop\untitled.png" alt="untitled"><figcaption aria-hidden="true">untitled</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理与接口技术</title>
    <url>/2022/03/05/16-32-26/</url>
    <content><![CDATA[<h1 id="微机原理与接口技术">微机原理与接口技术</h1>
<h2 id="基本概念">基本概念</h2>
<p>微型计算机简称微机，是微机原理这门课程的主要研究范围。</p>
<p>首先我们先对微型计算机有一个初步的认识。</p>
<h4 id="电脑微型计算机系统">电脑——微型计算机系统</h4>
<p>电脑是我们熟悉的事物，我们家用的台式电脑和笔记本电脑都是属于<strong>个人电脑（Personal Computer）</strong>，简称为PC。个人电脑PC是一个<strong>通用微型计算机系统（）</strong>。其中，“通用”暗示了“专用”计算机系统的存在，而“微型”暗示了“大型”计算机系统的存在。其中还有值得注意的是计算机系统中的“系统”二字，因为这暗示了在计算机之上还存在一个更加宏观的概念。</p>
<p>计算机根据规格和能力区分的话可以粗略分作超级计算机，大型计算机，小型计算机和微型计算机。其中超算和微机可能是我们日常生活中常常能听到的词语，前者出现在新闻里面，比如天河二号；后者出现在我们们的日常生活中，也就是我们的电脑（主机）。</p>
<p>经典的电脑硬件配置包括鼠标，键盘，显示器和电脑主机，虽然笔记本发展后大多数笔记本都配备有触控板作为鼠标的代替，但是鼠标依旧是更受欢迎的计算机<strong>外设（Peripherals）</strong>。除了鼠标，键盘和显示器也是最经典的外设，但是对于完全不了解电脑构造却经常使用电脑的人来说，或许会认为显示器是计算机，尤其是一体机的存在使得这个错误更容易犯下。但是，计算机，顾名思义是计算的机器，它的功能并不会包括“显示”。根据输入，计算机会得到输出，但是这个输出不是我们可以直接看到的“显示”，“显示”的功能来自一个密布发光单元的显示器，显示器可以将计算机的输出变成屏幕上的文字或者图片为我们“显示”出来。</p>
<p>外设不是计算机，真正的计算机是我们通常称为“电脑主机”的的部分，在台式机中，它是显示器旁边的长方体的箱子；在笔记本中，它一般在你的键盘的下面。</p>
<p>计算机（个人计算机）和外设，配合上电源，便组成了微型计算机系统的硬件部分。完整的微型计算机系统不仅包括硬件，还包括软件。后者不是我们在微机原理课程中重点的关注的内容，但是理解软件部分是微型计算机系统不可缺少的部分却很重要。</p>
<p>微型计算机系统的软件部分包括<strong>系统软件</strong>和<strong>应用软件</strong>，系统软件中我们最熟悉的就是操作系统，如Windows和MacOS；而像Office或者浏览器等软件则是应用程序即应用软件。</p>
<p>==总结：家用电脑整体称作<strong>微型计算机系统（）</strong>，这个系统分为硬件和软件两大部分，其中软件部分包括系统软件和应用软件；硬件部分包括电源、外设和最重要的微型计算机（电脑主机）。接下来我们重点介绍微型计算机的内部结构。==</p>
<h4 id="微型计算机">微型计算机</h4>
<p><strong>微型计算机（）</strong>内部结构可概括为四部分：</p>
<ul>
<li>CPU（这个肯定耳熟了，稍后会进一步介绍）</li>
<li>存储器（比较复杂，稍后重点介绍）</li>
<li>总线（bus）：总线就是连接计算机内部部件的导线</li>
<li>输入输出接口电路：与外设连接的导线</li>
</ul>
<p>相信即便是最不了解电脑的小白也听说过CPU的大名。CPU中的字母C表示Center，是中心的意思，表明CPU是计算机的中心。计算机中的一切一切都是围绕着CPU转圈的。这样重要且复杂的部件，我们肯定要单独拿出来讲：下一节微处理器，就是对CPU的详细介绍。</p>
<p>计算机的本质是计算，无论是使用计算机显示文本或是图形，播放音乐或是视频，计算机本身都只是在快速做着最简单的运算。我们从很小的时候便学习开始做运算了，我们知道，做运算首先我们需要纸笔记录下数字，然后可能还需要将结果记录在另一张纸上（比如你的试卷）。计算机中也存在大量的数字，我们称作数据（data），它们存在计算机的存储器中。除数据外，计算中我们需要知道算数的方法，比如老师对我们说，将两个数字相乘，我们就做乘法。计算机也存在类似的东西，称作指令（code）。众所周知，计算机使用二进制，也就是计算机中不存在文字，甚至不存在数字2，我们在计算机中只有0和1。因此计算机中指令和数据都是由0和1进行表示的。在计算机经典结构——冯·诺伊曼结构中，指令和数字不加区分的放在存储器中；而在另一种改进过的计算机结构——哈佛结构中，指令放在指令存储器中而数据放在数据存储器中。这种分开存放的优势在于可以使数据和指令的存取同时进行，我们将在后面进一步看到这样做的重要意义。</p>
<p>目前我们已经知道了，存储器存储着数据和指令。处理数据是计算机无时无刻都在做的事情，而指令则告诉计算机该怎样处理数据。那么接下来的问题是：我们需要一个什么样的存储器呢？</p>
<p>简单来说，我们需要一个好的存储器。一般来说，我们关注存储器的如下3个特点</p>
<ol type="1">
<li>存储器是一个存储结构，既要存，还要取
<ul>
<li>存——要求能存住，机器断电（掉电）后能不能一直保存</li>
<li>取——主要看速度，取出来自然是越快越好</li>
</ul></li>
<li>最后就是作为商品，我们还是要考虑成本的，成本太高买不起就不行了。</li>
</ol>
<p>综上，我们需要一个价格便宜，能掉电存储且读取速度快的存储器。</p>
<p>可惜的是，现实中没有那么完美的存储器（至少目前），虽然根据不同的原理人们制作出的低成本且掉电存储的快闪存储器Flash（就是很多人U盘用的那个），但是它传输速度慢；另一方面人们制作出了静态随机存储器SRAM，虽然便宜还传输快，但是掉电不保存。虽然除了上述两种还有一些类型的存储器，但是也都有其缺点。为了协调速度、容量和成本三个方面，人们设计出了三级存储结构：<strong>高速缓存存储器</strong>、<strong>内存储器（主存）</strong>和<strong>外存储器（辅存）</strong>。</p>
<p>高速缓存存储器存在于主存与CPU之间的一级存储器，容量小但是速度很快，接近于CPU的速度。</p>
<p>内存储器是CPU读取数据和指令的地方，如果数据在外存储器中，CPU将先把数据从外存储器移至内存储器中然后再处理数据。</p>
<p>外存储器就是我们平时说的电脑的固态硬盘，手里拿的U盘和已经淘汰了的光盘。</p>
<p>三级存储结构帮助我们再速度、容量和成本三个方面达到一个平衡。但是未来如果有更好的存储手段，能同时满足上述三点，或许我们就将创造全新的存储器结构，主存和辅存也将会像光盘一样被淘汰掉。</p>
<hr>
<p>微型计算机的分类——按微型计算机的结构形式分类。</p>
<ul>
<li>单片机</li>
<li>单板机</li>
<li>多板机</li>
</ul>
<p>对于数码爱好者，尤其是那些对于台式机组装机器充满兴趣的人都不会对多板机这个概念感到困惑。在台式机中存在一个叫主板或是叫母板的东西。典型的主板能提供一系列接合点，供我们非常熟悉名字的例如处理器、显卡、硬盘驱动器、存储器、对外设备等设备的接合。</p>
<p>多板机是在一块主板上提供了多个扩展插槽，并使用总线将各个部分进行连接，最终将一切封装在一个机箱里面。在组装的开始，我们有一堆板子，在组装完成后，我们有一台电脑。</p>
<p>单板机的思路与多板机不同，单板机将一台电脑用到的所用功能集成在一块电路板上，在购买单板机时我们直接买到的就是一台电脑，而不需要再进行组装。当然，鉴于单板机性能弱一般用于实验室和简单的控制场所，所以单板机所在的电路板可能会进一步连接在其他的电路板上。但是，无论外部还会连接什么，重点是，在一小块电路板上我们有了一台基础功能完备的电脑。这里值得一提的是，对于电子设计爱好者，很可能听说过Arduino和树莓派的大名，这里要说明，Arduino和树莓派都属于单板机。</p>
<p>单片机也被称作微控制器，这个名字基本对单片机定了性质。单片机通常是用来做控制的，常常用于工业，在实验室也经常见到它的身影。单片机将CPU和存储器……其实就是上面提到的微型计算机中该有的那些东西，集成在了一个芯片上面。通常来讲，你对商店老板说来来些单片机，那你将收到的是一些黑色塑料外壳包着的下方有许多金属引脚的小东西。与Arduino和树莓派，一个芯片既不能直接连接一个LED控制它的亮灭，也不能直接烧录程序。单片机正常执行控制需要建立一个最小工作系统，然后才能进行控制。如果想了解更具体些，<a href>这里</a>会有你想知道的。</p>
<p>==总结一下：微型计算机由CPU和存储器组成，内部有总线连接，向外有输入输出电路进行扩展。计算机的本职工作是做计算，计算需要指令和数据，根据指令数据的存储方式的不同可以将微型计算机分为冯·诺伊曼结构和哈佛结构。计算机可以分为单片机、单板机和多板机。将计算机放在一个芯片上是单片机，放在一个电路板上是单板机，多个板子各司其职组装在一起形成电脑叫多板机。==</p>
<h4 id="微处理器">微处理器</h4>
<p>微处理器（microprocessor）也称中央处理单元（central processing unit），是微型计算机的核心部件。</p>
<p>前面我们已将提过，计算机的本职工作是做计算。计算需要两方面内容——数据和指令。前者就相当于给你数字2和3，后者就相当于告诉你对2和3做乘法。对于CPU来说不止但肯定有下述三个功能：</p>
<ul>
<li>进行基本的算数和逻辑运算（如果想要知道电路是如何做运算的，<a href>这里</a>会找到答案的）</li>
<li>暂存少量数据（这是好理解的，毕竟我们计算式也要先把数字写在草稿纸上）</li>
<li>执行指令（值得注意的是指令是需要译码的）</li>
</ul>
<h3 id="嵌入式系统">嵌入式系统</h3>
<p>上文我们以通用计算机系统为例，沿着“微型计算机系统-&gt;微型计算机-&gt;微（型）处理器”三个层次描述了微机的基本概念。最后我们注意微机的另一大类，即平行于通用计算机系统的，名为嵌入式系统的专用计算机系统。</p>
<p>嵌入式系统也是微型计算机系统，上面描述的通用计算机系统包含的内容，在嵌入式系统中也同样有所体现。但是嵌入式系统的关键词在于“专用”。专用意味着嵌入式系统为某一具体的应用问题而生，不需要具备通用计算机系统的全部内容。例如，嵌入式系统中可能不会连接鼠标键盘等外设，而且不会具备完整的系统软件。</p>
<h2 id="arm微处理器">ARM微处理器</h2>
<p>ARM微处理器最重要的特性是其英文名称</p>
<h4 id="arm-微处理器的工作状态">ARM 微处理器的工作状态</h4>
<ul>
<li>ARM 状态：处理器执行32位的 ARM 指令集，即执行字方式的 ARM 指令</li>
<li>Thumb 状态：处理器执行16位的 Thumb 指令集，即执行半字方式的 ARM 指令</li>
</ul>
<p>ARM 微处理器在两种工作模式下都有切换处理器工作状态的指令，但是在 ARM 处理器开始执行代码时处理器应处于 ARM 状态。</p>
<h4 id="arm-微处理器的工作模式">ARM 微处理器的工作模式</h4>
<ul>
<li>用户模式</li>
<li>特权模式
<ul>
<li>系统模式</li>
<li>异常模式
<ul>
<li>管理模式</li>
<li>快速中断模式</li>
<li>外部中断模式</li>
<li>数据访问中止模式</li>
<li>未定义指令中止模式</li>
</ul></li>
</ul></li>
</ul>
<p>工作模式可以通过软件改变，也可以通过外部中断和处理器异常来改变。并且每一种模式下可以使用的寄存器是不同的。</p>
<h4 id="arm-处理器支持的数据类型和存储格式">ARM 处理器支持的数据类型和存储格式</h4>
<h5 id="数据类型">数据类型</h5>
<p>在处理器中数据类型是这样分类的，分成下面三种类型：</p>
<ul>
<li>字节类型</li>
<li>半字类型</li>
<li>字类型</li>
</ul>
<p>数据操作都是以字为单位的（这里课本写：ARM 指令是一个字长而 Thumb 指令是半字长；但不是说操作都是以字为单位并且都是一样长吗？？？），而从存储器读写的数据则可以按上述三种不同的数据类型进行读写。</p>
<p>对存储器按字或者半字类型进行读取时，需要进行对齐操作；对数据进行字节传输时不需要对齐。</p>
<blockquote>
<p>一条指令（指的是机器码）由操作码（opcode）和操作数（operand）构成。操作数可以是1个，也可以是多个，甚至可以没有。操作码则是每一条指令都必须有。操作码表示该指令要做什么动作，例如跳转，加减等等。操作数则表示操作对象，操作数可能还会分为目的操作数和源操作数。操作数当然是一个数字，该操作数可以由多种来源，例如寄存器，存储器或者立即数。本节介绍的处理器的寻址方式就是讨论指令中操作数的来源问题。</p>
</blockquote>
<h5 id="存储格式">存储格式</h5>
<blockquote>
<p>指令编码中，用来说明操作数来源和操作数构成存储器地址的方法，叫做寻址方式，英文为Addressing Mode。寻址方式是由处理器的指令编码直接决定的，是处理器体系架构的一部分，所以我们一般叫做xxx处理器寻址方式，例如8086寻址方式，MIPS寻址方式。寻址方式是学习任何一种汇编语言的起点。</p>
</blockquote>
<p>ARM 存储器的最大寻址空间为4 GB。</p>
<p>存储器可以看作是一个从零开始线性递增的一个容器，容器的基本单位为字节。</p>
<p>数据以字为单位存储在存储器中，这意味着一个（字）数据将存放在存储器的四个基本单位中。</p>
<p>数据在存储器中的存储方式有两种，区分两种存储方式的关键在于一个字的四个字节在存储器中哪一个存在高位哪一个存在低位：</p>
<ul>
<li>大端格式：数据的高字节位存储在存储器的低地址中</li>
<li>小端格式：数据的低字节位存储在存储器的低地址中</li>
</ul>
<p>大小端的存储方式可以通过外部引脚和内部寄存器的配置来进行选择，选择要在使用前进行配置，开始使用后只能选择一种存储器数据存储方式。</p>
<h4 id="arm-处理器的寄存器">ARM 处理器的寄存器</h4>
<p>ARM 寄存器：</p>
<ul>
<li>定义：寄存器是 CPU 内部用来暂时存放参与运算的数据和运算结果的小型存储区域</li>
<li>特征：传输数据的速度非常快</li>
<li>分类：
<ul>
<li>通用寄存器：保存数据和地址</li>
<li>状态寄存器：标识 CPU 的工作状态及程序的运行状态</li>
</ul></li>
<li>经典 ARM 寄存器在物理上共有37个32位寄存器组成
<ul>
<li>31个通用寄存器</li>
<li>6个状态寄存器</li>
</ul></li>
</ul>
<h4 id="arm-处理器的io组织">ARM 处理器的I/O组织</h4>
<p>I/O 是 CPU 与外部设备之间通信的桥梁</p>
<p>对 I/O 端口物理地址进行编址的方式有两种：</p>
<ul>
<li><p>独立编址方式：I/O映射方式，x86采用</p>
<p>I/O 端口地址与内存单元地址分开独立编址，I/O 端口地址不占用内存空间的地址范围，需要专门的I/O 指令和控制逻辑</p></li>
<li><p>统一编址方式：内存映射方式，ARM采用</p>
<p>I/O 端口地址与内存单元地址混在一起：将内存的一部分划分出来作为I/O 地址空间。</p></li>
</ul>
<h2 id="cortex-m4-微处理器">Cortex-M4 微处理器</h2>
<h4 id="cortex-m4-微处理器的工作状态">Cortex-M4 微处理器的工作状态</h4>
<h4 id="cortex-m4-微处理器的工作模式">Cortex-M4 微处理器的工作模式</h4>
<h4 id="cortex-m4-微处理器的寄存器组织">Cortex-M4 微处理器的寄存器组织</h4>
<ul>
<li>存在于：寄存器存在于处理器的内核之中</li>
<li>作用：执行数据处理和控制</li>
<li>分类：16个32位寄存器
<ul>
<li>通用寄存器组</li>
<li>特殊功能寄存器</li>
</ul></li>
<li>与经典的 ARM 微处理器对比：Cortex-M4 微处理器的寄存器较少</li>
<li>通用寄存器详解：
<ol type="1">
<li><span class="math inline">\(R0-R7\)</span>：
<ul>
<li>统称：低组寄存器</li>
<li>访问指令：32位指令和大多数16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R8-R12\)</span>：
<ul>
<li>统称：高组寄存器</li>
<li>访问指令：32位指令和少量16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R13\)</span>：
<ul>
<li>统称：堆栈指针寄存器</li>
<li>系统可以同时支持两个堆栈，</li>
</ul></li>
</ol></li>
</ul>
<h4 id="cortex-m4-微处理器的存储组织">Cortex-M4 微处理器的存储组织</h4>
<h1 id="摘抄">摘抄：</h1>
<p>RISC使用的是load-store结构。load-store结构的本质，在于RISC技术的CPU只处理（指逻辑，算术运算处理）寄存器中的数据。相反，X86却能够直接处理存储器中的数据。</p>
<p><a href="https://nieyong.github.io/wiki_cpu/index.html">index (nieyong.github.io)</a></p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程笔记</title>
    <url>/2022/02/25/05-07-35/</url>
    <content><![CDATA[<p>​</p>
<p>[TOC]</p>
<hr>
<h3 id="分类和解法">分类和解法</h3>
<h4 id="一阶线性方程">一阶线性方程</h4>
<p>$$ First,order,linear,differential,equation:x'+p(t)x=q(t) \\ solution:</p>
<p>e<sup>{<em>{}{}{p(t)}dt}x'+e^{</em>{}{}{p(t)}dt}p(t)x=e</sup>{<em>{}{}{p(t)}dt}q(t) \  \ (e^{</em>{}{}{p(t)}dt}x)'=e^{_{}{}{p(t)}dt}q(t) $$</p>
<h4 id="变量分离方程">变量分离方程</h4>
<p><span class="math display">\[
Separable\,equation : x&#39;=h(t)g(x) \qquad g(x)!= 0
\\\\
solution:x&#39;=h(t)g(x) \xrightarrow{x&#39;=\frac{dx}{dt}} \frac{dx}{g(x)}=h(t)dt
\\
\Downarrow 
\\
\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt
\]</span></p>
<h4 id="恰当方程">恰当方程</h4>
<p><span class="math display">\[
Exact\,equation:
\begin{cases}
M(x,y)dx+N(x,y)dy=0\\
\\
N_x=M_y\\
\end{cases}
\\\\
\]</span></p>
<h3 id="二阶线性常微分方程">二阶线性常微分方程</h3>
<p>最一般的二阶线性微分方程为： <span class="math display">\[
a_0(t)x&#39;&#39;+a_1(t)x&#39;+a_2(t)x=g(t)
\]</span> 下述讨论中，我们仅讨论<span class="math inline">\(a_0(t)\not=0\)</span>的情况</p>
<p>即： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)
\]</span></p>
<h4 id="齐次方程">齐次方程：</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=0\tag{1}
\]</span> 求齐次方程通解的方法：</p>
<ol type="1">
<li><p>找到两个特解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p>
<ol type="1">
<li><p>如果不能找到两个特解，那就先找到一个特解<span class="math inline">\(x_1\)</span>，那么<span class="math inline">\(x_2\)</span>为：</p>
<ol type="1">
<li>设<span class="math inline">\(x_2=v_1(t)x_1\)</span>，将<span class="math inline">\(x_2\)</span>带入到<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=0\)</span>中，整理求出<span class="math inline">\(v_1(t)\)</span></li>
</ol>
<p><span class="math display">\[
x_2=x_1\int \frac{e^{-\int p(t)dt}}{x_1^2}dt
\]</span></p></li>
<li><p>如果一个特解也找不到：</p>
<p>？？？？？</p></li>
</ol></li>
<li><p>验证两个特解<strong>线性无关</strong>:<span class="math inline">\(W(t)\not=0\)</span></p>
<ol type="1">
<li><p>Remark：若<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>是二阶常微分方程的解，则：<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>线性相关<span class="math inline">\(\,\Leftrightarrow W(x_1,x_2)(t)=0\)</span></p></li>
<li><p>其中： <span class="math display">\[
W(x_1,x_2)(t)=\begin{vmatrix}
x_1 &amp; x_2\\
x_1&#39; &amp; x_2&#39;
\end{vmatrix}=x_1x_2&#39;-x_1&#39;x_2
\]</span></p></li>
</ol></li>
<li><p>若两特解线性无关，则齐次方程(1)式的通解为：<span class="math inline">\(x=c_1x_1+c_2x_2\)</span></p></li>
</ol>
<h4 id="非齐次方程">非齐次方程</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\tag{2}
\]</span> 求非齐次方程通解的方法：</p>
<ol type="1">
<li><p>先令<span class="math inline">\(f(t)\equiv 0\)</span>，求出<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\)</span>的通解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p></li>
<li><p>非齐次方程的通解可以表示为：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span>，其中<span class="math inline">\(x_p=v_1(t)x_1+v_2(t)x_2\)</span></p></li>
<li><p>求解<span class="math inline">\(v_1(t),v_2(t)\)</span></p>
<ol type="1">
<li><p>列方程组 <span class="math display">\[
\begin{cases}
\begin{aligned}
v_1&#39;x_1+v_2&#39;x_2&amp;=0\\\\
v_1&#39;x_1&#39;+v_2&#39;x_2&#39;&amp;=f(t)
\end{aligned}
\end{cases}
\]</span></p></li>
<li><p>利用克莱姆法则：</p>
<ul>
<li><p>克莱姆法则：</p>
<p><img src="/2022/02/25/05-07-35/image-20211126105116954.png" alt="image-20211126105116954" style="zoom:33%;"></p>
<p><img src="/2022/02/25/05-07-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20211126105131958.png" alt="image-20211126105131958" style="zoom:33%;"></p></li>
</ul>
<p><span class="math display">\[
v1&#39;=\frac{\begin{vmatrix}0 &amp; x_2\\f(t) &amp; x_1&#39;\end{vmatrix}}{W(t)}=-\frac{x_2f(t)}{W(t)}\\\\
v2&#39;=\frac{\begin{vmatrix}x_1 &amp; 0\\x_1&#39; &amp; f(t)\end{vmatrix}}{W(t)}=-\frac{x_1f(t)}{W(t)}
\]</span></p></li>
<li><p>最终对<span class="math inline">\(v_1&#39;\)</span>和<span class="math inline">\(v_2&#39;\)</span>进行积分 <span class="math display">\[
v_1=\int{}v_1&#39;dt\,,\:v_2=\int{}v_2&#39;dt,
\]</span></p></li>
</ol></li>
<li><p>最终得到非齐次方程的通解：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span></p></li>
</ol>
<h4 id="常系数的二阶微分方程">常系数的二阶微分方程</h4>
<p>求解目标： <span class="math display">\[
ax&#39;&#39;+bx&#39;+cx=0\,,\:(a\not= 0)
\]</span> 求解方法： <span class="math display">\[
Let\;\;x=e^{mt}\;x&#39;=me^{mt}\;x&#39;&#39;=m^2e^{mt}\\ \Downarrow\\
ax&#39;&#39;+bx&#39;+cx=am^2e^{mt}+bme^{mt}+ce^{mt}=0\\ \Downarrow\\
e^{mt}(am^2+bm+c)=0
\]</span> 对于：<span class="math inline">\(am^2+bm+c=0\)</span></p>
<ul>
<li><p>case 1: <span class="math display">\[
\Delta &gt; 0\\
&amp;m_1=\frac{-b+\sqrt{b^2-4ac}}{2a}\\
&amp;m_2=\frac{-b-\sqrt{b^2-4ac}}{2a}\\
so\\
&amp;x_1=e^{m_1t}\;x_2=e^{m_2t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{m_1t}+c_2e^{m_2t}
\]</span></p></li>
<li><p>case 2: <span class="math display">\[
\Delta = 0\\
&amp;m=-\frac{b}{2a}\\
so\\
&amp;x_1=e^{mt}=e^{-\frac{b}{2a}t}\\
&amp;x_2=te^{-\frac{b}{2a}t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{-\frac{b}{2a}t}+c_2te^{-\frac{b}{2a}t}
\]</span></p></li>
<li><p>case 3: <span class="math display">\[
i^2=-1
\]</span></p>
<p>$$ =b^2-4ac &lt; 0\ &amp;m==i=i\</p>
<p>&amp;x=e^{t}(cos(t)+isin(t)) $$</p></li>
</ul>
<h4 id="欧拉等式">欧拉等式</h4>
<p>求解目标： <span class="math display">\[
at^2x&#39;&#39;+btx&#39;+cx=0
\]</span> 求解方法：</p>
<ol type="1">
<li><p>首先令：<span class="math inline">\(t=e^s,s=lnt\)</span></p></li>
<li><p>则有：<span class="math inline">\(x&#39;(s)=tx&#39;(t);\, x&#39;&#39;(s)-x&#39;(s)=t^2x&#39;&#39;(t)\)</span></p></li>
<li><p>上面两个式子带入<span class="math inline">\(at^2x&#39;&#39;+btx&#39;+cx=0\)</span>有：</p>
<p><span class="math inline">\(\begin{aligned}at^2x(t)&#39;&#39;+btx(t)&#39;+cx(t)\\&amp;=a(x&#39;&#39;(s)-x&#39;(s))+bx&#39;(s)+cx(s)\\&amp;=ax&#39;&#39;(s)+(b-a)x&#39;(s)+cx(s)\\&amp;=0\end{aligned}\)</span></p></li>
<li><p>根据常系数的二阶微分方程的求解方法：<span class="math inline">\(e^{mt}(am^2+(b-a)m+c)=0\)</span></p></li>
<li><p><span class="math display">\[
(am^2+(b-a)m+c)=0\;\;\sf{分三种情况讨论：}
\begin{cases}
\begin{aligned}
\Delta&gt;0\\\\
\Delta=0\\\\
\Delta&lt;0\\\\
\end{aligned}
\end{cases}
\]</span></p></li>
</ol>
<p>如果<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n × n\)</span>矩阵，那么下列语句是等价的。</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>是可逆的。</li>
<li><span class="math inline">\(Ax = 0\)</span>只有平凡解。</li>
<li><span class="math inline">\(A\)</span>的行简化阶梯形是<span class="math inline">\(I_n\)</span>。</li>
<li>A可以表示为初等矩阵的乘积.</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>都是一致的。</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>只有一个解</li>
<li><span class="math inline">\(det(A) \not= 0\)</span></li>
<li><span class="math inline">\(A\)</span>的列向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>的行向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>张成空间<span class="math inline">\(R_n\)</span>的列向量。</li>
<li><span class="math inline">\(A\)</span>的行向量张成<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的列向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的行向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的等级是<span class="math inline">\(n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零度为零。</li>
<li><span class="math inline">\(A\)</span>的零空间的正交补是<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间的正交补是<span class="math inline">\(\{0\}\)</span>。</li>
</ol>
<p>线性相关性，两种表述方式 <span class="math display">\[
x_3=c_1x_1+c_2x_2\\
\]</span> 线性无关：只有系数全为0时线性组合才恒为0</p>
<p>线性相关：能找出一组非零常数使得线性组合结果为0</p>
<h2 id="高阶微分方程">高阶微分方程</h2>
<h3 id="线性微分方程的一般理论">线性微分方程的一般理论</h3>
<p>本章讨论的问题：求解微分方程（高阶导数使用数字上标表示） <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{1}
\]</span></p>
<ol type="1">
<li><p>齐次形式： <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{2}
\]</span></p></li>
<li><p>解的存在唯一性：</p>
<p>如果<span class="math inline">\(a_i(t)(i=1,2,\cdot\cdot\cdot,n)\)</span>及<span class="math inline">\(f(t)\)</span>都是$a t b <span class="math inline">\(上的连续函数，则对于任一\)</span>t_0<span class="math inline">\(及任意的\)</span>x_0<span class="math inline">\(，\)</span>x_0'<span class="math inline">\(，\)</span><span class="math inline">\(，\)</span>x_0^{(n-1)}<span class="math inline">\(，方程（1）存在唯一解\)</span>x(t)<span class="math inline">\(，符号记为\)</span>x=(t)<span class="math inline">\(，定义于\)</span>a t b $，且满足初值条件： <span class="math display">\[
\varphi(t_0)=x_0,\;\varphi(t_0)&#39;=x_0&#39;,\;\varphi(t_0)^{(n-1)}=x_0^{(n-1)}
\]</span></p></li>
</ol>
<h4 id="齐次线性微分方程解的性质和结构"><code>齐次线性微分方程解</code>的性质和结构</h4>
<ol type="1">
<li><code>齐次线性微分方程的解</code>的<code>叠加原理</code>
<ol type="1">
<li>描述：<code>齐次线性微分方程的解</code>的<code>线性叠加</code>仍为<code>齐次线性微分方程的解</code></li>
<li>原理：
<ol type="1">
<li>常数可以从微分号下提出来</li>
<li>和的导数等于导数的和</li>
</ol></li>
<li>问题：什么情况下解的线性组合可以成为齐次线性微分方程的通解？</li>
</ol></li>
<li></li>
</ol>
<p>变量分离方程：</p>
<p>解法：</p>
<ol type="1">
<li>非初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解</li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span></li>
</ol></li>
<li>初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解
<ol type="1">
<li>若<span class="math inline">\(x=0\)</span>是方程的解，则<span class="math inline">\(x\)</span>要么恒大于0，要么恒小于0</li>
</ol></li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span>，其中<span class="math inline">\(g(x)\not=0\)</span></li>
<li>最后使用<span class="math inline">\(x(t_0)=x_0\)</span>求解常数<span class="math inline">\(c\)</span></li>
</ol></li>
</ol>
<p>备注：如果求解出的<span class="math inline">\(x(t)\)</span>的分母可以等于0，那么要排除等于0的点；如果带有初值，那么t的取值范围为带有初值的那一部分</p>
<p>如何寻找常数解？对于常数解，我们7有<span class="math inline">\(x&#39;=0\)</span>，所以只要寻找使得方程右边为<span class="math inline">\(0\)</span>的常数<span class="math inline">\(k\)</span>就好了</p>
<p>存在唯一性定理：</p>
<p>解的存在和个数由f在(x0,t0)附近的性质决定</p>
<p>如果f在(x0,t0)附近连续即可知初值问题至少存在局部唯一解</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 =&gt; 解在局部唯一</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 &amp;&amp; 偏导数在一条形区域内有界 =&gt; 则在条形区间内有唯一解</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2022/02/17/11-07-35/</url>
    <content><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="链表">链表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> a, <span class="type">int</span> b, Node* c) : <span class="built_in">coef</span>(a), <span class="built_in">expn</span>(b), <span class="built_in">next</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Node*&amp; head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num; std::cin &gt;&gt; num;<span class="comment">//每个链表中数字的个数</span></span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin &gt;&gt; coef &gt;&gt; expn;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(coef, expn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">            new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(Node*&amp; head1, Node*&amp; head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* ptr1 = head1;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head2-&gt;expn == ptr1-&gt;expn)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr1-&gt;coef = ptr1-&gt;coef + head2-&gt;coef;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(head2-&gt;coef, head2-&gt;expn, head1);</span><br><span class="line">            head1 = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* x1 = <span class="literal">NULL</span>, * x2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Create</span>(x1); <span class="built_in">Create</span>(x2);</span><br><span class="line">    <span class="built_in">Add</span>(x1, x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">tree</span>(<span class="type">char</span> a, tree *b, tree *c) : <span class="built_in">data</span>(a), <span class="built_in">left</span>(b), <span class="built_in">right</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    tree *left;</span><br><span class="line">    tree *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(tree *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">tree</span>(c, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(tree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;tree *&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处输出是前序遍历</span></span><br><span class="line">            cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//此处输出是中序遍历</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Creat</span>(root);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的非递归前序遍历">树的非递归前序遍历</h4>
<ol type="1">
<li>创建一个栈
<ol type="1">
<li>只要节点不为空或者栈不为空
<ol type="1">
<li>如果节点为空
<ol type="1">
<li>打印</li>
<li>入栈</li>
<li>左走</li>
</ol></li>
<li>如果节点不为空
<ol type="1">
<li>取栈首</li>
<li>右走</li>
<li>出栈</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="图">图</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> vertex[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> edge[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vertex_num, edge_num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G-&gt;vertex_num;</span><br><span class="line">    cin &gt;&gt; G-&gt;edge_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G-&gt;vertex[i];</span><br><span class="line">        G-&gt;visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">            G-&gt;edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;edge_num; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G-&gt;edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; G-&gt;vertex[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;edge[i][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(queue&lt;<span class="type">int</span>&gt;&amp; queue, <span class="type">int</span> i, Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    queue.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">if</span> (!G-&gt;visited[i])<span class="comment">//这个模块起名为访问列吧</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(queue, i, G);<span class="comment">//每列入队</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())<span class="comment">//行入队后检查队是否为空，队首作为行的检测依据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">                    <span class="keyword">if</span> (G-&gt;edge[queue.<span class="built_in">front</span>()][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])<span class="comment">//这个模块起名为访问行</span></span><br><span class="line">                        <span class="built_in">visit</span>(queue, j, G);<span class="comment">//每行入队</span></span><br><span class="line">                cout &lt;&lt; G-&gt;vertex[queue.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//测试数据：9 15  A B C D E F G H I 0 1 0 5 1 2 1 8 1 6 2 3 2 8 3 4 3 7 3 6 3 8 4 5 4 7 5 6 6 7</span></span><br><span class="line">    Graph G;</span><br><span class="line">    <span class="built_in">Create</span>(&amp;G);</span><br><span class="line">    <span class="comment">//每次只能选择一个运行</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G, 0);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接矩阵的广度遍历">邻接矩阵的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>遍历 i (列)所有节点，对于未访问的节点进行下述操作
<ol type="1">
<li>打印 i 处节点并设置为访问过</li>
<li>将数字 i 入队</li>
<li>队列不为空时执行如下操作
<ol type="1">
<li>将队首元素赋值给 i</li>
<li>遍历 j (行)所有节点，当 i 和 j 有关系且 j 处节点未访问时执行如下操作
<ol type="1">
<li>打印 j 处节点并设置为访问过</li>
<li>将数字 j 入队</li>
</ol></li>
<li>队首出队</li>
</ol></li>
</ol></li>
</ol>
<h4 id="邻接矩阵的深度遍历">邻接矩阵的深度遍历</h4>
<ol type="1">
<li>遍历 i (列)所有节点，未访问节点进入 DFS(G,i)</li>
<li>DFS 函数： <br>1. 打印进入 DFS 的节点并设置为访问 <br>2. 遍历 j (行)所有节点，当 i 和 j 有关系且未访问的节点进入 DFS(G,j)</li>
</ol>
<h3 id="邻接表">邻接表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    list&lt;Vertex*&gt; edge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(vector&lt;Vertex&gt;&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> vertex_num; cin &gt;&gt; vertex_num;</span><br><span class="line">    <span class="type">int</span> edge_num; cin &gt;&gt; edge_num;</span><br><span class="line"></span><br><span class="line">    Vertex temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp.data;</span><br><span class="line">        temp.visited = <span class="literal">false</span>;</span><br><span class="line">        G.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * edge_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G[v1].edge.<span class="built_in">push_back</span>(&amp;G[v2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vertex* <span class="title">next_vertex</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> *iiter;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vertex != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vertex-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        vertex-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_level</span><span class="params">(queue&lt;Vertex*&gt;&amp; queue, Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>((*iiter));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Vertex*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(vertex);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>()-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        queue.<span class="built_in">front</span>()-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">get_level</span>(queue, queue.<span class="built_in">front</span>());</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 9 15 A B C D E F G H I 0 1 0 5 1 0 1 2 1 6 1 8 2 1 2 3 2 8 3 2 3 4 3 6 3 7 3 8 4 3 4 5 4 7 5 0 5 4 5 6 6 1 6 3 6 5 6 7 7 3 7 4 7 6 8 1 8 2 8 3</span></span><br><span class="line">    vector&lt;Vertex&gt; G;</span><br><span class="line">    <span class="built_in">Creat</span>(G);</span><br><span class="line">    <span class="comment">//每次只能运行一个</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G[0]);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表的深度遍历">邻接表的深度遍历</h4>
<p>·只要顶点不为空，打印顶点并设置为访问过；将下一个顶点进入该函数</p>
<h4 id="邻接表的广度遍历">邻接表的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>第一个顶点入队</li>
<li>队不为空，执行下述操作
<ol type="1">
<li>取队首顶点</li>
<li>打印队首顶点并设置为访问过</li>
<li>获得下一层顶点</li>
<li>队首出队</li>
</ol></li>
</ol>
<h4 id="next_node">next_node</h4>
<p>查链表，找到未访问顶点；设置为访问，返回该顶点</p>
<h4 id="get_level">get_level</h4>
<p>查链表，找到未访问顶点；设置为访问，将该顶点入队</p>
<h2 id="排序">排序</h2>
<h3 id="快排">快排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sbit = begin;</span><br><span class="line">        <span class="type">int</span> pivot = arry[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = begin; j &lt; end; j++)</span><br><span class="line">            <span class="keyword">if</span> (arry[j] &lt; pivot)</span><br><span class="line">              &#123;<span class="built_in">swap</span>(arry[j], arry[sbit]); sbit++;&#125;</span><br><span class="line">              <span class="comment">//每个数字与pivot比较，较小的与sbit交换</span></span><br><span class="line">              <span class="comment">//将pivot与sbit交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arry[sbit], arry[end]);</span><br><span class="line">        <span class="built_in">sort</span>(arry, begin, sbit - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(arry, sbit + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">8</span>] = &#123; <span class="number">27</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">81</span>, <span class="number">72</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排">堆排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heap</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = begin;</span><br><span class="line">    <span class="type">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[right] &amp;&amp; right &lt;= end) left++;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[root]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arry[left], arry[root]);</span><br><span class="line">            root = left;</span><br><span class="line">            left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, i, end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arry[<span class="number">0</span>], arry[i]);</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, <span class="number">0</span>, i<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">11</span>] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>堆排序</li>
<li>得最大堆的方法：
<ol type="1">
<li>范围：从 非叶子节点 到 根节点<br>
</li>
<li>调整对象：循环因子 到 表</li>
</ol></li>
<li>排序的方法：
<ol type="1">
<li>范围：从 表尾 到 根节点前</li>
<li>调整对象：无序首 到 无序尾</li>
</ol></li>
<li>维持堆的方法：</li>
</ol>
]]></content>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式(Latex)</title>
    <url>/2022/02/20/23-32-35/</url>
    <content><![CDATA[<h1 id="数学公式latex">数学公式(LATEX)</h1>
<h3 id="测试">测试：</h3>
<p>行内公式测试：<span class="math inline">\(A_a\)</span>，希腊字母：<span class="math inline">\(\beta\)</span></p>
<p>行间公式测试： <span class="math display">\[
f(t)=a_t
\]</span> 换行测试</p>
<ol type="1">
<li><p>行内 <span class="math inline">\(\begin{gather*}a_2\\d^5\end{gather*}\)</span> 行内测试完毕</p></li>
<li><p>行间 <span class="math display">\[
\begin{gather*}
a_2\\
d^5
\end{gather*}、
\]</span></p></li>
</ol>
<p>可以正常渲染公式。</p>
<h3 id="常用">常用</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">上下标：y<span class="built_in">_</span>下标=x<span class="built_in">^</span>上标<span class="keyword">\\</span></span><br><span class="line">分式与求导:<span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;<span class="keyword">\\</span></span><br><span class="line">求导：求导其实就是输入字母<span class="keyword">\\</span></span><br><span class="line">积分：<span class="keyword">\int</span><span class="built_in">_</span>&#123;积分下限&#125;<span class="built_in">^</span>&#123;积分上限&#125;&#123;积分变量&#125;d被积变量<span class="keyword">\\</span></span><br><span class="line">大括号:</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">括号内第一行<span class="keyword">\\</span></span><br><span class="line">括号内第二行<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;<span class="keyword">\\</span></span><br><span class="line">极限:<span class="keyword">\lim</span><span class="built_in">_</span>&#123;n<span class="keyword">\rightarrow</span><span class="keyword">\infty</span>&#125;&#123;x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vec</span>&#123;向量&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\prod</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sqrt</span> e<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
上下标：y_下标=x^上标\\
分式与求导:\frac{分子}{分母}\\
求导：求导其实就是输入字母\\
积分：\int_{积分下限}^{积分上限}{积分变量}d被积变量\\
大括号:
\begin{cases}
括号内第一行\\
括号内第二行\\
\end{cases}\\
极限:\lim_{n\rightarrow\infty}{x}\\
\vec{向量}\\
\sum_{n=起始值}^{终值}{a_n}\\
\prod_{n=起始值}^{终值}{a_n}\\
\sqrt e\\
\approx
\end{gather*}
\]</span></p>
<h3 id="运算符">运算符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line"><span class="keyword">\times</span></span><br><span class="line">/</span><br><span class="line"><span class="keyword">\div</span></span><br><span class="line"><span class="keyword">\cdot</span></span><br><span class="line"><span class="keyword">\#</span></span><br><span class="line"><span class="keyword">\%</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
+
-
\times
/
\div
\cdot
\#
\%
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\sqcup</span></span><br><span class="line"><span class="keyword">\sqcap</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\cap
\cup
\land
\lor
\sqcup
\sqcap
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\ast</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\otimes</span></span><br><span class="line"><span class="keyword">\oplus</span></span><br><span class="line"><span class="keyword">\odot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\circ
\ast
\star
\otimes
\oplus
\odot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pm</span></span><br><span class="line"><span class="keyword">\mp</span></span><br><span class="line"><span class="keyword">\dotplus</span></span><br><span class="line"><span class="keyword">\divideontimes</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\pm
\mp
\dotplus
\divideontimes
\]</span></p>
<h4 id="约等于">约等于</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">= <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\approxeq</span></span><br><span class="line"><span class="keyword">\cong</span></span><br><span class="line"><span class="keyword">\sim</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
=
= \not
\equiv
\approx
\approxeq
\cong
\sim
\]</span></p>
<h4 id="比较">比较</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">&gt;<span class="keyword">\\</span></span><br><span class="line">0 <span class="keyword">\le</span> <span class="keyword">\omega</span> t <span class="keyword">\le</span> <span class="keyword">\pi</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ge</span></span><br><span class="line"><span class="keyword">\gg</span></span><br><span class="line"><span class="keyword">\ll</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
&lt;
&gt;\\
0 \le \omega t \le \pi \\
\ge
\gg
\ll
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\curlyeqprec</span></span><br><span class="line"><span class="keyword">\curlyeqsucc</span></span><br><span class="line"><span class="keyword">\prec</span></span><br><span class="line"><span class="keyword">\succ</span></span><br><span class="line"><span class="keyword">\preceq</span></span><br><span class="line"><span class="keyword">\succeq</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\curlyeqprec
\curlyeqsucc
\prec
\succ
\preceq
\succeq
\]</span></p>
<h3 id="集合逻辑相关">集合/逻辑相关</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br><span class="line"><span class="keyword">\owns</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\subset</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\supset</span></span><br><span class="line"><span class="keyword">\subseteq</span></span><br><span class="line"><span class="keyword">\supseteq</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\neg</span></span><br><span class="line"><span class="keyword">\emptyset</span></span><br><span class="line"><span class="keyword">\varnothing</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\because</span></span><br><span class="line"><span class="keyword">\forall</span></span><br><span class="line"><span class="keyword">\exists</span></span><br><span class="line"><span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\in
\owns \not
\subset \not
\supset
\subseteq
\supseteq
\\
\cap
\cup
\land
\lor
\\
\neg
\emptyset
\varnothing
\\
\because
\forall
\exists
\therefore
\]</span></p>
<h3 id="箭头">箭头</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\gets</span></span><br><span class="line"><span class="keyword">\leftarrow</span></span><br><span class="line"><span class="keyword">\to</span></span><br><span class="line"><span class="keyword">\rightarrow</span></span><br><span class="line"><span class="keyword">\leftrightarrow</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\uparrow</span></span><br><span class="line"><span class="keyword">\downarrow</span></span><br><span class="line"><span class="keyword">\updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\gets
\leftarrow
\to
\rightarrow
\leftrightarrow
\\
\uparrow
\downarrow
\updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Leftarrow</span></span><br><span class="line"><span class="keyword">\Rightarrow</span></span><br><span class="line"><span class="keyword">\Leftrightarrow</span></span><br><span class="line"><span class="keyword">\iff</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Uparrow</span></span><br><span class="line"><span class="keyword">\Downarrow</span></span><br><span class="line"><span class="keyword">\Updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Leftarrow
\Rightarrow
\Leftrightarrow
\iff
\\
\Uparrow
\Downarrow
\Updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\nearrow</span></span><br><span class="line"><span class="keyword">\searrow</span></span><br><span class="line"><span class="keyword">\swarrow</span></span><br><span class="line"><span class="keyword">\nwarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\nearrow
\searrow
\swarrow
\nwarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\leftharpoonup</span></span><br><span class="line"><span class="keyword">\leftharpoondown</span></span><br><span class="line"><span class="keyword">\rightharpoonup</span></span><br><span class="line"><span class="keyword">\rightharpoondown</span></span><br><span class="line"><span class="keyword">\rightleftharpoons</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\leftharpoonup
\leftharpoondown
\rightharpoonup
\rightharpoondown
\rightleftharpoons
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mapsto</span></span><br><span class="line"><span class="keyword">\leadsto</span></span><br><span class="line"><span class="keyword">\hookleftarrow</span></span><br><span class="line"><span class="keyword">\hookrightarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mapsto
\leadsto
\hookleftarrow
\hookrightarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\longleftarrow</span></span><br><span class="line"><span class="keyword">\longrightarrow</span></span><br><span class="line"><span class="keyword">\longleftrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftarrow</span></span><br><span class="line"><span class="keyword">\Longrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftrightarrow</span></span><br><span class="line"><span class="keyword">\longmapsto</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\longleftarrow
\longrightarrow
\longleftrightarrow
\Longleftarrow
\Longrightarrow
\Longleftrightarrow
\longmapsto
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\xrightarrow</span>&#123;over&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[over]&#123;&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[under]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;over&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\xrightarrow{over}
\xrightarrow[over]{}
\xrightarrow[under]{over}
\xleftarrow[]{over}
\xleftarrow[under]{}
\xleftarrow[under]{over}
\]</span></p>
<h3 id="空格间距">空格间距</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line"><span class="keyword">\sf</span>&#123;紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\it</span>&#123;a<span class="keyword">\!</span>b + ab + a<span class="keyword">\,</span>b + a<span class="keyword">\;</span>b + a<span class="keyword">\ </span>b + a<span class="keyword">\quad</span> b + a<span class="keyword">\qquad</span> b&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\sf{紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格}\\
\it{a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b}\\
\end{gather*}
\]</span></p>
<h3 id="希腊字母表">希腊字母表</h3>
<table>
<thead>
<tr class="header">
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(\gamma\)</span></td>
<td><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\nu\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\varepsilon\)</span></td>
<td><span class="math inline">\(\varrho\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\Delta\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
<td><span class="math inline">\(\varDelta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varPsi\)</span></td>
<td><span class="math inline">\(\zeta\)</span></td>
<td><span class="math inline">\(\kappa\)</span></td>
<td><span class="math inline">\(\xi\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\chi\)</span></td>
<td><span class="math inline">\(\varkappa\)</span></td>
<td><span class="math inline">\(\varsigma\)</span></td>
<td><span class="math inline">\(\Theta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Omega\)</span></td>
<td><span class="math inline">\(\varTheta\)</span></td>
<td><span class="math inline">\(\varSigma\)</span></td>
<td><span class="math inline">\(\varOmega\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\omicron\)</span></td>
<td><span class="math inline">\(\tau\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varphi\)</span></td>
<td><span class="math inline">\(\Lambda\)</span></td>
<td><span class="math inline">\(\Upsilon\)</span></td>
<td><span class="math inline">\(\varLambda\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta\)</span></td>
<td><span class="math inline">\(\theta\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\omega\)</span></td>
<td><span class="math inline">\(\varpi\)</span></td>
<td><span class="math inline">\(\digamma\)</span></td>
<td><span class="math inline">\(\partial\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\imath\)</span></td>
<td><span class="math inline">\(\jmath\)</span></td>
<td><span class="math inline">\(\aleph\)</span></td>
<td><span class="math inline">\(\hbar\)</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">No.</th>
<th style="text-align: center;">Lowercase</th>
<th style="text-align: center;">Uppercase</th>
<th style="text-align: center;">English</th>
<th style="text-align: center;">IPA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td>
<td style="text-align: center;"><span class="math inline">\(A\)</span></td>
<td style="text-align: center;"><span class="math inline">\(alpha\)</span></td>
<td style="text-align: center;"><strong>/'ælfə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\beta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(B\)</span></td>
<td style="text-align: center;"><span class="math inline">\(beta\)</span></td>
<td style="text-align: center;"><strong>/'bi:tə/or/'beɪtə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(gamma\)</span></td>
<td style="text-align: center;"><strong>/'gæmə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(delta\)</span></td>
<td style="text-align: center;"><strong>/'deltə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(E\)</span></td>
<td style="text-align: center;"><span class="math inline">\(epsilon\)</span></td>
<td style="text-align: center;"><strong>/'epsɪlɒn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(Z\)</span></td>
<td style="text-align: center;"><span class="math inline">\(zeta\)</span></td>
<td style="text-align: center;"><strong>/'zi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\eta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(eta\)</span></td>
<td style="text-align: center;"><strong>/'i:tə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(theta\)</span></td>
<td style="text-align: center;"><strong>/'θi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(9\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\iota\)</span></td>
<td style="text-align: center;"><span class="math inline">\(I\)</span></td>
<td style="text-align: center;"><span class="math inline">\(iota\)</span></td>
<td style="text-align: center;"><strong>/aɪ'əʊtə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(10\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td>
<td style="text-align: center;"><span class="math inline">\(K\)</span></td>
<td style="text-align: center;"><span class="math inline">\(kappa\)</span></td>
<td style="text-align: center;"><strong>/'kæpə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(11\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(lambda\)</span></td>
<td style="text-align: center;"><strong>/'læmdə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(12\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(M\)</span></td>
<td style="text-align: center;"><span class="math inline">\(mu\)</span></td>
<td style="text-align: center;"><strong>/mju:/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(13\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\nu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(nu\)</span></td>
<td style="text-align: center;"><strong>/nju:/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(14\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(xi\)</span></td>
<td style="text-align: center;"><strong>/ksi/or/'zaɪ/or/'ksaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(15\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omicron\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omicron\)</span></td>
<td style="text-align: center;"><strong>/əu'maikrən/or/'ɑmɪ,krɑn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(16\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(pi\)</span></td>
<td style="text-align: center;"><strong>/paɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(17\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\rho\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P\)</span></td>
<td style="text-align: center;"><span class="math inline">\(rho\)</span></td>
<td style="text-align: center;"><strong>/rəʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(18\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(sigma\)</span></td>
<td style="text-align: center;"><strong>/'sɪɡmə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(19\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\tau\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(tau\)</span></td>
<td style="text-align: center;"><strong>/tɔ:/or/taʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(20\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(upsilon\)</span></td>
<td style="text-align: center;"><strong>/'ipsilon/or/'ʌpsilɒn/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(21\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(phi\)</span></td>
<td style="text-align: center;"><strong>/faɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(22\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\chi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(X\)</span></td>
<td style="text-align: center;"><span class="math inline">\(chi\)</span></td>
<td style="text-align: center;"><strong>/kaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(23\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(psi\)</span></td>
<td style="text-align: center;"><strong>/psaɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(24\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omega\)</span></td>
<td style="text-align: center;"><strong>/'əʊmɪɡə/or/oʊ'meɡə/</strong></td>
</tr>
</tbody>
</table>
<h3 id="矩阵">矩阵</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">A = <span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
A = \begin{matrix}
a &amp; b\\
c &amp; d
\end{matrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">B = <span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{pmatrix}
a &amp; b\\
c &amp; d
\end{pmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C = <span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
C = \begin{vmatrix}
a &amp; b\\
c &amp; d
\end{vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">D = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
D = \begin{bmatrix}
a &amp; b\\
c &amp; d
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">E = <span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
E = \begin{Vmatrix}
a &amp; b\\
c &amp; d
\end{Vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">F = <span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
F = \begin{Bmatrix}
a &amp; b\\
c &amp; d
\end{Bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[A<span class="keyword">\ </span>b] = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c c c|c&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;13&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>1<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;23&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>2<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;31&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;32&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;33&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>3<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
[A\ b] = 
\begin{bmatrix}
\begin{array}{c c c|c}
a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
\end{array}
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c:c:c&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">d <span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> f <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hdashline</span></span><br><span class="line"> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span> i</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{c:c:c}
a &amp; b &amp; c \\ 
\hline
d &amp; e &amp; f \\
\hdashline
 g &amp; h &amp; i
\end{array}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">L<span class="built_in">_</span>&#123;n<span class="keyword">\times</span> n&#125; = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;1n&#125; <span class="keyword">\\</span> </span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;2n&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span><span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;n2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;nn&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
L_{n\times n} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ 
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ 
\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{bmatrix} -\frac{1}{2}(x^{(1)}(1)+x^{(1)}(2)) &amp; 1 \\  -\frac{1}{2}(x^{(1)}(2)+x^{(1)}(3)) &amp; 1  \\  \vdots &amp; \vdots \\ -\frac{1}{2}(x^{(1)}(17)+x^{(1)}(18)) &amp; 1  \\  \end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
Y = \begin{bmatrix}
x^{(0)}(2) \\ 
x^{(0)}(3)  \\ 
\vdots \\
x^{(0)}(18)  \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\textbf</span>&#123;u&#125;&#125; = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line">=<span class="keyword">\textbf</span>&#123;(B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="keyword">\textbf</span>&#123;)&#125;<span class="built_in">^</span>&#123;-1&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;Y&#125;</span><br><span class="line">=<span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\textbf{u}} = 
\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
=\textbf{(B}^{T}\textbf{B}\textbf{)}^{-1}\textbf{B}^{T}\textbf{Y}
=\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;a&#125;=<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125;= <span class="keyword">\\</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{a}=\\
\hat{b}= \\
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;dx<span class="built_in">^</span>&#123;(1)&#125;&#125;&#123;dt&#125;+<span class="keyword">\hat</span>&#123;a&#125;x<span class="built_in">^</span>&#123;(1)&#125;=<span class="keyword">\hat</span>&#123;b&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{dx^{(1)}}{dt}+\hat{a}x^{(1)}=\hat{b}
\]</span></p>
<h3 id="列式方程组">列式/方程组</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= (x+1)<span class="built_in">^</span>2<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>= x<span class="built_in">^</span>2 + 2x + 1</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= (x+1)^2\\
&amp;= x^2 + 2x + 1
\end{aligned}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">a <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if b&#125;<span class="keyword">\\</span></span><br><span class="line">b <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if a&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(x) = \begin{cases}
a &amp;\text{if b}\\
b &amp;\text{if a}\\
\end{cases}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x + 2y <span class="built_in">&amp;</span>= 1<span class="keyword">\\</span></span><br><span class="line">3x - y <span class="built_in">&amp;</span>= 5</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
x + 2y &amp;= 1\\
3x - y &amp;= 5
\end{aligned}
\end{cases}
\]</span></p>
<h3 id="注释图片">注释图片</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em;</span></span></span><br><span class="line"><span class="string"><span class="tag">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-20210531181704173&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span><br><span class="line"><span class="string"><span class="tag">    display: inline-block;</span></span></span><br><span class="line"><span class="string"><span class="tag">    color: #999;</span></span></span><br><span class="line"><span class="string"><span class="tag">    padding: 2px;&quot;</span>&gt;</span>注释<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center>
<img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/02/20/23-32-35/图片地址" alt="image-20210531181704173"> <br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
注释
</div>
</center>
<h3 id="字体">字体</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字体名</th>
<th style="text-align: center;">样式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="修饰符">修饰符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\theta</span>&#125;</span><br><span class="line"><span class="keyword">\widehat</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;y&#125;</span><br><span class="line"><span class="keyword">\overline</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\tilde</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\widetilde</span>&#123;ac&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\acute</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\check</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\grave</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\dot</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\ddot</span>&#123;a&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\theta}
\widehat{AB}
\\
\bar{y}
\overline{AB}
\\
\tilde{a}
\widetilde{ac}
\\
\bar{a}
\acute{a}
\check{a}
\grave{a}
\\
\dot{a}
\ddot{a}
\]</span></p>
<h3 id="括号">括号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">(</span><br><span class="line"><span class="keyword">\big</span>(</span><br><span class="line"><span class="keyword">\Big</span>(</span><br><span class="line"><span class="keyword">\bigg</span>(</span><br><span class="line"><span class="keyword">\Bigg</span>(</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">[]</span><br><span class="line">&lt;&gt;</span><br><span class="line">|绝对值|</span><br><span class="line"><span class="keyword">\&#123;</span><span class="keyword">\&#125;</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lgroup</span> x <span class="keyword">\rgroup</span></span><br><span class="line"><span class="keyword">\lVert</span> a <span class="keyword">\rVert</span></span><br><span class="line"><span class="keyword">\lceil</span> 2.6 <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> 1.2 <span class="keyword">\rfloor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ulcorner</span></span><br><span class="line"><span class="keyword">\urcorner</span></span><br><span class="line"><span class="keyword">\llcorner</span></span><br><span class="line"><span class="keyword">\lrcorner</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
(
\big(
\Big(
\bigg(
\Bigg(
\\
[]
&lt;&gt;
|绝对值|
\{\}
\\
\lgroup x \rgroup
\lVert a \rVert
\lceil 2.6 \rceil
\lfloor 1.2 \rfloor
\\
\ulcorner
\urcorner
\llcorner
\lrcorner
\end{gather*}
\]</span></p>
<h3 id="偏微分">偏微分</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> u&#125;&#123;<span class="keyword">\partial</span> t&#125;= h<span class="built_in">^</span>2 <span class="keyword">\left</span>( <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; +<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125;+ <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> z<span class="built_in">^</span>2&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2}+ \frac{\partial^2 u}{\partial z^2}\right)
\]</span></p>
<h3 id="图形">图形</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Box</span></span><br><span class="line"><span class="keyword">\square</span></span><br><span class="line"><span class="keyword">\blacksquare</span></span><br><span class="line"><span class="keyword">\triangle</span></span><br><span class="line"><span class="keyword">\triangledown</span></span><br><span class="line"><span class="keyword">\blacktriangle</span></span><br><span class="line"><span class="keyword">\diamond</span></span><br><span class="line"><span class="keyword">\Diamond</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\bigstar</span></span><br><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\bullet</span></span><br><span class="line"><span class="keyword">\bigcirc</span></span><br><span class="line"><span class="keyword">\bigodot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Box
\square
\blacksquare
\triangle
\triangledown
\blacktriangle
\diamond
\Diamond
\star
\bigstar
\circ
\bullet
\bigcirc
\bigodot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\diamondsuit</span></span><br><span class="line"><span class="keyword">\clubsuit</span></span><br><span class="line"><span class="keyword">\heartsuit</span></span><br><span class="line"><span class="keyword">\spadesuit</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\diamondsuit
\clubsuit
\heartsuit
\spadesuit
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\angle</span></span><br><span class="line"><span class="keyword">\measuredangle</span></span><br><span class="line"><span class="keyword">\top</span></span><br><span class="line"><span class="keyword">\bot</span></span><br><span class="line"><span class="keyword">\infty</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\angle
\measuredangle
\top
\bot
\infty
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\checkmark</span></span><br><span class="line"><span class="keyword">\dagger</span></span><br><span class="line"><span class="keyword">\ddagger</span></span><br><span class="line"><span class="keyword">\yen</span></span><br><span class="line"><span class="keyword">\$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\checkmark
\dagger
\ddagger
\yen
\$
\]</span></p>
<h3 id="变换符号">变换符号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%拉氏变换：</span></span><br><span class="line"><span class="keyword">\mathscr</span>&#123;L&#125;&#123;f(t)&#125;</span><br><span class="line"><span class="keyword">\mathcal</span>&#123;L&#125;</span><br><span class="line"><span class="comment">%傅里叶变换：</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathscr{L}\{f(t)\}\quad
\mathcal{L}
\]</span></p>
<h1 id="typroa框图博客不支持">typroa框图（博客不支持）</h1>
<h3 id="流程图">流程图</h3>
<p>语法说明：</p>
<ul>
<li>graph LR： 这一行说明要绘制的图形的方向。
<ul>
<li>LR：从左到右，left to right</li>
<li>RL：从右到左，right to left</li>
<li>TB：从上到下，top to bottom</li>
<li>BT：从下到上，bottom to top</li>
</ul></li>
<li>定义节点：有两种定义节点的方式
<ul>
<li>可以直接输入文字信息作为节点名称: node1</li>
<li>也可以在节点名称前加一个id的形式：id2(node2)，这样后续可以通过id1来引用node1这个节点。</li>
</ul></li>
<li>节点图形形状：
<ul>
<li>默认：方形</li>
<li>(node2）: 圆角</li>
<li>{[node3]) ：椭圆</li>
</ul></li>
<li>条件节点：在绘制流程图中会经常用到条件节点，在Mermaid中也可以实现的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234024945-16458036280891.png" alt="image-20220225234024945"><figcaption aria-hidden="true">image-20220225234024945</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line">para=&gt;parallel: parallel tasks</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;para</span><br><span class="line">para(path1, bottom)-&gt;sub1(right)-&gt;op1</span><br><span class="line">para(path2, top)-&gt;op1</span><br><span class="line">para(path3, top)-&gt;op1</span><br><span class="line">para(path4, top)-&gt;op1</span><br><span class="line">para(path5, top)-&gt;op1</span><br><span class="line">para(path6, top)-&gt;op1</span><br><span class="line">para(path7, top)-&gt;op1</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234115328-16458036772432.png" alt="image-20220225234115328"><figcaption aria-hidden="true">image-20220225234115328</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学</title>
    <url>/2022/02/27/16-41-33/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="前言">前言</h3>
<p>本书主要参考尼曼（Donald A. Neamen）的《电子电路分析与设计（第四版）》（Microelectronics: Circuit Analysis And Design Forth Edition）写成。</p>
<h2 id="半导体器件及其基本应用">半导体器件及其基本应用</h2>
<h3 id="半导体">半导体</h3>
<p>在电路课和物理课上我们已经学习了一些电子器件，例如最典型的器件——电阻器。电阻器是导体，其最重要的性质“电阻”表示了导体对于电流的阻碍性质。除此之外我们还学习了电容和电感；电感的性质存在于线圈之中，线圈是使用导体制成的；电容则是导体极板中间夹着一个绝缘体介质形成。如此归纳，我们会发现在之前的课程之中，我们了解的范畴始终存在于导体和绝缘体之中，而半导体材料制作而成的器件却从未被提及。所以，在“半导体”这一节中，我们将注意力集中在半导体上，从研究半导体自身的性质开始，最终我们将得到一个简单的半导体器件。</p>
<p>正式开始本节前，我们简单地回顾一下中学的知识，以下这些是作者默认读者已经了解了的知识。</p>
<ul>
<li>导体中存在大量可以自由移动的电子，称之为自由电子（free electron）。自由电子在受到外电场或外磁场的作用时，能够在物质中自由移动。</li>
<li>导体中自由电子的定向移动形成了电流，电流（current）的定义式为 <span class="math inline">\(i=\frac{dq}{dt}\)</span>。</li>
<li>载流子（charge carrier）指可以自由移动的带有电荷的物质微粒，是物质中电流形成的原因，导体中的载流子是电子。</li>
<li>在半导体中存在两种载流子——电子（electron）和空穴（hole）。空穴是电子移动后留下的空位，从物理模型上可以将空穴看作是正电子。在半导体中，电子和空穴两种载流子共同形成半导体中的电流。</li>
</ul>
<h4 id="本征半导体intrinsic-semiconductor">本征半导体（intrinsic semiconductor）</h4>
<blockquote>
<p>本征半导体是指纯净（pure）的半导体</p>
</blockquote>
<p>本征半导体的概念是我们应当格外注意的，因为这不是一个偏日常化和口语化的词语，但是在这里它的含义却是十分简单——本征，不过就是纯净不含杂质的意思。</p>
<p>强调材料的纯度似乎是一件奇怪的事情，因为常识中我们通常认为提纯是必须的，无需额外强调的。例如我们不会强调一个钢筋的纯度，但是我们知道</p>
<p>本征半导体是指纯净的半导体，强调这个词似乎暗示着有一种不纯净的半导体的存在，并且这种不纯净的半导体的存在是十分有必要的。</p>
<h3 id="二极管及其基本电路">二极管及其基本电路</h3>
<p>TODO</p>
<h3 id="三极管及其基本电路">三极管及其基本电路</h3>
<p>TODO</p>
<h3 id="场效应管及其基本电路">场效应管及其基本电路</h3>
<p>TODO</p>
<h2 id="模拟电子技术">模拟电子技术</h2>
<p>TODO</p>
<h2 id="数字电子技术">数字电子技术</h2>
<p>TODO</p>
<p>运算放大器电路</p>
<p>分析顺序</p>
<ul>
<li>图像</li>
<li>公式</li>
<li>结论</li>
</ul>
<ol type="1">
<li><p>反相放大电路</p>
<ul>
<li><p>反相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1249-16473232199221.PNG" alt="IMG_1249" style="zoom: 25%;"></p></li>
<li><p>反相放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p>假设运算放大器是理想的，即</p>
<ul>
<li>开环增益 <span class="math inline">\(A_{od}=\infty\)</span>：故输入信号 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是相等的。且由于 <span class="math inline">\(v_2\)</span> 与地面连接，故 <span class="math inline">\(v_2\)</span> 是“接地”，而 <span class="math inline">\(v_1\)</span> 是“虚地”。</li>
<li>输入阻抗大小为 <span class="math inline">\(\infty\)</span>：流入运算放大器的电流为 <span class="math inline">\(0\)</span> 。</li>
</ul>
<p>理想运放约束+基尔霍夫定律可得： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{v_{i_1}-v_1}{R_1}=\frac{v_1-v_o}{R_2}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<ul>
<li>对于理想运放，闭环电压增益是运放外电阻比值的函数，与运放内部的参数无关。</li>
<li>增益中的负号表示 “反相” ，是反相放大电路名字的由来。</li>
<li>反相放大电路中没有耦合电容（就是电容，作用是耦合所以叫耦合电容），因此反相放大电路可以放大直流电压信号。</li>
</ul></li>
</ul></li>
<li><p>反相放大电路扩展——带 T 型网络的放大电路</p>
<ul>
<li><p>作为改进方案被提出的原因：</p>
<p>反相放大电路的增益 <span class="math inline">\(A_v\)</span> 为 <span class="math inline">\(-\frac{R_2}{R_1}\)</span>，那么如果我们的设计目标是设计一个闭环增益 <span class="math inline">\(A_v=-100\)</span> 且输入电阻 <span class="math inline">\(R_i=R_1=50k\Omega\)</span> 的反相放大电路。于是，反馈电阻 <span class="math inline">\(R_2\)</span> 就必须是 <span class="math inline">\(5M\Omega\)</span>。然而，这个电阻值对大多数实际电路来说太大了。为了解决这个问题我们提出了作为改进方案的带 T 型网络的放大电路。</p></li>
<li><p>带 T 型网络的放大电路的电路图如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1258.PNG" alt="IMG_1258" style="zoom:25%;"></p></li>
<li><p>设 <span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span> 和 <span class="math inline">\(R_4\)</span> 三个电阻的公共节点处电势为 <span class="math inline">\(v_x\)</span>，则: <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;i_2+i_3=i_4\\\\
&amp;\frac{v_1-v_x}{R_2}+\frac{v_x-v_o}{R_3}=\frac{v_x}{R_4}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<p>使用带 T 型网络的放大电路，可以在使用合理大小电阻的情况下获得更大的增益。</p></li>
</ul></li>
<li><p>同相放大电路；</p>
<ul>
<li><p>同相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1253-16473270320863.PNG" alt="IMG_1253" style="zoom: 25%;"></p></li>
<li><p>同相放大电路增益 <span class="math inline">\(A_v=\frac{R_2}{R_1}+1\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\begin{cases}
v_-=v_+=v_i\\\\
\frac{0-v_-}{R1}=\frac{v_--v_o}{R_2}\\
\end{cases}\\\\
&amp;get\quad A_v=\frac{v_o}{v_i}=\frac{R_2}{R_1}+1
\end{aligned}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>电压跟随器：</p>
<ul>
<li><p>电压跟随器连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1246.PNG" alt="IMG_1246" style="zoom:25%;"></p></li>
<li><p>电压跟随器增益 <span class="math inline">\(A_v\)</span>：</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>求和放大电路：</p>
<ul>
<li><p>求和放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1252.PNG" alt="IMG_1252" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}\)</span>：</p>
<p><span class="math display">\[
\sum_{j=1}^{n}\frac{v_{i_j}-0}{R_i}=\frac{0-v_o}{R_f}\\
get\quad v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>差分放大电路：</p>
<ul>
<li><p>差分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1244.PNG" alt="IMG_1244" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})\)</span>：</p>
<p>$$</p>
<span class="math display">\[\begin{aligned}
&amp;if\quad v_{i_2}=0,\;v_{i_1}\not=0\\

&amp;then\quad v_{o_1}=-\frac{R_2}{R_1}v_{i_1}\\\\\\

&amp;if\quad v_{i_2}\not=0,\;v_{i_1}=0\\

&amp;then\quad v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}\\\\\\

&amp;so\quad v_o=v_{o_1}+v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}-\frac{R_2}{R_1}v_{i_1}\\

&amp;To\quad satified\quad when\quad v_{i_1}=v_{i_2},v_o=0\,;so\quad \frac{R_4}{R_3}=\frac{R_2}{R_1}\\

&amp;Finally\quad v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})
\end{aligned}\]</span>
<p>$$</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>积分放大电路：</p>
<ul>
<li><p>积分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1254.PNG" alt="IMG_1254" style="zoom:25%;"></p></li>
<li><p>积分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=V_C-\frac{1}{RC}\int_{0}^{t}v_i(\tau)d\tau
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>微分放大电路：</p>
<ul>
<li><p>微分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1251.PNG" alt="IMG_1251" style="zoom:25%;"></p></li>
<li><p>微分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-RC\frac{dv_{i}}{dt}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>对数放大电路：</p>
<ul>
<li><p>对数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1247.PNG" alt="IMG_1247" style="zoom:25%;"></p></li>
<li><p>对数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-V_Tln\left(\frac{v_i}{I_SR_1}\right)
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>指数放大电路：</p>
<ul>
<li><p>指数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1257.PNG" alt="IMG_1257" style="zoom:25%;"></p></li>
<li><p>指数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-I_SR\cdot e^{v_i/V_T}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>仪用放大电路：</p>
<ul>
<li><p>仪用放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1256.PNG" alt="IMG_1256" style="zoom:25%;"></p></li>
<li><p>仪用放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=\frac{R_4}{R_3}\left(1+\frac{2R_2}{R_1}\right)(v_{i_2}-v_{i_1})
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
</ol>
<h2 id="集成电路偏置">集成电路偏置</h2>
<p>使用分立电子元器件对晶体管放大电路进行偏置时，我们通常使用的是分压电阻网络。在集成电路设计中，电阻的集成需要比晶体管更大的面积，因此我们更希望通过晶体管来配置放大电路。在接下来的设计中我们可以看到，晶体管可以构成恒流源和负载器件。</p>
<p>集成电路偏置和有源负载这一章节学习了在设计集成电路中需要使用到的<strong>晶体管恒流源——镜像电流源（Current Mirror）</strong>和<strong>晶体管电阻（负载）——有源负载</strong></p>
<p>关于集成电路的部分放到下一阶段学习吧</p>
<p>一个设计良好的电流源电路，必须同时满足如下这四点要求：</p>
<ul>
<li>能够输出符合要求的直流电流；</li>
<li>温度稳定性更好；</li>
<li>受到电源电压等因素的影响较小；</li>
<li>输出电阻要尽可能更大；</li>
</ul>
<p>如果一个电流源能够同时满足上述这些要求，那么就可以将其等效为下面的<strong>理想电流源</strong>：<img src="/2022/02/27/16-41-33/image-20220316212039647-16474368536751.png" alt="image-20220316212039647" style="zoom:25%;"></p>
<p>晶体管和场效应管等有源元件，在放大区的输出电流几乎不受输出电压的影响，展现出恒流特性：</p>
<h2 id="差分和多级放大电路">差分和多级放大电路</h2>
<p>本章介绍的是主要内容是一种多晶体管电路——差分放大电路。与之前理想运放一节不同的是，这里的差分放大电路是由基本的晶体管构成的电路</p>
<p>差分放大电路是模拟电路的基本单元，既是几乎所有运放的输入级，也是高速数字逻辑电路的基础。</p>
<p>差分放大电路为</p>
<h2 id="section"></h2>
<h3 id="施密特触发器">施密特触发器</h3>
<h4 id="比较器">比较器</h4>
<h4 id="施密特触发器-1">施密特触发器</h4>
<h4 id="section-1"></h4>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学笔记</title>
    <url>/2022/02/21/08-25-17/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="基本概念">基本概念</h3>
<p>组态：</p>
<ul>
<li>定义：晶体管接入电路的方法（晶体管接入电路的形态）。</li>
<li>种类：共基组态（共基极的接入方法）、共射组态和共集组态</li>
<li>F&amp;Q：
<ul>
<li>共"的含义——共在组态的概念中指端口共用。
<ul>
<li>进一步解释端口共用："将 BJT 晶体管看作一个双端口网络模型进行分析时，需要输入输出各两个端口，而晶体管有 3 个端口，因此需要一个端口共用。"</li>
</ul></li>
<li>在组态概念下我们要讨论的问题是什么：
<ul>
<li>首先明确组态概念下讨论的是晶体管本身的伏安特性，谈论组态时是不含不涵盖除晶体管之外的其他元器件的。</li>
<li>不同组态下晶体管展现出的不同的输入输出特性（伏安特性）是我们研究的重点</li>
</ul></li>
</ul></li>
</ul>
<p>电路负载线：</p>
<ul>
<li>定义：电路负载线表征电路对元器件施加的约束，这个约束表现为一种伏安关系</li>
<li>方法：负载线可以由基本的电路定律得到（如基尔霍夫定律）</li>
<li>tips：使用电路定律得到的负载线公式可以整理成针对于某一负载伏安关系的一次函数: <span class="math inline">\(i=k v+b\)</span></li>
</ul>
<p>器件的伏安特性与</p>
<p>耦合：</p>
<ul>
<li>定义：耦合就是连接的意思</li>
<li>耦合电容：晶体管电路中的耦合电容起到连接直流源与交流源的作用</li>
</ul>
<p>偏置与静态工作点：</p>
<ul>
<li><p>偏置的含义：偏置是一种利用直流电压为电路设置固定直流电流和电压的广义称谓</p></li>
<li><p>讨论偏置时的研究对象我们的研究对象不是电子元器件，而是某一电路</p></li>
<li><p>偏置操作不但在"电路网络（黑箱）"外加入了直流电源，而且配合了电阻器件进行约束。</p>
<ul>
<li>以晶体管的偏置为例：直流电源与电阻一起构成了晶体管电路，该对晶体管工作范围进行了约束，这种约束可以使用负载线来表示，并且可以通过数学形式变化将负载线与晶体管的输入输出特征曲线放在同一坐标轴下得到一个交点，称为静态工作点</li>
</ul></li>
<li><p>静态工作点的含义：</p>
<ul>
<li>偏置时设置的固定的电流与电压被称为静态工作点，标记为 Q</li>
<li>静态工作点由元器件伏安特性和电路伏安约束共同确定，对于特定的器件，静态工作点仅由电路的配置决定。</li>
<li>对于晶体管，配置不同的静态工作点有两个目标
<ul>
<li>第一个目标时让晶体管工作在特定的状态，在模拟电子技术中我们希望让晶体管工作在放大的工作状态</li>
<li>第二个目标是针对线性的放大工作范围，我们还要挑选一个合适的位置，不能使得放大的信号失真</li>
</ul></li>
</ul></li>
<li><p>晶体管放大要求（偏置要求）</p>
<ul>
<li><p>输入电压应该超过晶体管导通电压。</p>
<p>The input voltage should exceed <strong>cut-in voltage</strong> for the transistor to be <strong>ON</strong>.</p></li>
<li><p>BJT应该在有源区，作为一个放大器。</p>
<p>The BJT should be in the <strong>active region</strong>, to be operated as an <strong>amplifier</strong>.</p></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{gather*}
\begin{aligned}
I_C&amp;=I_{\sf{多子电流}}+I_{\sf{少子电流}}\\
   &amp;=\alpha I_E+I_{CBO}\\
   &amp;=\alpha (I_B+I_C)+I_{CBO}\\
\end{aligned}
\Rightarrow
I_C=\frac{\alpha}{1-\alpha}I_B+\frac{1}{1-\alpha}I_{CBO}=\beta I_B+I_{CEO}
\end{gather*}
\]</span> <span class="math inline">\(I_E=I_se^{v_{BE}/V_T}\)</span></p>
<p><span class="math inline">\(I_C=\alpha I_E+I_{CBO}\)</span></p>
<h3 id="稳定化stabilization">稳定化（Stabilization）</h3>
<p>为了让晶体管</p>
<blockquote>
<p>使操作点独立于温度变化或晶体管参数变化的过程被称为稳定。</p>
<p>The process of making the operating point independent of temperature changes or variations in transistor parameters is known as <strong>Stabilization</strong>.</p>
</blockquote>
]]></content>
      <tags>
        <tag>电子学</tag>
      </tags>
  </entry>
  <entry>
    <title>电路基础</title>
    <url>/2022/02/27/16-42-00/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab收集数据绘制箱型图</title>
    <url>/2022/02/25/08-07-35/</url>
    <content><![CDATA[<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">使用手册：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据文档：(Data Text) 软件生成的文本文档，例如：qjy_q1-1_20210827181142。</span></span><br><span class="line"><span class="comment">数据文件夹：(Date File) 使用软件时创建的文件夹，例如：20210827；约定：数据文件夹的名称按“年月日”连续数字来命名，不按照约定命名可能导致读取异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设置文件夹：</span></span><br><span class="line"><span class="comment">首先设置matlab的“当前文件夹”为包含“数据文件夹”的文件夹</span></span><br><span class="line"><span class="comment">根据提示输入“数据文件夹”名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>;</span><br><span class="line">str = input(prompt);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);<span class="comment">%读入“数字”并转化为“文件夹名”</span></span><br><span class="line"></span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name=DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);<span class="comment">%修改当前文件夹为“数据文件夹”</span></span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);<span class="comment">%以cell形式提取文件的第一列</span></span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];<span class="comment">%提取有用信息</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">==================</span></span><br><span class="line"><span class="comment">J_sc=mid(3,1);</span></span><br><span class="line"><span class="comment">V_oc=mid(8,1);</span></span><br><span class="line"><span class="comment">FF=mid(9,1);</span></span><br><span class="line"><span class="comment">Eta = mid(10,1);</span></span><br><span class="line"><span class="comment">===================</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);<span class="comment">%将元胞数组转化为普通数组(单引号字符串的数组形式会自动合并)</span></span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取字符串中的数字并以元胞数组形式储存</span></span><br><span class="line">	usfull_data_num=string(C_usfull_data_num);<span class="comment">%将元胞数组转换为普通(双引号字符串)数组</span></span><br><span class="line">	usfull_data = str2double(usfull_data_num);<span class="comment">%将字符串转化为数字</span></span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box11_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line"> X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line"> Y=vertcat(y1,y2,y3);</span><br><span class="line"> boxplot(X,Y);</span><br><span class="line"></span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line">judge=input(<span class="string">&#x27;绘图or生成表格:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> judge == <span class="string">&#x27;绘图&#x27;</span></span><br><span class="line">	<span class="comment">%查询片的数量:</span></span><br><span class="line">	PIECE=input(<span class="string">&#x27;片的数量？\n输入示例:8\n&#x27;</span>);</span><br><span class="line">	CELL=input(<span class="string">&#x27;电池的数量？\n输入示例:[9 9 9 9 9 9 9 9]\n&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%定义分类方式:</span></span><br><span class="line">	IpMid=input(<span class="string">&#x27;输入分类方式，将作为箱型图的X轴.\n输入示例:2-3石墨盒 1-2石墨盒\n&#x27;</span>,<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">	class_way = string(split(IpMid));</span><br><span class="line">	m=<span class="built_in">length</span>(class_way);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%对应分类方式与片的关系:</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		fprintf(<span class="string">&#x27;第%d个条件对应的片的序号\n输入示例:[1 3 5]&#x27;</span>,n);</span><br><span class="line">		Part(n,:) = &#123;input(<span class="string">&#x27;\n&#x27;</span>)&#125;;</span><br><span class="line">		Length(n,:)=<span class="built_in">length</span>(Part&#123;n,:&#125;);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">%画图</span></span><br><span class="line">	<span class="keyword">for</span> m=<span class="number">1</span>:CELL(<span class="number">1</span>)</span><br><span class="line">		load_data_plot(<span class="number">1</span>,m) = J_sc(m);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">2</span>:PIECE</span><br><span class="line">		<span class="keyword">for</span> m=<span class="number">1</span>:CELL(n)</span><br><span class="line">			load_data_plot(n,m) = J_sc((n<span class="number">-1</span>)*CELL(n<span class="number">-1</span>)+m);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		<span class="keyword">for</span> q=<span class="number">1</span>:Length</span><br><span class="line">			data_plot(n,:)=&#123;load_data_plot(Part&#123;n,<span class="number">1</span>&#125;(<span class="number">1</span>,q),:)&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Plot_title=input(<span class="string">&#x27;输入图像的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	X_name=<span class="string">&#x27;条件&#x27;</span>;</span><br><span class="line">	Y_name=input(<span class="string">&#x27;输入Y轴的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	<span class="keyword">switch</span> Y_name</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;J_sc&#x27;</span></span><br><span class="line">			a=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;V_oc&#x27;</span></span><br><span class="line">			a=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;FF&#x27;</span></span><br><span class="line">			a=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Eta&#x27;</span></span><br><span class="line">			a=<span class="number">4</span>;</span><br><span class="line">		<span class="keyword">otherwise</span></span><br><span class="line">			warning(<span class="string">&#x27;输入错误，请按照要求输入。&#x27;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	title(Plot_title);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">elseif</span> judge == <span class="string">&quot;生成表格&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&quot;输入错误,请输入“绘图”或者“生成表格”。&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Jsc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Voc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of FF&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Eta&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2022/02/25/11-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1 id="蓝桥杯">蓝桥杯</h1>
<figure>
<img src="/2022/02/25/11-07-35/Users\qjy\Desktop\image-20211030223845558.png" alt="image-20211030223845558"><figcaption aria-hidden="true">image-20211030223845558</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;			<span class="comment">// reg52.h 中没有定义 P4 寄存器故自己定义</span></span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “stc15f2k60s2.h”	<span class="comment">// 该文件已定义 P4 寄存器故无需重复定义</span></span></span><br><span class="line"> </span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2 的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<h3 id="基础编程位运算">基础编程——位运算</h3>
<h4 id="基本位运算符">基本位运算符</h4>
<p>取反、按位与、按位或、按位异或</p>
<h4 id="基本位运算">基本位运算</h4>
<h5 id="掩码">掩码</h5>
<p>讲各个位的值初始化为想要的样子，对于74HC138译码器，我们初始化为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initial value is not sure</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"><span class="comment">//P2 = 0001 1111</span></span><br></pre></td></tr></table></figure>
<p>通过掩码 0x1f 我们可以让 38 译码器的 ABC 三个引脚初始化为 000 。</p>
<h5 id="设置位">设置位</h5>
<p>通过或运算符可以设置各个位的值，对于 38 译码器，我们想要使之使能Y4，需要设置 ABC 为 001 ，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set P2 = 0001 1111</span></span><br><span class="line">P2 |= <span class="number">0x80</span>;</span><br><span class="line"><span class="comment">//get P2 = 1000 1111</span></span><br></pre></td></tr></table></figure>
<h5 id="关闭位">关闭位</h5>
<p>关闭 P2 的</p>
<h3 id="led">LED</h3>
<h4 id="题目要求">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现LED的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍然后熄灭；</p>
<p>接着依次点亮LED指</p>
<p>示灯；</p>
<p>最后依次熄灭指示灯；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点">考点：</h4>
<p>74HC138、74HC573和74HC02三个数字IC；C51开发方式——IO口扩展</p>
<h4 id="笔记">笔记：</h4>
<p>​ C51开发的两种方式：IO口扩展和存储器映射扩展</p>
<p>​ 跳线帽<span class="math inline">\(J3\)</span>：WR引脚，存储器映射扩展；接地，IO扩展</p>
<p><img src="/2022/02/25/11-07-35/image-20211030180455602.png" alt="image-20211030180455602" style="zoom: 50%;"></p>
<p>三八译码器：三个输入控制八路互斥的低有效输出——七位高一位低</p>
<p>使用方法：</p>
<ul>
<li>ABC三个输入端控制Y0-Y7八个输出端</li>
<li>输入端输入的三位二进制数的十进制形式对应Y的编号
<ul>
<li>如<span class="math inline">\(CBA=(100)_2=(4)_{10} \Rightarrow Y(4)\)</span></li>
</ul></li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180601344.png" alt="image-20211030180601344" style="zoom:50%;"></p>
<p>锁存器：八路三态输出的非反转透明锁存器</p>
<p>使用方法：</p>
<ul>
<li>控制引脚：LE，低电平锁存，高电平导通</li>
<li>导通时D和Q的电平一致</li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180521683.png" alt="image-20211030180521683" style="zoom:50%;"></p>
<p>使用方法：</p>
<ul>
<li><p>使用IO扩展，跳线帽设置为为GND</p></li>
<li><p><span class="math inline">\((WR-&gt;GND)J13\)</span></p>
<p><span class="math inline">\(74HC138(Y4)-&gt;(Y4)74HC02(Y4C)-&gt;(LE)M74HC573MIR\)</span></p>
<p><span class="math inline">\(\sf{使用}:WR=0;\,Y4=0\,\sf{ 时},\, Y4C=1\)</span></p></li>
</ul>
<p>左移运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	P0 = (<span class="number">0xff</span> &lt;&lt;i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; P0 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：510 1020 2040 4080 8160 16320 32640 65280</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay100ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LEDrunning</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="comment">//通过配置三八译码器使得锁存器导通，此时单片机P0口电压直接对应LED灯的电压</span></span><br><span class="line">    HC138_C = <span class="number">1</span>;</span><br><span class="line">    HC138_B = <span class="number">0</span>;</span><br><span class="line">    HC138_A = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将P0口全部设为低电平，点亮所有LED灯</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0x00</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        P0 = <span class="number">0xff</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0xff</span>&lt;&lt;i;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = ~(<span class="number">0xff</span>&lt;&lt;i);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LEDrunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蜂鸣器和继电器">蜂鸣器和继电器</h3>
<h4 id="题目要求-1">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现蜂鸣器与继电器的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍后熄灭；</p>
<p>接着依次点亮LED指示灯；</p>
<p>继电器吸合一会后断开；</p>
<p>然后依次熄灭LED指示灯；</p>
<p>蜂鸣器鸣叫会后关闭；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点-1">考点：</h4>
<p>蜂鸣器和继电器的使用；继续使用上面的三个IC；ULN2003达林顿管——一个驱动管</p>
<h4 id="笔记-1">笔记：</h4>
<p>针脚选择BTN</p>
<h4 id="代码-1">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/11-07-35/image-20211030203349176.png" alt="image-20211030203349176" style="zoom:50%;"></p>
<h3 id="独立按键">独立按键</h3>
<h4 id="题目要求-2">题目要求：</h4>
<blockquote>

</blockquote>
<h4 id="考点-2">考点：</h4>
<ul>
<li>独立按键；矩阵键盘</li>
<li>读取IO口电平</li>
<li>按键消抖</li>
</ul>
<h4 id="笔记-2">笔记：</h4>
<p>根据原理图可知：</p>
<p><img src="/2022/02/25/11-07-35/image-20211030204322671.png" alt="image-20211030204322671" style="zoom: 67%;"></p>
<p><span class="math inline">\(J5\)</span>接2、3引脚，此时<span class="math inline">\(P30-P33\)</span>四个单片机IO口分别接<span class="math inline">\(S7-S4\)</span>四个独立按键再接<span class="math inline">\(GND\)</span></p>
<h4 id="代码-2">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit s7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit s6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit s5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit s4 = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit L1 = P0^<span class="number">0</span>;</span><br><span class="line">sbit L2 = P0^<span class="number">1</span>;</span><br><span class="line">sbit L3 = P0^<span class="number">2</span>;</span><br><span class="line">sbit L4 = P0^<span class="number">3</span>;</span><br><span class="line">sbit L5 = P0^<span class="number">4</span>;</span><br><span class="line">sbit L6 = P0^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SelecHC138(<span class="number">4</span>);<span class="comment">//控制锁存器打开LED灯</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ScanKeys_Alone();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数码管">数码管</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegTab[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,</span><br><span class="line">                             <span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegBuf[]=&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>数码管延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_dtms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">10</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时刷新频率可以到100Hz，即0.01ms</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_tms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时延时大约1ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===============初始化定时器0==================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Timer0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        TMOD = <span class="number">0x01</span>;                    <span class="comment">//16位定时模式</span></span><br><span class="line">        TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;      <span class="comment">//定时50ms</span></span><br><span class="line">        TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">        ET0 = <span class="number">1</span>;                       <span class="comment">//使能定时器T0中断</span></span><br><span class="line">        EA = <span class="number">1</span>;                       <span class="comment">//使能总中断        </span></span><br><span class="line">        TR0 = <span class="number">1</span>;                       <span class="comment">//启动定时器T0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*============定时器0中断服务函数===============*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeviceTimer0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">1</span>;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">    P0=<span class="number">0xff</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EGplay(i);</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器计算">定时器计算</h3>
<p><span class="math display">\[
10ms=0.01s\\
\sf{计算机器周期数目：}\\x\frac{12}{11059200}=0.01\\
get\:x=9216=0x2400\\
so\:TH0=0x24,TL0=0x00;
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_0_ini</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD = <span class="number">0x01</span>;</span><br><span class="line">	TH0 = <span class="number">0xfc</span>;</span><br><span class="line">	TL0 = <span class="number">0x67</span>;</span><br><span class="line">	TR0=<span class="number">1</span>;</span><br><span class="line">	TF0=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">timer_0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span><span class="comment">//@ t (ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> timer_0_tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(TF0==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TF0=<span class="number">0</span>;</span><br><span class="line">        TH0 = <span class="number">0xfc</span>;</span><br><span class="line">		TL0 = <span class="number">0x67</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=t)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            timer_0_tag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> timer_0_tag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> timer_0_tag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通信">通信</h3>
<p><img src="/2022/02/25/11-07-35/image-20211116001027941.png" alt="image-20211116001027941"></p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑设计基础</title>
    <url>/2022/03/09/16-14-26/</url>
    <content><![CDATA[<h1 id="logic-design">Logic Design</h1>
<h3 id="数制">数制</h3>
<p>数制是用一组固定符号和统一规则来表示数值的方法，通常包含基数和位权两个基本要素。其中<strong>基数</strong>是指使用数码的个数，例如：二进制的基数为<code>2</code>，十进制的基数为<code>10</code>。<strong>位权</strong>是指数制某位所表示的数值权重的大小，例如：十进制数<code>123</code>，<code>1</code>的位权是<code>100</code>，<code>2</code>的位权是<code>10</code>，<code>3</code>的位权是<code>1</code>。二进制数<code>1011</code>，从左至右<code>1</code>、<code>0</code>、<code>1</code>、<code>1</code>的位权依次是<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>。常用的数制有<strong>二</strong>、<strong>八</strong>、<strong>十</strong>、<strong>十六</strong>四种进制，书写时可以在相应数值尾部添加字母<strong>B</strong>、<strong>O</strong>、<strong>D</strong>、<strong>H</strong>或者下标<strong>2</strong>、<strong>8</strong>、<strong>10</strong>、<strong>16</strong>进行标识，计算机<strong>传输和保存数据</strong>通常使用的是<strong>二进制</strong>。</p>
<h3 id="码制">码制</h3>
<p>码制是计算机存储、传输数据所使用的编码规则；其中原码、反码、补码是计算机设备保存数值类型数据的编码方式，ASCII 与 Unicode 属于保存字符类型数据的编码格式；而 BCD 编码、格雷码则主要用于设备之间的数据<strong>传输以及转换</strong>。</p>
<blockquote>
<p>BCD 码的优点在于格式转换容易，十进制数值表达精度较高；缺点是增加了电路进行算术运算的复杂度，并且存储效率较低。</p>
</blockquote>
<h3 id="数字系统">数字系统</h3>
<p>数字系统设计大致分为三个方面</p>
<ul>
<li>系统设计
<ul>
<li>系统设计是将一个数字系统划分为多个子系统进行设计。</li>
</ul></li>
<li>逻辑设计
<ul>
<li>逻辑设计是将多个逻辑功能块互联实现特定功能</li>
</ul></li>
<li>电路设计</li>
</ul>
<p>数字系统的中许多子系统以开关电路的形式存在，开关电路具有一个或多个输入端，一个或多个输出端，输入输出端都取离散值的电路。开关电路一般使用门电路来描述，使用布尔代数进行分析。开关电路有两种——组合电路和时序电路。</p>
<p>开关电路分类：</p>
<ul>
<li>组合电路
<ul>
<li>组合电路中输出值仅与当前输入值有关</li>
<li>组合电路的基本构成是逻辑门，逻辑设计就是将逻辑门相互连接起来以便将电路的输入信号转化为预期的输出信号。</li>
</ul></li>
<li>时序电路
<ul>
<li>时序电路中输出值不仅与当前输入值有关，也与之前的输入值有关；可以认为时序电路具有记忆功能</li>
<li>时序电路的基本存储元件（存储之前的值）是触发器，触发器与逻辑门一起组成时序电路——如计数器和寄存器。</li>
</ul></li>
</ul>
<h3 id="布尔代数">布尔代数</h3>
<p>逻辑设计课程中我们使用二值布尔代数来设计开关电路。我们使用布尔变量来表示电路的输入和输出，其中布尔变量代表逻辑电路中的两种不同状态——</p>
<p>普通代数中的<strong>交换律</strong>和<strong>结合律</strong>同样可以在布尔代数中使用。</p>
<p>布尔代数中的交换律表明开关的位置（出现次序）不会影响最终结果，结合律表明开关导通的次序不会影响最终结果。</p>
<p>在布尔代数中，分配律有两种形式：</p>
<ul>
<li><p>一种是普通的分配律：<span class="math inline">\(X(Y+Z)=XY+XZ\)</span></p>
<p>​ 与运算可以分配在或运算上</p>
<p>​ 去和括号内相乘</p></li>
<li><p>另一种被称作第二分配律：<span class="math inline">\(X+(YZ)=(X+Y)(X+Z)\)</span></p>
<p>​ 或运算可以分配在与运算上</p>
<p>​ 去和括号内相加</p></li>
</ul>
<p>很多布尔代数表达式可以使用一个更简单的表达式替换，每个布尔代数表达式</p>
<h2 id="数字电路概念">数字电路概念</h2>
<h3 id="高阻态">高阻态</h3>
<p>高阻抗状态（<em>High impedance</em>）表示电路中的某个节点具有相对电路中其它点更高的阻抗，电路分析时通常将高阻态作为开路理解。即可以将其视为输出/输入电阻极大，极限状态可以认为是悬空（<em>断路</em>）的状态，高阻态通常使用字母<strong>Z</strong>表示。</p>
<h3 id="三态门">三态门</h3>
<p>数字电路中的三态逻辑（<em>Three-state logic</em>）是指其输出既可以是代表<code>0</code>和<code>1</code>的高低电平，也可以是其特有的高阻抗状态（<em>相当于隔断状态，电阻极大，类似于开路</em>）。</p>
<p>具有高电平、低电平、高阻态三种状态的元器件称为三态器件，三态器件都通过一个控制使能端 B 来控制整个三态门电路的通断。当使能端高电平有效时，三态器件可以正常的<code>0</code>或<code>1</code>输出，当使能端低电平无效时，三态电路将会输出高阻态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">输入端 A</th>
<th style="text-align: left;">使能端 B</th>
<th style="text-align: left;">输出端 C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>X</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>Z</code></td>
</tr>
</tbody>
</table>
<h3 id="组合时序逻辑电路">组合/时序逻辑电路</h3>
<ul>
<li><strong>组合逻辑电路</strong>（<em>Combinational Logic Circuit</em>），其任一时刻的稳态输出仅与该时刻输入的变量取值有关，而与该时刻之前输入的变量取值无关。组合电路主要由各种逻辑门（<code>半加器</code>、<code>全加器</code>、<code>半减器</code>、<code>全减器</code>、<code>数据选择器</code>、<code>数据分配器</code>、<code>编码器</code>、<code>译码器</code>）组成，电路中没有记忆元件和反馈线。</li>
<li><strong>时序逻辑电路</strong>（<em>Sequential Logic Circuit</em>）任意时刻的稳态输出不仅取决于当前输入，还与前一时刻输入的状态有关，换而言之，时序逻辑电路必须拥有特定的储存元件来保存前一次的输入状态。因此，时序逻辑电路除包含有组合逻辑电路以外，还必须含拥有存储信息能力的电路（<code>触发器</code>、<code>寄存器</code>、<code>计数器</code>）。</li>
</ul>
<h3 id="gpio">GPIO</h3>
<p><strong>通用输入输出</strong>（<em>General-purpose input/output</em>），功能类似于 8051 单片机的 P0 到 P3 口，引脚输出的高低电平可由开发人员读写相应寄存器进行控制。该接口有时也称为<strong>总线扩展器</strong>，当开发板接口不够用时，可以通过转接板将其扩展为<code>I²C</code>、<code>SPI</code>等其它串行接口。</p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>双轮自平衡小车制作指南</title>
    <url>/2022/02/25/19-20-54/</url>
    <content><![CDATA[<h1 id="双轮自平衡小车制作指南">双轮自平衡小车制作指南</h1>
<h3 id="整体介绍">整体介绍</h3>
<p>这将会是我制作自平衡小车的一个开始，本文的目标在于设计一个简单的自平衡小车，实现自平衡站立和行进。作品将依托于开源硬件平台Arduino，使用C语言进行程序开发。</p>
<p>双轮小车与四轮小车不同，双轮小车本身是一个欠稳定系统。将一个双轮小车直立着放在地面上时，小车难以站立，而是会向前或者向后倾倒。若要使小车维持稳定站立，我们需要引入一个控制系统。当小车将要向前倾倒时，控制电机带动轮胎向前移动，便阻止了小车前倾；同理可知小车后倾时可以向后移动阻止后倾，从而实现小车的平衡。</p>
<p>为了实现上述的控制，首先我们需要实时获取小车的“姿态”，即小车向前倾倒还是向后倾倒，以及倾倒的程度（一般使用角度来表示这个倾倒的程度）。“姿态”的获取需要使用可以测量加速度和角加速度的传感器，这种传感器被称作惯性测量单元 (IMU)，惯性测量单元获取的数据可以帮助我们获取小车“姿态”。</p>
<p>第二步是依据小车的“姿态”，控制电机活动，具体的控制内容包括电机的转速和转向。</p>
<h3 id="材料准备">材料准备</h3>
<p>实现一个最基础的平衡小车需要以下组件：</p>
<ul>
<li>微控制器：Arduino Nano 开发板</li>
<li>惯性测量单元 (IMU) ：MPU6050模块</li>
<li>电机：
<ul>
<li>N20减速直流电机（带霍尔编码器，详细参数见后文）</li>
<li>双母头电机端子线（型号：ZH1.5MM）</li>
<li>端子线贴片插座（型号：ZH1.5MM）</li>
</ul></li>
<li>电源：
<ul>
<li>7.4V锂电池</li>
<li>AMS1117降压电源模块（5V）</li>
<li>USB-Typec母头（带PCB板）</li>
</ul></li>
<li>外壳：3D打印外壳</li>
<li>电路板：立创EDA设计原理图和PCB板</li>
<li>其他：
<ul>
<li>N20减速直流电机配套固定架和D字轴轮胎</li>
<li>螺丝螺母</li>
<li>面包板和杜邦线（学习和测试时使用，实际小车中不使用）</li>
<li></li>
</ul></li>
</ul>
<h3 id="arduino-nano-介绍">Arduino Nano 介绍</h3>
<h4 id="初始arduino">初始Arduino</h4>
<p>Arduino是一款开源的嵌入式硬件开发平台，不仅包括了众多型号的开发板，而且包括了一个集成开发环境（IDE）辅助开发者编程，烧录和通信。Arduino本身提供了许多标准库，这些库的封装程度高，因此用户不必去关心寄存器配置而是可以通过库函数的调用来实现各种功能。Arduino作为一个受欢迎的开源平台，在互联网上可以找到大量的资料和例程进行学习。除了上文提到的标准库之外，Arduino还有各种用户针对不同外设写的库，可以在Arduino中轻松的获取和使用。Arduino本身还提供有图形化编程选项，即便是不会编程的非专业人士也可以快速上手。Arduino帮助我们从嵌入式硬件开发底层的细节中挣脱出来，把注意力放在控制本身这件事上。而且，鉴于本文的希望依托于一个可靠的开源平台且尽可能构造一个简单的自平衡小车，因此Arduino平台成为了我的首选。</p>
<p>进行电子设计时，我们首先要确定控制核心的选择。在这里我们选择了Arduino里面的Nano开发板进行开发。下图是Nano的模型图/引脚图。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162323982.png" alt="image-20220226162323982" style="zoom:67%;"></p>
<p>第一次接触硬件设计的人可能看到这张图会感到很复杂且不知所措。因此接下来我们将会通过一些实验来认识Nano。在结束这一章时再次回来看这张图片，或许你就会感到亲切了。</p>
<h4 id="实验1控制">实验1——控制</h4>
<p>Ardino是一块开源的嵌入式硬件平台，这句话对于初学者来说可能会是一个巨大的困扰，因为嵌入式是何意义，向初学者“正确”的解释清楚这件事并不容易。但是，不理解这段话并不影响我们去使用Arduino Nano来进行一些小开发。我们只需要牢牢记住一件事，那就是Nano是一个微控制器，微就是微小的意思，Nano就是个小型的控制器。控制器就是用来做控制的。接下来我们先从一个简单的实验入手，使用这个控制器去做一些控制。</p>
<p>首先我们先理解控制的概念，我们会希望控制什么呢？可能有人说，控制机器人！或者是控制一个遥控飞机飞行！是的，这些是控制，但是这种难度的控制并不适合一个初学者去学习。其实，控制无处不在，比如，我们按下开关，就可以打开灯，开关就是一个控制器，控制着灯的亮灭。现在，让我们把开关换成Nano，用它来控制一个LED小灯的亮灭。</p>
<p>实验需要准备：</p>
<ul>
<li>Arduino Nano开发板（焊接好排针），Arduino IDE，Micro USB接口的数据线</li>
<li>面包板和杜邦线（双公头）</li>
<li>LED灯和电阻</li>
</ul>
<p>首先，按照下图的方法连接电路。</p>
<p>然后打开Arduino IDE：用数据线将Nano与电脑相连接，选择相应的型号的开发板和端口，在编辑器中写入代码，然后点击编译并烧录，具体操作如下图：</p>
<p>图中代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED = <span class="number">7</span>;               <span class="comment">// 给D7引脚重命名为LED</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(LED, OUTPUT);        <span class="comment">// 将名为LED的引脚设置为（数字）输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED, HIGH);       <span class="comment">// 向LED引脚进行写入“高”，表示输出高电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">  digitalWrite(LED, LOW);        <span class="comment">// 向LED引脚进行写入“低”，表示输出低电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述操作后，就能看到LED亮一秒，灭一秒了。</p>
<p>使用模拟量（analogWrite(Pin,Value)函数的本质是PWM驱动）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte GND = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> byte LED = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(GND, OUTPUT);</span><br><span class="line">  pinMode(LED, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  analogWrite(GND, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i = i + <span class="number">50</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    analogWrite(LED, i);</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  analogWrite(LED, <span class="number">0</span>);</span><br><span class="line">  delay(<span class="number">1500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实验2通信">实验2——通信</h4>
<h4 id="实验3">实验3——</h4>
<h3 id="电机基础">电机基础</h3>
<h4 id="了解直流电机">了解直流电机</h4>
<p>学习和使用电机之前，我们首先要对电机的基本原理有一定的认识。最基础的电机的是我们在中学阶段就学习过的直流电机。直流电机是一个放在磁场中的导线转子，当有直流电流过导线转子时，转子便受力旋转。直流电机通入直流后转子转速很快，但是其扭矩——或者说转动的力度，很小。但是为了能带动轮胎转动实现小车行进，我们需要转子拥有较大的扭矩。于是我们有了减速直流电机。减速直流电机相比于直流电机多了一个减速箱。减速箱内部有许多齿轮，转子转动带动减速箱内部的齿轮转动，这一过程将导致转轴转速降低而扭矩提高，因此我们称其为减速电机。减速电机中最重要的参数是减速比。减速比的大小等于减速箱外的转轴转一圈时直流电机转子转过的圈数。我们使用的N20电机就是一个减速直流电机。</p>
<p>驱动直流电机的方法非常简单，只需要在电机的两个端子上接上正负电压，电机便开始转动。若是交换两端子上的电压，则电机会沿于之前相反的方向转动。对于装有编码器的N20电机来说，标注为M1和M2的端子为直流电机的端子。</p>
<p>为了更全面的理解电机，我们应该了解另一种常见的电机类型——步进电机，以便在其他时候遇到的话不至于与现在所学的电机相混淆。步进电机是一种可以顾名思义的东西，只不过大多数人在最开始想到的含义可以不太正确。步进电机不是专指用来前进或者行进的电机，毕竟很显然的是，只要外界轮子，直流电机也可以前进。步进电机这个名字来源于电机的内部构造，转子在脉冲信号输入下发生一步一步的转动，这种一步一步的转动的效果有点像钟表的秒针，每一秒在表盘上走一小步，一步一步的旋转，最终一分钟后旋转了一圈。如果我们加快这一过程，这样电机就不再是做一顿一顿的运动了，而是一个连续不断的快速的旋转。</p>
<p>步进电机只是转子旋转的原理和直流电机不同，但是依然可以在步进电机外接入减速箱。这两个电机的定语是两种平行的分类方式，这点不要混淆。</p>
<p>我们回到上文的直流电机，如果想要了解更多关于步进电机的知识，可以在搜索引擎上搜索“步进电机”，在这里我只是做简单的介绍。</p>
<p>直流电机有两个端子，施加正负电压即可驱动马达转动，交换正负电压就可以改变马达转向。前者非常简单，只需要提供一个外接直流电源，或者使用Nano的5V引脚和GND引脚就可以驱动电机转动，手动改变电流源极性或者使用微控制器调整输出电压信号都可以改变马达转向。但是如开篇我们所说的，我们需要同时控制电机转速和转向。为此，我们需要学习使用一种要脉冲宽度调制（Pulse-width modulation）的技术来控制电机的转速。下面我们就来详细地了解一下PWM技术，并且使用Nano来控制电机的转速和转向。</p>
<h4 id="脉冲宽度调制pwm">脉冲宽度调制（PWM）</h4>
<h5 id="pwm简介">PWM简介*</h5>
<p>TODO</p>
<h5 id="在arduino中使用pwm">在Arduino中使用PWM</h5>
<p>TODO</p>
<h4 id="编码器">编码器</h4>
<p>TODO</p>
<h3 id="mpu6050">MPU6050</h3>
<h4 id="原始数据">原始数据</h4>
<p>双轮自平衡小车使用的惯性测量单元 (IMU) 是MPU6050，包含一个三轴的加速度传感器和一个三轴的陀螺仪。加速度传感器可以获取运动的物体在三个坐标轴方向上的加速度，陀螺仪可以获取绕坐标轴旋转的物体的角加速度。</p>
<p>对于双轮自平衡小车，我们需要其在一个坐标轴方向上的角度信息。从小车侧面看，仅有可能向左右两个方向倾倒，而不会向前后倾倒，并且小车的静止和行进都是在地面这个水平面进行，因此不需要关心Z轴上的变化。因此，设计一个自平衡小车，我们只需要关注其绕X轴或是绕Y轴的角度（取决于模块的放置方式）问题即可。</p>
<p>在本次设计中，我将按照下图的方式放置MPU6050，因此我们关注的是绕X轴的角度变化。</p>
<figure>
<img src="/2022/02/25/19-20-54/照片预览_2022-02-27-16459370460521.svg" alt="照片预览_2022-02-27"><figcaption aria-hidden="true">照片预览_2022-02-27</figcaption>
</figure>
<p>为了实时获取小车的角度信息，我们需要同时使用加速度传感器和陀螺仪。单独测试MPU6050模块时，可以将将MPU6050模块的VCC引脚接Nano的5V引脚，MPU6050模块的GND引脚接Nano的GND引脚。接入电源后模块便能实时产生六个数据（实际数据比六个多，还包括温度数据，这里不进行介绍），我们使用<span class="math inline">\(I^2C\)</span>通信方式进行MPU6050模块和Nano之间的通信。进行<span class="math inline">\(I^2C\)</span>通信时，首先要将MPU6050模块的SCL引脚与Nano的SCL引脚相连，MPU6050模块的SDA引脚与Nano的SDA引脚相连。但是，这里存在一个问题是，在Nano的PCB板上我们找不到名为SCL与SDA的引脚。这时候我们就要回到文章开头的那张Nano引脚图了。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162741791.png" alt="image-20220226162741791" style="zoom: 50%;"></p>
<p>在图中我们可以看到Nano的A4引脚外面写着SDA，A5引脚外写着SCL，其实这是表示引脚的公用，即A4引脚既能做一个单纯的模拟引脚使用，也可以作为SDA引脚使用。因此，为了将MPU6050中产生的数据导入到Nano中，我们MPU6050模块的SDA引脚与Nano的A4引脚相连，SCL与A5相连。连接好之后，我们就可以通过代码来进行程序读取了。</p>
<p>使用Arduino进行<span class="math inline">\(I^2C\)</span>通信一般需要用到“Wire.h”这个标准库，使用“Wire.h”我们首先要将它包含进来。使用时，首先要进行初始化，与串口通信相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要读取MPU6050中的数据，我们需要知道其地址，然后进行数据传输，具体的代码操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//配置MPU6050的加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x1C</span>);</span><br><span class="line">  Wire.write(<span class="number">0x00</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本阶段的目标在于读取MPU6050中的原始数据，包括三个坐标方向上的加速度信息和三个方向上的角加速度信息。为了存储这些读取来的数据，我们设置了6个浮点数类型的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX, GyroY, GyroZ;</span><br></pre></td></tr></table></figure>
<p>来存储数据，之所以是变量数据类型而不是数组，因为这6个信息是实时测量值，在loop()这个函数中每一列都会获取当下的这六个数据，并立即进行处理，通过数学运算获取实时的角度信息，而下一刻的角度信息则有下一刻的六个数据计算得来。loop()函数中实时获取六个数据的方法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//读取加速度的值：</span></span><br><span class="line">  <span class="comment">//开启加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//读取角加速度的值：</span></span><br><span class="line">  <span class="comment">//开启角加速度模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取角加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码中，以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br></pre></td></tr></table></figure>
<p>为例，在MPU6050中直接读取的数据为<span class="math inline">\(AccX*16384.0\)</span>，之所以这里要将<span class="math inline">\(16384.0\)</span>这个数字除掉，其实是在进行单位转换，将加速度的单位转化为<span class="math inline">\(g\)</span>，这里的<span class="math inline">\(g=9.8\)</span>其实就是重力加速度。这里之所以将加速度的单位统一为重力加速度，是因为从原理上看，加速度计测量加速度原理就是以重力加速度为参考求出来的，所以一般将加速度的单位设为重力加速度。</p>
<p>使用上述代码</p>
<h4 id="数字滤波器">数字滤波器</h4>
<p>TODO</p>
<p>一阶互补滤波器（仅roll值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C address</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX = <span class="number">-1.5</span>,GyroErrorX = <span class="number">-0.25</span>,rollError = <span class="number">-3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">19200</span>);</span><br><span class="line">  Wire.begin();                      <span class="comment">// Initialize comunication</span></span><br><span class="line">  Wire.beginTransmission(MPU);       <span class="comment">// Start communication with MPU6050 // MPU=0x68</span></span><br><span class="line">  Wire.write(<span class="number">0x6B</span>);                  <span class="comment">// Talk to the register 6B</span></span><br><span class="line">  Wire.write(<span class="number">0x00</span>);                  <span class="comment">// Make reset - place a 0 into the 6B register</span></span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);        <span class="comment">//end the transmission</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// === Read acceleromter data === //</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>); </span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Y-axis value</span></span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Z-axis value</span></span><br><span class="line">  accAngleX = (<span class="built_in">atan</span>(AccY / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(AccX, <span class="number">2</span>) + <span class="built_in">pow</span>(AccZ, <span class="number">2</span>))) * <span class="number">180</span> / PI) - AccErrorX;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// === Read gyroscope data === //</span></span><br><span class="line">  previousTime = currentTime;</span><br><span class="line">  currentTime = millis();</span><br><span class="line">  elapsedTime = (currentTime - previousTime) / <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroX = GyroX - GyroErrorX;</span><br><span class="line">  gyroAngleX = gyroAngleX + GyroX * elapsedTime;</span><br><span class="line">  </span><br><span class="line">  roll = <span class="number">0.96</span> * gyroAngleX + <span class="number">0.04</span> * accAngleX -rollError;</span><br><span class="line">  Serial.println(roll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pid控制">PID控制</h3>
<p>TODO</p>
<h3 id="d建模制作小车外壳">3D建模——制作小车外壳</h3>
<p>TODO</p>
<h3 id="pcb设计制作小车电路板">PCB设计——制作小车电路板</h3>
<p>与使用面包板进行测试不同，绘制PCB板时使用的连线在打印PCB后就会固定下来，因此我们必须在编程时调用相应的引脚，这样才不会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HC06</span></span><br><span class="line"><span class="comment">//TX-&gt;Nano_Rx</span></span><br><span class="line"><span class="comment">//RX-&gt;Nano_TX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050</span></span><br><span class="line"><span class="comment">//SCL-&gt;Nano_A5</span></span><br><span class="line"><span class="comment">//SDA-&gt;Nano_A4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050 仅计算Roll时需要的变量如下</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX,GyroErrorX,rollError;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//小车直行代码</span></span><br><span class="line">  analogWrite(L1_M1,<span class="number">255</span>);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,<span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录一个可以使用的卡尔曼滤波器，直接使用下面的代码可以使用串口绘图器绘制出Roll的角度变化，打开绘图器时Roll的值记作0，然后表现为相对偏移，这个滤波器效果还不错，至少比那个一阶互补滤波器强，但是感觉相应速度不是很快。</p>
<p>主函数：</p>
<p>Kalman Filter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println(GetValue());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">  	fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建标签："Kalman.cpp"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kalman::Kalman() </span><br><span class="line">&#123;</span><br><span class="line">  Q_angle = <span class="number">0.001f</span>;</span><br><span class="line">  Q_bias = <span class="number">0.003f</span>;</span><br><span class="line">  R_measure = <span class="number">0.03f</span>;</span><br><span class="line"></span><br><span class="line">  angle = <span class="number">0.0f</span>;</span><br><span class="line">  bias = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span> </span><br><span class="line">&#123;</span><br><span class="line">  rate = newRate - bias;</span><br><span class="line">  angle += dt * rate;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] += dt * (dt * P[<span class="number">1</span>][<span class="number">1</span>] - P[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>][<span class="number">0</span>] + Q_angle);</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] += Q_bias * dt;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> S = P[<span class="number">0</span>][<span class="number">0</span>] + R_measure;</span><br><span class="line">  <span class="type">float</span> K[<span class="number">2</span>];</span><br><span class="line">  K[<span class="number">0</span>] = P[<span class="number">0</span>][<span class="number">0</span>] / S;</span><br><span class="line">  K[<span class="number">1</span>] = P[<span class="number">1</span>][<span class="number">0</span>] / S;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> y = newAngle - angle;</span><br><span class="line">  angle += K[<span class="number">0</span>] * y;</span><br><span class="line">  bias += K[<span class="number">1</span>] * y;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> P00_temp = P[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="type">float</span> P01_temp = P[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] -= K[<span class="number">0</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= K[<span class="number">0</span>] * P01_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= K[<span class="number">1</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] -= K[<span class="number">1</span>] * P01_temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setAngle</span><span class="params">(<span class="type">float</span> angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;angle = angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRate</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;rate;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_angle = Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_bias = Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;R_measure = R_measure;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQangle</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQbias</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRmeasure</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;R_measure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新建标签"Kalman.h"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Kalman_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Kalman_h_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kalman</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    Kalman();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAngle</span><span class="params">(<span class="type">float</span> angle)</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQangle</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQbias</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRmeasure</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    <span class="type">float</span> Q_angle;</span><br><span class="line">    <span class="type">float</span> Q_bias;</span><br><span class="line">    <span class="type">float</span> R_measure;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> angle;</span><br><span class="line">    <span class="type">float</span> bias;</span><br><span class="line">    <span class="type">float</span> rate;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> P[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Kalman_Filter(Adxl_angle, Gyro_sensor); <span class="comment">//卡尔曼融合获取angle</span></span><br><span class="line">Input = angle;</span><br><span class="line">myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PID_v1.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Setpoint, Input, Output;</span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line">  PID <span class="title function_">myPID</span><span class="params">(&amp;Input, &amp;Output, &amp;Setpoint,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>, DIRECT)</span>; <span class="comment">//PID对象声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  setupPID();  <span class="comment">//PID初始化</span></span><br><span class="line">    </span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line">  </span><br><span class="line">  Input = GetValue();</span><br><span class="line">  myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">  Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Drive</span><span class="params">(<span class="type">float</span> Output)</span></span><br><span class="line">&#123;    </span><br><span class="line">  analogWrite(L1_M1,Output);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,Output);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setupPID</span><span class="params">()</span>&#123;</span><br><span class="line">  Input = <span class="number">0</span>;</span><br><span class="line">  Setpoint = <span class="number">17</span>;  <span class="comment">//我的小车自平衡角度为17</span></span><br><span class="line">  myPID.SetSampleTime(<span class="number">100</span>);  <span class="comment">//控制器的采样时间100ms</span></span><br><span class="line">  <span class="comment">//myPID.SetOutputLimits(0, 2000); </span></span><br><span class="line">  myPID.SetMode(AUTOMATIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>记录</title>
    <url>/2022/03/15/15-32-05/</url>
    <content><![CDATA[<h1 id="fpga">FPGA</h1>
<h3 id="时序约束">时序约束</h3>
<ol type="1">
<li>如通信实验，时钟频率比较高的实验，需要进行时序约束</li>
<li>当占用芯片的逻辑资源多的时候，需要使用时序约束：因为FPGA在布线时会优先考虑面积</li>
</ol>
<p>时钟约束用来描述设计人员对于时序的要求，包括时钟频率和输入输出延时</p>
<p>D触发器</p>
<p>arduino 机械臂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myservo_1;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_2;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_3;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line"><span class="type">int</span> pos_1 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_2 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_3 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.attach(<span class="number">12</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">    myservo_2.attach(<span class="number">11</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">      myservo_3.attach(<span class="number">10</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_1 = <span class="number">0</span>; pos_1 &lt;= <span class="number">10</span>; pos_1 ++) &#123; <span class="comment">// 0°到180°</span></span><br><span class="line">    <span class="comment">// in steps of 1 degree</span></span><br><span class="line">    myservo_1.write(pos_1);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">for</span> (pos_2 = <span class="number">0</span>; pos_2 &lt;= <span class="number">60</span>; pos_2 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_2.write(pos_2);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_3 = <span class="number">0</span>; pos_3 &lt;= <span class="number">30</span>; pos_3 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_3.write(pos_3);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_1.write(<span class="number">-5</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////  for (pos_1 = 0; pos_1 &lt;= 120; pos_1 ++) &#123; // 0°到g180°</span></span><br><span class="line"><span class="comment">////    // in steps of 1 degree</span></span><br><span class="line"><span class="comment">////    myservo_1.write(pos_1);              // 舵机角度写入</span></span><br><span class="line"><span class="comment">////    delay(5);                       // 等待转动到指定角度</span></span><br><span class="line"><span class="comment">////  &#125;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字电路中的逻辑值">数字电路中的逻辑值：</h3>
<ul>
<li>逻辑 0：表示低电平，相当于电路 GND。</li>
<li>逻辑 1：表示高电平，相当于电路 VCC。</li>
<li>逻辑 X：表示未知，高或低。</li>
<li>逻辑 Z：表示高阻态，悬空状态</li>
</ul>
<h3 id="verilog-中的数字表示">Verilog 中的数字表示：</h3>
<p>“（数字的二进制）位宽 + 进制（缩写） + 数值”来表示一个数字。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制0101的表示</span></span><br><span class="line"><span class="number">4&#x27;b0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制2的表示，数字2的二进制表示为0010占4位</span></span><br><span class="line"><span class="number">4&#x27;d2</span></span><br></pre></td></tr></table></figure>
<p>Verilog 的默认二进制位宽为32位，默认的进制为十进制。</p>
<p>当二进制数字位数多的时候可以使用下划线增加可读性，编译时下划线会被去掉。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16&#x27;b1001_1010_1010_1001</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符">标识符：</h4>
<p>Verilog 的标识符可以用于定义模块名、端口名和信号名。</p>
<p>Verilog 的命名规则与 C 语言变量名的命名规则基本相同：只有一点，可以在命名中包含$符号。</p>
<p>标识符规则：</p>
<ul>
<li></li>
</ul>
<p>标识符推荐写法：</p>
<ul>
<li>不建议大小写混合</li>
<li>普通内部信号全部小写</li>
<li>信号命名体现含义</li>
<li>使用下划线区分词</li>
<li>采用前后缀：比如时钟可以采用：clk_50，clk_cpu</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>三种数据类型：</p>
<ul>
<li><p>寄存器数据类型：实际电路物理模型</p>
<ul>
<li><p>抽象数据存储单元，可以通过赋值语句改变寄存器储存的值</p></li>
<li><p>关键字：reg，默认初始值为 X 不确定</p></li>
<li><p>```verilog // reg + [位宽：31:0 指32位位宽，高位在前] + 标识符名称（寄存器名称） reg [31:0] delay_cnt; //延时计数使用的寄存器 reg key_reg; //没给位宽时默认位宽为1 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  + reg 类型的数据只能在 always 语句和 initial 语句中被赋值</span><br><span class="line"></span><br><span class="line">  + 如果 always 中带有时钟信号即过程语句描述的是时序逻辑，则寄存器对应为触发器</span><br><span class="line"></span><br><span class="line">  + 如果 always 中不带有时钟信号即过程语句描述的是组合逻辑，则寄存器对应为硬件连线</span><br><span class="line"></span><br><span class="line">  + </span><br><span class="line"></span><br><span class="line">+ 线网数据类型：实际电路物理模型</span><br><span class="line"></span><br><span class="line">+ 参数数据类型：给编译器用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 图像处理</span><br><span class="line"></span><br><span class="line">OV7725摄像头</span><br><span class="line"></span><br><span class="line">主控器控制OV7725时采用SCCB协议读写其寄存器，而它输出图像时则使用VGA或QVGA时序， 其中VGA在输出图像分辨率为480*640时采用，QVGA是Quarter VGA，其输出分辨率为240*320， 这些时序跟控制液晶屏输出图像数据时十分类似。</span><br><span class="line"></span><br><span class="line">OV7725传感器输出图像时，一帧帧地输出，在帧内的数据一般从左到右，从上到下， 一个像素一个像素地输出(也可通过寄存器修改方向)，见图 [摄像头数据输出](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id20) 。</span><br><span class="line"></span><br><span class="line">![摄像头数据输出](记录/OV7725012.jpg)</span><br><span class="line"></span><br><span class="line">例如，见图 [像素同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id21) 和图 [QVGA帧图像同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#qvga) ， 若我们使用D2-D9数据线，图像格式设置为RGB565，&lt;img src=&quot;记录/image-20220326130518483.png&quot; alt=&quot;image-20220326130518483&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">```verilog</span><br><span class="line">//RGB数据转换为YCBCR</span><br><span class="line">//因为FPGA处理除法是比较耗费资源的，所以我们团队采用左移右移以替代乘除法。处理整形数据可以将数据整体左移八位，再进行计算，最后在右移回去即可。</span><br><span class="line"></span><br><span class="line">Y’ = 0.257R’ + 0.504G’ + 0.098*B’ + 16</span><br><span class="line">Cb’ = -0.148R’ - 0.291G’ + 0.439*B’ + 128</span><br><span class="line">Cr’ = 0.439R’ - 0.368G’ - 0.071*B’ + 128</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>进行数据输出时，D2-D9数据线在PCLK在上升沿阶段维持稳定， 并且会在1个像素同步时钟PCLK的驱动下发送1字节的数据信号，所以2个PCLK时钟可发送1个RGB565格式的像素数据。 当HREF为高电平时，像素数据依次传输，每传输完一行数据时，行同步信号HREF会输出一个电平跳变信号间隔开当前行和下一行的数据； 一帧的图像由N行数据组成，当VSYNC为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC会输出一个电平跳变信号。</p>
<p><img src="/2022/03/15/15-32-05/image-20220326132950059.png" alt="image-20220326132950059" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rows=<span class="number">200</span></span><br><span class="line">cols=<span class="number">300</span></span><br><span class="line">num=<span class="number">2000</span> <span class="comment">#随机像素点的个数</span></span><br><span class="line">img=np.zeros((rows,cols,<span class="number">3</span>),np.uint8)</span><br><span class="line">pos1=np.random.randint(<span class="number">200</span>,size=(num,<span class="number">1</span>)) <span class="comment">#行位置随机数组</span></span><br><span class="line">pos2=np.random.randint(<span class="number">300</span>,size=(num,<span class="number">1</span>)) <span class="comment">#列</span></span><br><span class="line"><span class="comment">#随机位置处设置像素点值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">0</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">1</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">2</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">如果在OpenCV中处理图像，是BGR的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I=numpy.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=numpy.uint8) </span><br><span class="line"><span class="comment">#图片I大小为3*3，灰度值全为0，也就是黑色图像</span></span><br><span class="line">I=cv2.cvtColor(I,cv2.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#此时图像I变成了三个通道的每个像素点的值都为0</span></span><br><span class="line"><span class="comment">#有27个像素值，HSV色彩空间也是同样的方式，只是只是通道数不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emptyImage = np.zeros(img.shape, np.uint8)</span><br><span class="line">cv2.imshow(<span class="string">&quot;EmptyImage&quot;</span>, emptyImage) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">Strawberry=cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line"><span class="comment">#Strawberry=cv2.imread(&quot;strawberry.jpg&quot;)</span></span><br><span class="line">Lower = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">Upper = np.array([<span class="number">40</span>, <span class="number">40</span>, <span class="number">255</span>])</span><br><span class="line">Binary = cv2.inRange(Strawberry, Lower, Upper)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>, Binary)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\fruits.jpg&#x27;</span>)</span><br><span class="line">fruit = cv2.cvtColor(fruit,cv2.COLOR_BGR2YUV)</span><br><span class="line">Y,U,V = cv2.split(fruit)</span><br><span class="line">Blueberry = cv2.inRange(U,<span class="number">130</span>,<span class="number">255</span>)</span><br><span class="line">Strawberry = cv2.inRange(V,<span class="number">170</span>,<span class="number">255</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;blueberry&quot;</span>,Blueberry)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>,Strawberry)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line">skin1 = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OSTU&quot;</span>, skin1)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cr_otsu1</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;YCrCb颜色空间的Cr分量+Otsu阈值分割</span></span><br><span class="line"><span class="string">    :param image: 图片路径</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"></span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">_, skin = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image raw&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image raw&quot;</span>, img)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image CR&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, skin)</span><br><span class="line"></span><br><span class="line">dst = cv2.bitwise_and(img, img, mask=skin)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;seperate&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;seperate&quot;</span>, dst)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="灰度化">灰度化</h3>
<p>转换色彩空间：</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\name_of_picture&#x27;</span>)</span><br><span class="line">img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"><span class="comment">#img_YUV = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span></span><br><span class="line"><span class="comment">#img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img_ycbcr)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>以RGB格式的彩图为例，通常灰度化采用的方法主要有：</p>
<p>方法1：<span class="math inline">\(Gray=(R+G+B)/3\)</span></p>
<p>方法2：<span class="math inline">\(Gray=max(R,G,B)\)</span></p>
<p>方法3：<span class="math inline">\(Gray=0.299R+0.587G+0.114B\)</span>（这种参数考虑到了人眼的生理特点）</p>
<p>所谓阈值处理，就是给定一个阈值，当像素值比指定阈值大或小时做相关的操作。==这个字念yu，不是fa==，方法签名为:<code>cv2.threshold(src,thresh,maxval,type,dst=None)</code>,需要将的是OpenCV中提供的几种type：</p>
<ul>
<li>cv2.THRESH_BINARY：若像素值大于阈值，则置为maxval；否则置0</li>
<li>cv2.THRESH_BINARY_INV：THRESH_BINARY的反转</li>
<li>cv2.THRESH_TRUNC：若像素值大于阈值，则置为阈值；否则不变</li>
<li>cv2.THRESH_TOZERO：小于阈值的部分置为0；其他不变</li>
<li>cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">_, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY_INV)</span><br><span class="line">_, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TRUNC)</span><br><span class="line">_, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO)</span><br><span class="line">_, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO_INV)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#固定阈值的二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>选则合适的阈值筛选不同的色块，链接下文轮廓识别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自适应阈值二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th3)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="腐蚀">腐蚀</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;i.png&quot;</span>)</span><br><span class="line">img_noise = copy.deepcopy(img)</span><br><span class="line"><span class="comment"># add some noise to original image</span></span><br><span class="line">rows, cols = img_noise.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">	i = random.randint(<span class="number">0</span>, rows - <span class="number">1</span>)</span><br><span class="line">	j = random.randint(<span class="number">0</span>, cols - <span class="number">1</span>)</span><br><span class="line">	img_noise[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), dtype=np.uint8)</span><br><span class="line">erosion = cv2.erode(img_noise, kernel)</span><br><span class="line">dilation = cv2.dilate(erosion, kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;rectangle.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_contours_of_binary_image</span>():</span><br><span class="line">	im = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>)</span><br><span class="line">	imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">	ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">		<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">	res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">   	img_show(res)</span><br><span class="line">    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>轮廓检测能用代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">kernel = np.ones((<span class="number">1</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, anchor=(<span class="number">2</span>, <span class="number">0</span>), iterations=<span class="number">5</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>能看懂的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调节二值化的阈值可以描出不同的色块</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">100</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="二值化">二值化</h3>
<p>二值图也就是黑白图。将灰度图转换成黑白图的过程，就是二值化。二值化的一般算法是：</p>
<p><span class="math inline">\(g={0,f≤t1,f&gt;t}\)</span></p>
<p>其中t被称为阀值。阀值的确定方法有下面几种。</p>
<h2 id="otsu法大津法或最大类间方差法">Otsu法（大津法或最大类间方差法）</h2>
<p>来自霓虹国的大津展之为这种波谷找到了一个合适的数学表达，并于 1979 年发表论文[2]。这个二值化方法称为<strong>大津算法（Otsu’s method）</strong>。</p>
<p>大津算法就是，<strong>从 1 到 255 一个个数字试，找到一个数字能够把两个波峰切开</strong>，让两个波峰内部的类内方差之和最小。类内方差之和就是，单独求这两个波峰各自的方差，乘上波峰的占比权重，然后加起来。</p>
<p>这个数字就能最好的把图像分开，<strong>对应的就是双峰直方图中的波谷</strong>。这个算法最多只需遍历两次直方图数组，速度飞快，至今仍被广泛应用。</p>
<p>图像比较复杂的时候，我们对大津算法稍加扩展也可以完成分割。对大津算法的多级推广成为<strong>多大津算法（multi Otsu method） [3]</strong>。</p>
<p>*这里提到的是局部阈值的基本方法，对于实际使用中常见的其他局部阈值方法，请参阅<strong>Chow-Kaneko 自适应阈值法 [4]</strong>。</p>
<p>局部阈值的应用非常广泛，特别是对白纸黑字的处理非常有效。光学字符识别（OCR）和二维码扫描的算法中，很多都用了局部阈值操作。比如下面这张受光不均的二维码。</p>
<p>该算法是一种动态阈值分割算法。它的主要思想是按照灰度特性将图像划分为背景和目标2部分（这里我们将f≤t的部分称为背景，其他部分称为目标。），选取门限值，使得背景和目标之间的方差最大。</p>
<blockquote>
<p>注：Nobuyuki Otsu（大津展之），东京大学博士，先后在筑波大学和东京大学担任教授。</p>
</blockquote>
<p>其步骤如下：</p>
<p>1.建立图像灰度直方图。</p>
<p>2.计算背景和目标的出现概率。</p>
<p><span class="math inline">\(pA=∑i=0tpi,pB=∑i=t+1L−1pi=1−pA\)</span></p>
<p>其中，A和B分别表示背景部分和目标部分。</p>
<p>3.计算A和B两个区域的类间方差。</p>
<p><span class="math inline">\(公式ωA=∑i=0tipipA,ωB=∑i=t+1L−1ipipB(公式1)\)</span></p>
<p>公式1分别计算A和B区域的平均灰度值；</p>
<p>公式<span class="math inline">\(ω0=pAωA+pBωB=∑i=0L−1ipi\)</span>(公式2)</p>
<p>公式2计算灰度图像全局的灰度平均值；</p>
<p>公式<span class="math inline">\(σ2=pA(ωA−ω0)2+pB(ωB−ω0)2\)</span>(公式3)</p>
<p>公式3计算A、B两个区域的类间方差。</p>
<p>4.针对每一个灰度值，计算类间方差。选择方差最大的灰度值，作为阀值t。</p>
<p>下面是几个在使用opencv作轮廓检测时需要注意的点：</p>
<ul>
<li>为了更精确地提取轮廓，请使用二值图。也就是说，在使用轮廓提取函数前，请将源图片运用阈值进行<code>二值化(cv2.threshold())</code>或者采用<code>Canny边缘检测</code>。</li>
<li>findContours 函数会修改源图片，如果希望在轮廓检测后继续使用源图片，务必提前保存在另一个变量中。</li>
<li>在OpenCV中，轮廓检测视作从黑色背景中提取白色的物体，所以，在结果中，白色表示物体，黑色表示背景。</li>
</ul>
<p><em>提取轮廓的步骤大概会是这样子：</em></p>
<ol type="1">
<li>读取源图片，并转化为灰度图</li>
<li>运用threshold将灰度图片二值化（也可以使用Canny边缘检测）</li>
<li>使用<code>findContours()函数</code>找到所有的轮廓</li>
<li>使用<code>drawContours()函数</code>将轮廓画出来</li>
</ol>
<p>https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</p>
<h2 id="图像处理">图像处理</h2>
<h3 id="形态学">形态学</h3>
<h4 id="膨胀">膨胀</h4>
<h5 id="简介">简介</h5>
<p>膨胀是数学形态学的两种基本运算之一，腐蚀是另一种基本运算。它通常应用于二值图像，但也有适用于灰度图像的版本。该算子对二值图像的基本作用是逐渐扩大前景像素(通常为白色像素)区域的边界。因此，前景像素的区域会增大，而这些区域内的孔会变小。</p>
<h5 id="它是如何运作的">它是如何运作的</h5>
<p>这个描述的有用背景在词汇表的数学形态学部分给出。</p>
<p>膨胀运算符接受两段数据作为输入。首先是要放大的图像。第二个是一组坐标点(通常很小)，称为结构元素(也称为内核)。正是这个构造元素决定了输入图像的精确膨胀效果。</p>
<p>二值图像膨胀的数学定义如下：</p>
<p>设X为输入二值图像对应的欧几里德坐标集，K为构造元素的坐标集。</p>
<p>Kx表示K的平移使其原点在x处。</p>
<p>那么X乘以K的膨胀就是所有点X的集合使得Kx与X的交点非空。</p>
<p>除了与输入图像相关联的一组坐标的导出方式之外，灰度膨胀的数学定义是相同的。此外，这些坐标是三维的，而不是二维的。</p>
<p>作为二元扩张的一个例子</p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电子课程书籍</title>
    <url>/2022/03/23/15-24-59/</url>
    <content><![CDATA[<h2 id="河南大学迈阿密学院电子信息专业培养计划及其课本">河南大学迈阿密学院电子信息专业培养计划及其课本</h2>
<p>注：如果您不理解本篇博客的目的，请阅读<a href="https://qsctech.github.io/zju-icicles/">此文</a>。</p>
<h3 id="大一上学期">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 1 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>3 Longman Academic Writing Series</em><br> （无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 1 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>中国近现代史纲要</td>
<td>《中国近现代史纲要 （2018年版）》</td>
</tr>
<tr class="even">
<td>形式与政策</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>大学体育（一）College Physical Education I</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><a href="https://kdocs.cn/l/cbVej03YO5yb?f=201"><em>Elementary Linear Algebra</em><br></a>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td><em>Thinking Like an Engineer</em><br>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>编程导论（Introduction to Programming）</td>
<td><em>C++ Pregramming program Design Including Data Structures</em><br>（无中文版和答案）</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 2 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td>The Everyday Writer 6th Edition <br>（无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td>《流畅英语口语教程 第二册》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 2 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>思想道德修养与法律基础</td>
<td>《思想道德修养与法律基础 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（二）College Physical Education II</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 下》<br>参考答案</td>
</tr>
<tr class="odd">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td><em>Engineering Circuit Analysis</em><br>《工程电路分析 中文版》<br></td>
</tr>
<tr class="even">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td><em>Electric Circuit Ninth Edition</em><br>《电路 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>电路实验</td>
<td>“教师讲义 + 教学课件”</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 3 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>Technical Writing A Practical Guide for Engineers, Scientists, and Nontechnical Professionals by Phillip A. Laplante</em><br>无中文版</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 3 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>马克思主义基本原理概论</td>
<td>《马克思主义基本原理概论 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（三）College Physical Education III</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td><em>A Textbook on Ordinary Differential Equations</em><br>（无中文版和参考答案）<br>参考书：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="odd">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>数据结构（Data Structures）</td>
<td>《数据结构（C语言版）》<br><em>Data Structures Using C</em><br>参考资料：<a href="https://www.bilibili.com/video/BV1Fv4y1f7T1">视频课</a></td>
</tr>
<tr class="even">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="odd">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共两门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 4 智慧版》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 4 智慧版》</td>
</tr>
<tr class="even">
<td>大学体育（四）（College Physical Education IV）</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td><em>Probability, Statistics, and Random Processes For Electrical Engineerin</em><br>（无中文版）<br><a href>参考答案</a><br>参考资料：《概率论与数理统计 (第四版)》</td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>《信号与系统（郑君里）第三版 上》<br>参考书籍：<br>《信号与系统（郑君里）第三版 下》<br>《信号与系统（奥本海姆）第二版》</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td><em>Fundamentals Of Logic Design Seven Edition</em><br>《逻辑设计基础 中文版》<br>参考答案</td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>ARM：《微机原理与接口技术 第三版 基于ARM Cortex-M4 田辉》<br><em>Practical Microcontroller Engineering with ARMÂ­ Technology by Ying Bai<br></em>参考资料：x86：《微型计算机原理与接口技术》</td>
</tr>
<tr class="even">
<td><del>电子电路CAD （Electronic Circuit CAD）</del></td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期">大三上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td>《中文版 信号与系统 奥本海姆》</td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td><em>Field and Wave Electromagnetics by David K. Cheng</em><br>《电磁场与电磁波 中文版》</td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td><em>Semiconductor physics and devices basic principles by Donald A. Neamen</em><br>《半导体物理与器件 中文版》</td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td>《单片机原理及接口技术 第5版》</td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td>《Verilog HDL 数字设计与综合》</td>
</tr>
<tr class="even">
<td>创新项目实践（一）Practice of Innovation Project I</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期">大三下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td>《嵌入式系统设计——基于STM32CubeMX与HAL库》</td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td>《通信系统 中文版》<br>《通信原理》</td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin</em></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td>《电力电子技术》</td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td><em>Digital integrated circuits a design perspective</em><br>《数字集成电路——电路系统与设计 中文版》</td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td><em>Design of Analog CMOS Integrated Circuits by Behzad Razavi</em></td>
</tr>
<tr class="odd">
<td>创新项目实践（二）Practice of Innovation Project II</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>资料分享</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCv笔记</title>
    <url>/2022/03/30/11-27-50/</url>
    <content><![CDATA[<h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR 8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或 -1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如 <span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>， <strong><a href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong> 等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span> 中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数 <code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span> 转换，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于 <span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在 <span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较 <span class="math inline">\(OpenCV\)</span> 值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span> 图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在 $ HSV$ 中，比在 <span class="math inline">\(BGR\)</span> 颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span> 图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a href="https://www.stackoverflow.com/">stackoverflow.com</a> 中发现的一个常见问题。它非常简单，你可以使用相同的函数<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的 <span class="math inline">\(BGR\)</span> 值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$ 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和 <span class="math inline">\([H+10, 255,255]\)</span> 为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整 <span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong> 和 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为 <span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span> 用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span> 提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code> 函数。详情请查看 <span class="math inline">\(matplotlib\)</span> 文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a> 接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span> 是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span> 的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span> 的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 函数，其中 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 是 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a> 被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为 <span class="math inline">\(127\)</span> 的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span> 阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span> 实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span> 的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad \&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2 \frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span> 的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在 <span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span> 有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong> 来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示： <span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span> 操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong> 或 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong> 完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个 <span class="math inline">\(3x3\)</span> 标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数 <code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span> 内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong> 完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是 $ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了 <span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$ 取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong> 创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong> 取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span> 的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong> 在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a href="https://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong> 等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是 <span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span> 的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut 算法的交互式前景提取</h3>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/29/16-12-02/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">clc; </span><br><span class="line">close all; </span><br><span class="line">clear all; </span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;);%要求你.m文件下有test.bmp这个图像文件 </span><br><span class="line">PR=I(:,:,1);%提取红色分量 </span><br><span class="line">PG=I(:,:,2);%提取绿色分量 </span><br><span class="line">PB=I(:,:,3);%提取蓝色分量 </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(PR);title(&#x27;提取红分量后&#x27;); </span><br><span class="line">subplot(2,2,3);imshow(PG);title(&#x27;提取绿色分量后&#x27;); </span><br><span class="line">subplot(2,2,4);imshow(PB);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;); </span><br><span class="line">[m,n,d]=size(I); </span><br><span class="line"> </span><br><span class="line">level=15;%设置阈值 </span><br><span class="line">level2=70;%设置阈值 </span><br><span class="line"> </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,1)-I(i,j,2)&gt;level2)&amp;&amp;(I(i,j,1)-I(i,j,3)&gt;level2)) </span><br><span class="line">            r(i,j,1)=I(i,j,1); </span><br><span class="line">            r(i,j,2)=I(i,j,2); </span><br><span class="line">            r(i,j,3)=I(i,j,3); </span><br><span class="line">       else  </span><br><span class="line">            r(i,j,1)=255; </span><br><span class="line">            r(i,j,2)=255; </span><br><span class="line">            r(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(r);title(&#x27;提取红分量后&#x27;);%显示提取红分量后的图 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取绿分量，不满足阈值的变为白色 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,2)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,2)-I(i,j,3)&gt;level)) </span><br><span class="line">            g(i,j,1)=I(i,j,1); </span><br><span class="line">            g(i,j,2)=I(i,j,2); </span><br><span class="line">            g(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            g(i,j,1)=255; </span><br><span class="line">            g(i,j,2)=255; </span><br><span class="line">            g(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,3);imshow(g);title(&#x27;提取绿分量后&#x27;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取蓝色分量 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,3)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,3)-I(i,j,2)&gt;level)) </span><br><span class="line">                    b(i,j,1)=I(i,j,1); </span><br><span class="line">                    b(i,j,2)=I(i,j,2); </span><br><span class="line">                    b(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            b(i,j,1)=255; </span><br><span class="line">            b(i,j,2)=255; </span><br><span class="line">            b(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,4);imshow(b);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%清空变量，读取图像</span></span><br><span class="line">RGB = imread(<span class="string">&#x27;2019050913413134.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;process&#x27;</span>),</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(RGB),title(<span class="string">&#x27;原始RGB&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%convert frame from RGB to YCBCR colorspace（转换到YCBCR空间）</span></span><br><span class="line">YCBCR = rgb2ycbcr(RGB);</span><br><span class="line">whos,</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(YCBCR),title(<span class="string">&#x27;YCBCR&#x27;</span>),</span><br><span class="line"><span class="comment">%filter YCBCR image between values and store filtered image to threshold</span></span><br><span class="line"><span class="comment">%matrix（用各个通道的阈值对其进行二值化处理）</span></span><br><span class="line">Y_MIN = <span class="number">0</span>;  Y_MAX = <span class="number">256</span>;</span><br><span class="line">Cb_MIN = <span class="number">100</span>;   Cb_MAX = <span class="number">127</span>;</span><br><span class="line">Cr_MIN = <span class="number">138</span>;   Cr_MAX = <span class="number">170</span>;</span><br><span class="line">threshold=roicolor(YCBCR(:,:,<span class="number">1</span>),Y_MIN,Y_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">2</span>),Cb_MIN,Cb_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">3</span>),Cr_MIN,Cr_MAX);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(threshold),title(<span class="string">&#x27;YCBCR二值化&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%perform morphological operations on thresholded image to eliminate noise</span></span><br><span class="line"><span class="comment">%and emphasize the filtered object(s)（进行形态学处理：腐蚀、膨胀、孔洞填充）</span></span><br><span class="line">erodeElement = strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">3</span>) ;</span><br><span class="line">dilateElement=strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">8</span>) ;</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imfill(threshold,<span class="string">&#x27;holes&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(threshold),title(<span class="string">&#x27;形态学处理&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%获取区域的&#x27;basic&#x27;属性， &#x27;Area&#x27;, &#x27;Centroid&#x27;, and &#x27;BoundingBox&#x27; </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;处理结果&#x27;</span>),</span><br><span class="line">stats = regionprops(threshold, <span class="string">&#x27;basic&#x27;</span>);</span><br><span class="line">[C,area_index]=<span class="built_in">max</span>([stats.Area]);</span><br><span class="line"><span class="comment">%定位脸部区域</span></span><br><span class="line">face_locate=[stats(area_index).Centroid(<span class="number">1</span>),stats(area_index).Centroid(<span class="number">2</span>)];</span><br><span class="line">imshow(RGB);title(<span class="string">&#x27;after&#x27;</span>),<span class="built_in">hold</span> on</span><br><span class="line">text(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>)<span class="number">-40</span>,  <span class="string">&#x27;face&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>), <span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[stats(area_index).BoundingBox],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
