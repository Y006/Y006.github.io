<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y006.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1},"gitalk":{"order":-2}}},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="联系我：2420457716@qq.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://y006.github.io/default-index/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="联系我：2420457716@qq.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="邱金羽">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y006.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">邱金羽的技术博客！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="邱金羽"
      src="/images/custom-logo.jpg">
  <p class="site-author-name" itemprop="name">邱金羽</p>
  <div class="site-description" itemprop="description">联系我：2420457716@qq.com</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/32844822/dynamic" title="Bilibili个人空间 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;32844822&#x2F;dynamic" rel="noopener" target="_blank">Bilibili个人空间</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/qiu-jin-yu-60" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qiu-jin-yu-60" rel="noopener" target="_blank">知乎</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://uinika.github.io/" title="https:&#x2F;&#x2F;uinika.github.io&#x2F;" rel="noopener" target="_blank">UinIO</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fazzie-key.cool/" title="https:&#x2F;&#x2F;fazzie-key.cool&#x2F;" rel="noopener" target="_blank">摸黑干活</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://eater.net/" title="https:&#x2F;&#x2F;eater.net&#x2F;" rel="noopener" target="_blank">Ben Eater</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.52diy.com.cn/" title="https:&#x2F;&#x2F;blog.52diy.com.cn&#x2F;" rel="noopener" target="_blank">52diy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://gaoyichao.com/Xiaotu/" title="https:&#x2F;&#x2F;gaoyichao.com&#x2F;Xiaotu&#x2F;" rel="noopener" target="_blank">小土的世界</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stm32f4-discovery.net/" title="https:&#x2F;&#x2F;stm32f4-discovery.net&#x2F;" rel="noopener" target="_blank">Tilen Majerle</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mculover666.blog.csdn.net/" title="https:&#x2F;&#x2F;mculover666.blog.csdn.net&#x2F;" rel="noopener" target="_blank">Mculover666</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ssy1938010014.github.io/" title="https:&#x2F;&#x2F;ssy1938010014.github.io&#x2F;" rel="noopener" target="_blank">ssy的小天地</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bengoooo.github.io/" title="https:&#x2F;&#x2F;bengoooo.github.io&#x2F;" rel="noopener" target="_blank">BENgoooo</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2023/08/26/09-33-31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/26/09-33-31/" class="post-title-link" itemprop="url">hexo博客移植记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-26 09:33:31 / 修改时间：10:30:26" itemprop="dateCreated datePublished" datetime="2023-08-26T09:33:31+08:00">2023-08-26</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/08/26/09-33-31/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/08/26/09-33-31/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>22年8月换了新电脑，23年8月才把博客移植到新电脑上。最早建站的时候经历非常坎坷，各种配置折磨了我好久，遇到的一些问题网上查不到只能自己看着报错慢慢尝试，或者换着各种关键词去谷歌。我担心移植也会出现各种问题，大三又是比较繁忙的时候，如果出现了问题现在能显示的页面也显示不出来，还耽误时间，便暂停了移植计划，同时也暂停了更新。</p>
<p>不过今天终于还是将博客移植到新电脑上了，参考了一篇文章并且在ChatGPT的帮助下，移植过程可以说是非常顺利，妈妈再也不用担心我处理不了报错了（笑）。但是为了方便以后还有可能出现的移植需求，这里简单记录一下移植过程。</p>
<p>首先要把旧电脑中的这些内容拷贝到新电脑上合适的目录下，我在这里是E盘目录下的y006_github_io_blog文件夹。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS E:\y006_github_io_blog&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: E:\y006_github_io_blog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----        2023-08-26      9:59                scaffolds</span><br><span class="line">d-----        2023-08-26      9:59                source</span><br><span class="line">d-----        2023-08-26      9:59                themes</span><br><span class="line">-a----        2022-02-11     16:23             89 .gitignore</span><br><span class="line">-a----        2022-03-31     17:49            845 package.json</span><br><span class="line">-a----        2022-04-05     15:05           3069 _config.yml</span><br></pre></td></tr></table></figure>
<p>然后在新电脑上安装Git，然后在E:_github_io_blog文件夹中右键点击Git
Bash Here，使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>查看是否安装好了node和hexo，如果显示下面的内容则已经安装好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">24204@qjy_thinkbook MINGW64 /e/y006_github_io_blog</span><br><span class="line">$ hexo -v</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class="line">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class="line">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class="line">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class="line">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class="line">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class="line">========================================</span><br><span class="line">NexT version 8.10.0</span><br><span class="line">Documentation: https://theme-next.js.org</span><br><span class="line">========================================</span><br><span class="line">hexo: 6.3.0</span><br><span class="line">hexo-cli: 4.3.1</span><br><span class="line">os: win32 10.0.22621</span><br><span class="line">node: 16.17.0</span><br><span class="line">v8: 9.4.146.26-node.22</span><br><span class="line">uv: 1.43.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.47.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.7</span><br><span class="line">openssl: 1.1.1q+quic</span><br><span class="line">cldr: 41.0</span><br><span class="line">icu: 71.1</span><br><span class="line">tz: 2022a</span><br><span class="line">unicode: 14.0</span><br><span class="line">ngtcp2: 0.1.0-DEV</span><br><span class="line">nghttp3: 0.1.0-DEV</span><br></pre></td></tr></table></figure>
<p>注意查看node是否安装好。上述安装过程不再进行阐述，网上资料很多。我们假设已经做好了基本软件的安装。下面进行移植。</p>
<p>首先我们在Git Bash Here中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>此时应该弹出一个本地链接，点进去即可看到博客原来的配置都能正常显示在本地。这里我在一开始遇到了一个关于Pandoc的报错。这是因为我在博客上显示Latex需要用到Pandoc进行格式转化。由于我为我的Typora已经下载过了Pandoc，因此我在Typora的</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件 -&gt; 偏好设置 -&gt; 导出 -&gt; Pandoc路径</span><br></pre></td></tr></table></figure>
<p>中可以找到Pandoc的可执行文件，或者你也可以去官网下载Pandoc的可执行文件，将这个文件的路径添加到</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win系统开始图标右键 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 在系统环境变量一栏中找到PATH，添加Pandoc的可执行文件目录</span><br></pre></td></tr></table></figure>
<p>解决完这个问题后再次使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>可以看到本地已经可以正常显示之前配置好的博客。</p>
<p>然后可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>将文件上传到GitHub服务器。这里会存在一个问题就是SSH密钥问题。旧的SSH密钥可能会丢失，你可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al ~/.ssh</span><br></pre></td></tr></table></figure>
<p>来检查，这里我在没有SSH密钥的时候显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al ~/.ssh</span><br><span class="line">total 5</span><br><span class="line">drwxr-xr-x 1 24204 197610  0 Aug 26 09:10 ./</span><br><span class="line">drwxr-xr-x 1 24204 197610  0 Aug 26 09:10 ../</span><br><span class="line">-rw-r--r-- 1 24204 197610 92 Aug 26 09:10 known_hosts</span><br></pre></td></tr></table></figure>
<p>此时我们需要新建一个SSH密钥。即使没有丢失也可以新建一个SSH密钥，不会有影响。</p>
<p>首先在Git Bash Here中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行这条指令的时候会让你选择一个文件地址存放生成的密钥，可以在博客的目录下建一个文件夹叫做ssh_key，然后目录选择示例如下，注意落脚点是ssh_key文件夹下面的my_ssh_key文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\y006_github_io_blog\ssh_key\my_ssh_key</span><br></pre></td></tr></table></figure>
<p>然后启动SSH
Agent并添加密钥，输入输出内容应该如下（$后面的内容是我输入的内容）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">24204@qjy_thinkbook MINGW64 /e/y006_github_io_blog</span><br><span class="line">$ <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line">Agent pid 278</span><br><span class="line"></span><br><span class="line">24204@qjy_thinkbook MINGW64 /e/y006_github_io_blog</span><br><span class="line">$ ssh-add E:/y006_github_io_blog/ssh_key/my_ssh_key</span><br><span class="line">Identity added: E:/y006_github_io_blog/ssh_key/my_ssh_key (your_email@example.com)</span><br></pre></td></tr></table></figure>
<p>接下来将生成的密钥添加到GitHub：</p>
<p>首先仍是在Git Bash Here中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> E:\y006_github_io_blog\ssh_key\my_ssh_key.pub</span><br></pre></td></tr></table></figure>
<p>将密钥打印在终端，然后复制这个密钥到GitHub：</p>
<p>登录到GitHub账户，并进入“Settings”（设置）&gt;“SSH and GPG
keys”（SSH和GPG密钥）&gt;“New SSH
key”（新SSH密钥）。在“Title”（标题）字段中输入一个识别该密钥用途的名称，然后在“Key”（密钥）字段中粘贴复制的SSH公钥，最后点击“Add
SSH key”（添加SSH密钥）。</p>
<p>完成后可以删除旧的SSH密钥，然后此时再次运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>就可以在新电脑上上传我们的博客内容了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/10/12/23-40-51/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/12/23-40-51/" class="post-title-link" itemprop="url">单片机实验讲义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-12 23:40:51" itemprop="dateCreated datePublished" datetime="2022-10-12T23:40:51+08:00">2022-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-31 21:10:22" itemprop="dateModified" datetime="2022-10-31T21:10:22+08:00">2022-10-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/10/12/23-40-51/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/10/12/23-40-51/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="单片机第一次作业">单片机第一次作业</h2>
<h3 id="题目要求">题目要求</h3>
<ol type="1">
<li>安装 Keil 和 Proteus，熟悉 Keil 编译和可执行文件的生成操作和 Proteus
仿真操作</li>
<li>使用汇编语言编写代码实现单片机引脚输出 PWM 波形，使用 Proteus
中的示波器查看波形</li>
<li>使用按键控制 PWM 的延时长度（占空比？）</li>
<li>录制视频发至 B 站</li>
</ol>
<h3 id="题目实现">题目实现</h3>
<ol type="1">
<li>安装步骤及工程创建省略，具体操作可以类比。</li>
<li>代码实现思路：首先建立一个延时时间为
1ms（0.999285ms）的延时函数作为时基，然后通过调用该延时函数来控制高低电平的维持时间。主函数中通过每隔一定时间拉高拉低电平来实现
PWM 波形的生成。主函数中还包含按键检测的电路，进入 LOOP
前后都要进行按键检测。PWM 的占空比范围为
0%~100%，可以使用按键来控制每次按下按键时 PWM 的占空比增加 10%。</li>
<li>仿真电路搭建：在 Component Mode 中选择器件 AT89C51 和 button，在
Termianl Mode 中选择 Ground，在 Virtual Instrument Mode 中选择
OSCILLOSCOPE</li>
</ol>
<h3 id="代码详解">代码详解</h3>
<p>为了实现目标程序，我们首先实现一个目标程序的子集：我们首先设计一个占空比为
50% 的 PWM，这个代码是非常好理解的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETB	P2.1		;设置P2^1端口为高电平</span><br><span class="line">LCALL	DELAY		;跳转执行延时子函数</span><br><span class="line">CLR		P2.1		;设置P2^1端口为低电平</span><br><span class="line">LCALL	DELAY		;设置P2^1端口为高电平</span><br></pre></td></tr></table></figure>
<p>这是我们的延时代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;-------------------------------时基，单位msBEGIN-------------------------------</span><br><span class="line">DELAY:	;延时:1T+153*(4*1T+2T)+2T = 921T;921T = 921*1.085us = 0.999285ms</span><br><span class="line">		MOV	R2,#153			;1T</span><br><span class="line">HERE:</span><br><span class="line">		NOP					;1T</span><br><span class="line">		NOP					;1T</span><br><span class="line">		NOP					;1T</span><br><span class="line">		NOP					;1T</span><br><span class="line">		DJNZ	R2,HERE		;2T</span><br><span class="line">		NOP					;1T</span><br><span class="line">		RET					;2T</span><br><span class="line">;---------------------------------时基，单位msEND--------------------------------</span><br></pre></td></tr></table></figure>
<p>然后我们实现第二个小目标：设置一个占空比可调的占空比</p>
<p>为此我们给高电平一个时间，给低电平另一个时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETB	P2.1</span><br><span class="line">LCALL	HOLDHIGH</span><br><span class="line">CLR		P2.1</span><br><span class="line">LCALL	HOLDLOW</span><br></pre></td></tr></table></figure>
<p>这是使用循环嵌套进行高低电平持续时间的设置。我们设置 PWM 的周期为 100
个 DELAY，然后就可以非常方便的表示占空比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------高电平维持时间BEGIN----------------------------</span><br><span class="line">HOLDHIGH:	;延时:1T+30*921T+2T+2T = 27635T;27635T = 27635*1.085us = 29.983975ms</span><br><span class="line">			;延时:1T+x*921T+2T+2T = 921x+5T;921x+5T = 999.285x+0.000543ms</span><br><span class="line">		MOV		R5,30		;1T</span><br><span class="line">AGAINH:</span><br><span class="line">		LCALL	DELAY		;921T</span><br><span class="line">		DJNZ	R5,AGAINH	;2T</span><br><span class="line">		RET					;2T</span><br><span class="line">;--------------------------------高电平维持时间END-------------------------------</span><br><span class="line"></span><br><span class="line">;------------------------------低电平维持时间BEGIN-------------------------------</span><br><span class="line">HOLDLOW:	;延时:1T+70*921T+2T+2T = 64475T;64475T = 64475*1.085us = 69.955375ms</span><br><span class="line">			;延时:1T+1T+1T+1T+x*921T+2T+2T = 921x+8T;921x+8T = 999.285x+0.000868ms</span><br><span class="line">			;x = 70,69.950ms</span><br><span class="line">		MOV 	R5,70		;1T</span><br><span class="line">AGAINL:</span><br><span class="line">		LCALL	DELAY		;921T</span><br><span class="line">		DJNZ	R5,AGAINL	;2T</span><br><span class="line">		RET					;2T</span><br><span class="line">;-------------------------------低电平维持时间END--------------------------------</span><br></pre></td></tr></table></figure>
<p>但是这种情况下如果在源代码中改变占空比的话，我们需要改动两个值，现在我们希望的是，改动一处的值然后就能得到周期
100ms 的占空比正确的 PWM。</p>
<p>于是我们进行了下面的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------低电平维持时间BEGIN-------------------------------</span><br><span class="line">HOLDLOW:	;延时:1T+70*921T+2T+2T = 64475T;64475T = 64475*1.085us = 69.955375ms</span><br><span class="line">			;延时:1T+1T+1T+1T+x*921T+2T+2T = 921x+8T;921x+8T = 999.285x+0.000868ms</span><br><span class="line">			;x = 70,69.950ms</span><br><span class="line">		MOV 	R5,30		;1T</span><br><span class="line">		MOV 	A,#100		;1T</span><br><span class="line">		SUBB 	A,R5		;1T</span><br><span class="line">		MOV 	R5,A		;1T</span><br><span class="line">AGAINL:</span><br><span class="line">		LCALL	DELAY		;921T</span><br><span class="line">		DJNZ	R5,AGAINL	;2T</span><br><span class="line">		RET					;2T</span><br><span class="line">;-------------------------------低电平维持时间END--------------------------------</span><br></pre></td></tr></table></figure>
<p>最后，我们使用寄存器 B 来存储占空比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">		MOV		B,#30</span><br><span class="line">;--------------------------------高电平维持时间BEGIN----------------------------</span><br><span class="line">HOLDHIGH:	;延时:1T+30*921T+2T+2T = 27635T;27635T = 27635*1.085us = 29.983975ms</span><br><span class="line">			;延时:1T+x*921T+2T+2T = 921x+5T;921x+5T = 999.285x+0.000543ms</span><br><span class="line">		MOV		R5,B		;1T</span><br><span class="line">AGAINH:</span><br><span class="line">		LCALL	DELAY		;921T</span><br><span class="line">		DJNZ	R5,AGAINH	;2T</span><br><span class="line">		RET					;2T</span><br><span class="line">;--------------------------------高电平维持时间END-------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;------------------------------低电平维持时间BEGIN-------------------------------</span><br><span class="line">HOLDLOW:	;延时:1T+70*921T+2T+2T = 64475T;64475T = 64475*1.085us = 69.955375ms</span><br><span class="line">			;延时:1T+1T+1T+1T+x*921T+2T+2T = 921x+8T;921x+8T = 999.285x+0.000868ms</span><br><span class="line">			;x = 70,69.950ms</span><br><span class="line">		MOV 	R5,B		;1T</span><br><span class="line">		MOV 	A,#100		;1T</span><br><span class="line">		SUBB 	A,R5		;1T</span><br><span class="line">		MOV 	R5,A		;1T</span><br><span class="line">AGAINL:</span><br><span class="line">		LCALL	DELAY		;921T</span><br><span class="line">		DJNZ	R5,AGAINL	;2T</span><br><span class="line">		RET					;2T</span><br><span class="line">;-------------------------------低电平维持时间END--------------------------------</span><br></pre></td></tr></table></figure>
<p>接下来的目标是添加按键逻辑。</p>
<p>首先我们来思考一下按键的逻辑是什么样子的：首先我们假设初始时寄存器 B
的值是 10，即占空比为 10%</p>
<ul>
<li>按键按下：寄存器 B 中的值加 10</li>
<li>按键松开：执行 IO 口高低电平的切换</li>
</ul>
<p>依照这种逻辑，我们有代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;-----------------------------------主函数BEGIN---------------------------------</span><br><span class="line">MAIN:</span><br><span class="line">		SETB	P2.1		;1T</span><br><span class="line">		LCALL	HOLDHIGH	;2T</span><br><span class="line">		CLR		P2.1		;1T</span><br><span class="line">		LCALL	HOLDLOW		;2T</span><br><span class="line">		</span><br><span class="line">		JB		P2.0,MAIN	;P2.1为1的时候循环，按键按下变为0时进入ADD指令</span><br><span class="line">		MOV 	A,B</span><br><span class="line">		ADD 	A,#10</span><br><span class="line">		MOV 	B,A</span><br><span class="line">		</span><br><span class="line">		SJMP 	MAIN</span><br><span class="line">;-----------------------------------主函数END-----------------------------------</span><br></pre></td></tr></table></figure>
<p>在这种逻辑下，我们会发现我们已经实现了使用按键控制 PWM
的占空比。在仿真工程中我们也可以看到每次按下按键时输出的 PWM
占空比都会发生变化。</p>
<p>但是，如果我们仔细观察占空比的变化，我们会发下每次按下时增长的占空比比预期的
10% 要多。这是为什么呢？</p>
<p>这要来重新思考我们的按键逻辑，我们来重新整理一下：</p>
<ul>
<li>按键按下：寄存器 B 中的值加==<strong>一次</strong>== 10</li>
<li>按键等待：按键等待用户松开按键，确认这是一次按键操作</li>
<li>按键松开：一次按键操作后改变了占空比输出 PWM</li>
</ul>
<p>其实，这里的关键在于，当按键按下时，我们需要等待，等待按键被松开，然后才判断为
1
次按下。如果不进行等待（不进行阻塞），那么当按下的时候，那么代码一直在循环执行按键按下的操作，即寄存器
B 加 10</p>
<p>于是我们得到了新的按键控制逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;-----------------------------------主函数BEGIN---------------------------------</span><br><span class="line">MAIN:</span><br><span class="line">		JNB		P2.0,MAIN	;使用阻塞的方式检测按键松开</span><br><span class="line">LOOP:</span><br><span class="line">		SETB	P2.1		;1T</span><br><span class="line">		LCALL	HOLDHIGH	;2T</span><br><span class="line">		CLR		P2.1		;1T</span><br><span class="line">		LCALL	HOLDLOW		;2T</span><br><span class="line">		</span><br><span class="line">		JB		P2.0,LOOP	;P2.1为1的时候循环，按键按下变为0时进入ADD指令</span><br><span class="line">		MOV 	A,B</span><br><span class="line">		ADD 	A,#10</span><br><span class="line">		MOV 	B,A</span><br><span class="line">		</span><br><span class="line">		SJMP 	MAIN</span><br><span class="line">;-----------------------------------主函数END-----------------------------------</span><br></pre></td></tr></table></figure>
<p>此时我们已经能较为完美的进行 PWM 占空比控制了</p>
<p>其实我一开始就是写道这个程度，但是当我整理这份报告的时候，我突然发现其实还有一个重要的改进空间，那就是上述代码在按键按下时在一直等待，而因为我们的
PWM
的周期较小，我们在按下的时候会出现某一段波形为空的状态（波形持续输出一段高电平或者低电平），这是因为我们在按键等待的时候即这个循环内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">		JNB		P2.0,MAIN	;使用阻塞的方式检测按键松开</span><br></pre></td></tr></table></figure>
<p>什么都没做。这种波形的中断，在一些场合下可能是致命的，因此我们有必要做一些改进。</p>
<p>我这里采用了一个非常简单的方法进行改进，就是在这个循环体内也加入 PWM
生成代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;-----------------------------------主函数BEGIN--------------------------------</span><br><span class="line">MAIN:</span><br><span class="line">		SETB	P2.1		;1T</span><br><span class="line">		LCALL	HOLDHIGH	;2T</span><br><span class="line">		CLR		P2.1		;1T</span><br><span class="line">		LCALL	HOLDLOW		;2T</span><br><span class="line">		JNB		P2.0,MAIN	;使用阻塞的方式检测按键松开</span><br><span class="line">LOOP:</span><br><span class="line">		SETB	P2.1		;1T</span><br><span class="line">		LCALL	HOLDHIGH	;2T</span><br><span class="line">		CLR		P2.1		;1T</span><br><span class="line">		LCALL	HOLDLOW		;2T</span><br><span class="line">		</span><br><span class="line">		JB		P2.0,LOOP	;P2.1为1的时候循环，按键按下变为0时进入ADD指令</span><br><span class="line">		MOV 	A,B</span><br><span class="line">		ADD 	A,#10</span><br><span class="line">		MOV 	B,A</span><br><span class="line">		</span><br><span class="line">		SJMP 	MAIN</span><br><span class="line">;-----------------------------------主函数END-----------------------------------</span><br></pre></td></tr></table></figure>
<p>这样就比较丝滑的做到了使用按键控制 PWM</p>
<h3 id="仿真详解">仿真详解</h3>
<p>比较简单，略。</p>
<h2 id="单片机第二次作业">单片机第二次作业</h2>
<h3 id="题目要求-1">题目要求</h3>
<p>流水灯实验</p>
<ol type="1">
<li>八个LED灯加两个按键</li>
<li>一个按键用于控制流水灯的样式</li>
<li>另一个按键用于控制流水灯的延时</li>
</ol>
<h3 id="题目实现-1">题目实现</h3>
<ol type="1">
<li>创建 Keil 工程和 Proteus 工程</li>
<li>选择 P2 口连接八个 LED 灯，选择 P1.0 和 P1.1作为按键输入端口</li>
<li>编写代码</li>
</ol>
<h3 id="代码详解-1">代码详解</h3>
<p>首先我们先写一个流水灯代码。由于这次要同时操作八个流水灯，因此我们可以直接操作
Port 而不是对其中的单个端口进行操作。一个位的信息可以控制一个
Pin，因此一个 Port 可以使用 8 位二进制数表示。这种情况下想让 LED
灯全亮的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED P2</span></span><br><span class="line">LED = <span class="number">0xff</span>;</span><br></pre></td></tr></table></figure>
<p>使用移位运算可以改变 Pin 的状态。例如，上两行代码执行过后 P2
口的状态为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P20 --&gt; <span class="number">1</span></span><br><span class="line">P21 --&gt; <span class="number">1</span></span><br><span class="line">P22 --&gt; <span class="number">1</span></span><br><span class="line">P23 --&gt; <span class="number">1</span></span><br><span class="line">P24 --&gt; <span class="number">1</span></span><br><span class="line">P25 --&gt; <span class="number">1</span></span><br><span class="line">P26 --&gt; <span class="number">1</span></span><br><span class="line">P27 --&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用移位运算来改变 P2 的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LED = <span class="number">0xff</span> &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>执行这段代码后，状态变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P20 --&gt; <span class="number">1</span></span><br><span class="line">P21 --&gt; <span class="number">1</span></span><br><span class="line">P22 --&gt; <span class="number">1</span></span><br><span class="line">P23 --&gt; <span class="number">1</span></span><br><span class="line">P24 --&gt; <span class="number">1</span></span><br><span class="line">P25 --&gt; <span class="number">1</span></span><br><span class="line">P26 --&gt; <span class="number">1</span></span><br><span class="line">P27 --&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>那么流水效果只需要配合循环即可实现：同时因为灯是先全亮然后再从上往下灭，因此我们封装成一个函数起名为
<code>up_to_down()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up_to_down</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> delay_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LED = <span class="number">0xff</span> &lt;&lt; i;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; delay_time; j++)</span><br><span class="line">			Delay10ms();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理我们可以写出第二种流水方式——自下向上亮</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down_to_up</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> delay_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LED = <span class="number">0xff</span> &lt;&lt; <span class="number">8</span> - i;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; delay_time; j++)</span><br><span class="line">			Delay10ms();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装好之后我们可以在 <code>main()</code>
函数中调用了。方法是设置一个状态变量，然后不停的查询它，每种状态对应一种流水灯流水方式，流水方式的选择可以使用
<code>switch</code> 语句来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		init_led();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		down_to_up(delay_time);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		up_to_down(delay_time);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们要做的就是将按键控制逻辑加进去，来控制状态变量
<code>state</code> 和延时长度变量 <code>delay_time</code> 发生变化。</p>
<p>一种简单的逻辑是，既然按键也需要单片机轮询扫描，那么我们可以也加入到
<code>while(1)</code> 中，于是我们得到这样的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> state = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> delay_time = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	init_led();</span><br><span class="line">	init_button();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (button1 == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Delay10ms();</span><br><span class="line">			<span class="keyword">if</span> (button1 == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(button1 == <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (state &lt; <span class="number">2</span>)</span><br><span class="line">					state++;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (button2 == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Delay10ms();</span><br><span class="line">			<span class="keyword">if</span> (button2 == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(button2 == <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (delay_time &lt; <span class="number">100</span>)</span><br><span class="line">					delay_time = delay_time + <span class="number">10</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					delay_time = <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (state)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				init_led();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				down_to_up(delay_time);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				up_to_down(delay_time);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以开始仿真。得到的结果是可以改变流水效果和延时。但是同时也有问题，就是我们的按键在很多情况下是不管用的，只有少数情况下能够起作用。</p>
<p>这是因为我们在 <code>while(1)</code>
中除了扫描按键，还执行了流水灯的代码，而流水灯的代码存在很长的延时，当代码执行到这些延时的时候，即便是按下按键，没有正在执行按键检测逻辑，那么就不能正确的识别按键按下的操作。</p>
<p>解决这个方法最好的办法是，不管我们现在在做什么，只要按键被按下，就让单片机停下手头在做的事情，先帮我们改变
<code>state</code> 变量和 <code>delay_time</code>
，然后再让单片机回到它之前进行的位置比如执行延迟。这样一来就可以实现按键的检测而不影响点灯了。</p>
<p>这种实现思路在单片机上是可以做到的，但是需要使用到我们目前还没有学过的知识，因此我们换一种方式来解决。</p>
<p>这里我们首先将按键检测代码封装成一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_button</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Delay10ms();</span><br><span class="line">	<span class="keyword">if</span> (button1 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (button1 == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (state &lt; <span class="number">2</span>)</span><br><span class="line">			state++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			state = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (button2 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (button2 == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (delay_time &lt; <span class="number">100</span>)</span><br><span class="line">			delay_time = delay_time + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			delay_time = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (button1 == <span class="number">0</span> || button2 == <span class="number">0</span>);</span><br><span class="line">	check_button();</span><br></pre></td></tr></table></figure>
<p>然后，前面问题的解决方案就是，在每一轮延迟循环中我们都进行按键检测。因为按键检测的代码复杂度不高（只有分支语句，时间复杂度只有
<span class="math inline">\(O(1)\)</span>
），因此我们将按键检测代码放到流水灯中。又因为流水灯代码中时间复杂度最高的（为
<span class="math inline">\(O(n²)\)</span>
）是延时函数，因此将按键检测代码放在延迟中去。</p>
<p>最终结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED P2</span></span><br><span class="line">sbit button1 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit button2 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit error = P1 ^ <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> delay_time = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_led</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_button</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_button</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay10ms</span><span class="params">()</span>; <span class="comment">//@11.0592MHz</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_to_down</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down_to_up</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	init_led();</span><br><span class="line">	init_button();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (state)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			init_led();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			down_to_up();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			up_to_down();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			error = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_led</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LED = <span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">if</span> (button1 == <span class="number">0</span> || button2 == <span class="number">0</span>)</span><br><span class="line">		check_button();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_button</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	button1 = <span class="number">1</span>;</span><br><span class="line">	button2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay10ms</span><span class="params">()</span> <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">18</span>;</span><br><span class="line">	j = <span class="number">235</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_button</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Delay10ms();</span><br><span class="line">	<span class="keyword">if</span> (button1 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (button1 == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (state &lt; <span class="number">2</span>)</span><br><span class="line">			state++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			state = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (button2 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (button2 == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (delay_time &lt; <span class="number">100</span>)</span><br><span class="line">			delay_time = delay_time + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			delay_time = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">up_to_down</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LED = <span class="number">0xff</span> &lt;&lt; i;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; delay_time; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (button1 == <span class="number">0</span> || button2 == <span class="number">0</span>)</span><br><span class="line">				check_button();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Delay10ms();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down_to_up</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LED = <span class="number">0xff</span> &lt;&lt; <span class="number">8</span> - i;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; delay_time; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (button1 == <span class="number">0</span> || button2 == <span class="number">0</span>)</span><br><span class="line">				check_button();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Delay10ms();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="仿真详解-1">仿真详解</h3>
<h2 id="单片机第三次作业没布置">单片机第三次作业（没布置）</h2>
<h3 id="题目要求-2">题目要求</h3>
<h3 id="题目实现-2">题目实现</h3>
<h3 id="代码详解-2">代码详解</h3>
<h3 id="仿真详解-2">仿真详解</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/09/28/14-52-54/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/28/14-52-54/" class="post-title-link" itemprop="url">电磁场与电磁波</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-28 14:52:54" itemprop="dateCreated datePublished" datetime="2022-09-28T14:52:54+08:00">2022-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-22 23:53:54" itemprop="dateModified" datetime="2022-11-22T23:53:54+08:00">2022-11-22</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/09/28/14-52-54/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/09/28/14-52-54/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="矢量分析">矢量分析</h2>
<h3 id="坐标系">坐标系</h3>
<p>基本正交坐标系的度量系数 <span class="math inline">\(h\)</span></p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 26%">
<col style="width: 27%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>坐标系关系</th>
<th>直角坐标系（<span class="math inline">\(x,y,z\)</span>）</th>
<th>柱坐标系（<span class="math inline">\(r,\phi,z\)</span>）</th>
<th>球坐标系（<span class="math inline">\(R,\theta,\phi\)</span>）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(h1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(h2\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(r\)</span></td>
<td><span class="math inline">\(R\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(h3\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(Rsin\theta\)</span></td>
</tr>
</tbody>
</table>
<h3 id="矢量微积分中的微分元">矢量微积分中的微分元</h3>
<ol type="1">
<li>线微元：<span class="math inline">\(d\vec{l} =
\vec{a_1}(h_1{a_{u_{1}}})+\vec{a_2}(h_2{a_{u_{2}}})+\vec{a_3}(h_3{a_{u_{3}}})\)</span><br>
</li>
<li>面微元：<span class="math inline">\(d\vec{s} =
\vec{a_n}ds\)</span>，其中 <span class="math inline">\(\vec{a_n}\)</span> 是面积 <span class="math inline">\(s\)</span> 的单位法向量
<ul>
<li><span class="math inline">\(ds_1 = h_2h_3du_2du_3\)</span></li>
<li><span class="math inline">\(ds_2 = h_1h_3du_1du_3\)</span></li>
<li><span class="math inline">\(ds_3 = h_1h_2du_1du_2\)</span></li>
</ul></li>
<li>体微元：<span class="math inline">\(dv =
h_1h_2h_3du_1du_2du_3\)</span></li>
</ol>
<h3 id="场函数的特性描述">场函数的特性描述</h3>
<p>标量场梯度：对于标量场 <span class="math inline">\(V(u_1,u_2,u_3)\)</span></p>
<ul>
<li>梯度定义式： <span class="math inline">\(\vec{\nabla} =
\vec{a_n}\frac{dV}{dn}\)</span></li>
<li>梯度计算式：<span class="math inline">\(\vec{\nabla} V =
\left(\vec{a_{u_1}}\frac{\partial}{h_1 \partial u_1} +
\vec{a_{u_2}}\frac{\partial}{h_2 \partial u_2} +
\vec{a_{u_3}}\frac{\partial}{h_3 \partial u_3}\right)V\)</span></li>
<li>标量场方向导数：<span class="math inline">\(dV/dl = \vec{\nabla} V
\cdot \vec{a_l}\)</span></li>
</ul>
<p>矢量场的散度：对于矢量场 <span class="math inline">\(\vec{A} =
\vec{a_1}A_1 + \vec{a_2}A_2 + \vec{a_3}A_3\)</span></p>
<ul>
<li>散度定义式：<span class="math inline">\(div \vec{A} = \lim_{\Delta
v\rightarrow0}{\frac{\oint_s\vec{A}d\vec{s}}{\Delta v}}\)</span></li>
<li>散度计算式：<span class="math inline">\(div \vec{A} = \vec{\nabla}
\cdot \vec{A}\)</span></li>
<li>散度定理：<span class="math inline">\(\oint_s\vec{A}\,d\vec{s} =
\int_v \vec{\nabla} \cdot \vec{A} \,dv\)</span></li>
</ul>
<p>矢量场的旋度：</p>
<ul>
<li>旋度的定义式：<span class="math inline">\(curl \vec{A} =
\lim_{\Delta
s\rightarrow0}{\left[\frac{\vec{a_n}\oint_c\vec{A}d\vec{l}}{\Delta
s}\right]_{max}}\)</span><br>
</li>
<li>旋度的计算式：<span class="math inline">\(curl \vec{A} =
\vec{\nabla} \times \vec{A}\)</span></li>
<li>斯托克斯公式：<span class="math inline">\(\int_s \vec{\nabla} \times
\vec{A} \,d\vec{s} = \oint_c\vec{A}\,d\vec{l}\)</span></li>
</ul>
<p>恒等式：</p>
<ul>
<li><span class="math inline">\(\vec{\nabla} \times (\vec{\nabla} V) =
0\)</span></li>
<li><span class="math inline">\(\vec{\nabla} \cdot (\vec{\nabla} \times
\vec{A}) = 0\)</span></li>
</ul>
<p>亥姆霍兹定律：如果一个矢量场的散度和旋度处处都已经给定，那么这个矢量场（矢量点函数）就确定了，最多附加一个常数。</p>
<h3 id="静电场">静电场</h3>
<h4 id="真空静电学基本公理">真空静电学基本公理：</h4>
<p><span class="math display">\[
\vec{\nabla} \cdot \vec{E} = \frac{\rho}{\varepsilon_0}\\
\vec{\nabla} \times \vec{E} =0
\]</span></p>
<h4 id="高斯定理">高斯定理：</h4>
<p>对场强的散度描述可以推出高斯定理 <span class="math display">\[
\oint_s\vec{E}\,d\vec{s} = \int_v\vec{\nabla} \cdot \vec{E} \,dv= \int_v
\frac{\rho}{\varepsilon_0} \,dv = \frac{Q}{\varepsilon_0}
\]</span></p>
<h4 id="基尔霍夫定律">基尔霍夫定律：</h4>
<p>对场强的旋度描述可以推出基尔霍夫定律 <span class="math display">\[
\oint_c\vec{E}\,d\vec{l} = \int_s \vec{\nabla} \times \vec{E} \,d\vec{s}
=  \int_s 0 \,d\vec{s} = 0
\]</span></p>
<h4 id="场强计算">场强计算：</h4>
<ol type="1">
<li><p>静止在无界真空中的单个点电荷 <span class="math inline">\(q\)</span> 的场强计算：</p>
<ul>
<li><p>点电荷的位置矢量为 <span class="math inline">\(\vec{0}\)</span>
即 <span class="math inline">\(q\)</span> 位于坐标原点： <span class="math display">\[
\oint_s\vec{E}\,d\vec{s} = E_R(4\pi R^2) = \frac{q}{\varepsilon_0}\\
\Downarrow\\
\vec{E} = \vec{a_R}E_R=\vec{a_R}\frac{q}{4\pi \varepsilon_0R^2}
\]</span></p></li>
<li><p>点电荷的位置矢量为 <span class="math inline">\(\vec{R&#39;}\)</span> <span class="math display">\[
\vec{E} = \frac{\vec{R}-\vec{R&#39;}}{|\vec{R}-\vec{R&#39;}|} \cdot
\frac{q}{4\pi \varepsilon_0 |\vec{R}-\vec{R&#39;}|^2} = \frac{1}{4\pi
\varepsilon_0} \cdot \frac{q(\vec{R}-\vec{R&#39;})}{
|\vec{R}-\vec{R&#39;}|^3}
\]</span></p></li>
</ul></li>
<li><p>电偶极子：</p>
<ul>
<li>定义电荷量 <span class="math inline">\(q\)</span> 与矢量 <span class="math inline">\(d\)</span> （从 <span class="math inline">\(-q\)</span> 到 <span class="math inline">\(+q\)</span> ）的乘积称为电偶极矩 <span class="math inline">\(p\)</span> <span class="math display">\[
\vec{E} = \frac{p}{4\pi \varepsilon_0 R^3} (\vec{a_R}2cos\theta +
\vec{a_\theta}sin\theta)
\]</span></li>
</ul></li>
<li><p>离散电荷系统：</p>
<ul>
<li><span class="math display">\[
\vec{E} = \frac{1}{4\pi \varepsilon_0} \cdot
\sum_{k=1}^n\frac{k(\vec{R}-\vec{R&#39;_k})}{
|\vec{R}-\vec{R&#39;_k}|^3}
\]</span></li>
</ul></li>
<li><p>连续电荷系统：</p>
<ul>
<li><p>先微分：<span class="math inline">\(Q = \rho\,dv&#39;\)</span>
（此处可以采用不同的微分方式，如面微分或者线微分） <span class="math display">\[
d\vec{E} = \vec{a_R}dE_R=\vec{a_R}\frac{\rho\,dv&#39;}{4\pi
\varepsilon_0R^2}
\]</span></p></li>
<li><p>后积分：其中 <span class="math inline">\(\vec{a_R} =
/R^3\)</span> <span class="math display">\[
\vec{E} = \frac{1}{4\pi
\varepsilon_0}\int_{v&#39;}\frac{\vec{R}\,\rho}{R^3}\,dv&#39;
\]</span></p></li>
</ul></li>
</ol>
<h4 id="电位计算">电位计算：</h4>
<ol type="1">
<li><p>引入：由零恒等式的推论：一个无旋矢量场总可以写成一个标量场的梯度，由此可以使用场强来定义出电位：
<span class="math display">\[
\vec{E} = -\vec{\nabla} V
\]</span> 电位的物理意义与功联系： <span class="math display">\[
\frac{W}{q} = -\int^{P_2}_{P_1}\vec{E}\cdot d\vec{l} = V_{P_2}-V_{P_1}
\]</span></p></li>
<li><p>单个点电荷的电位（以无限远处作为零电位） <span class="math display">\[
V = -\int^R_\infty \left( \vec{a_R} \frac{q}{4\pi \varepsilon_0R^2}
\right) \cdot \vec{a_R} dR\\
\Downarrow\\
V = \frac{q}{4\pi \varepsilon_0R}
\]</span></p></li>
<li><p>离散点电荷系统： $$</p>
<p>$$</p></li>
<li><p>电偶极子： <span class="math display">\[
V = \frac{\vec{p} \cdot \vec{a_R}}{4\pi \varepsilon_0R^2}
\]</span></p></li>
</ol>
<h4 id="静电场中的导体">静电场中的导体</h4>
<ol type="1">
<li><p>研究内容：静电场中的导体内部和表面的电荷分布</p></li>
<li><p>使用高斯定理可知：导体内部不存在电荷分布 <span class="math display">\[
\rho = 0\\
\vec{E} = 0
\]</span></p></li>
<li><p>导体表面场强：</p>
<ol type="1">
<li>切向场强：使用场强的旋度描述可知为 <span class="math inline">\(0\)</span></li>
<li>法向场强：使用高斯定理：<span class="math inline">\(\vec{E_n} =
\rho_S/\varepsilon_0\)</span></li>
</ol>
<p><span class="math display">\[
\vec{E_t} = 0\\
\vec{E_n} = \frac{\rho_S}{\varepsilon_0}
\]</span></p></li>
</ol>
<h4 id="静电场中的电介质">静电场中的电介质</h4>
<p>首先为了描述极化电介质引入了极化矢量： <span class="math display">\[
\vec{p} =  \lim_{\Delta v\rightarrow0} \frac{\sum_{k=1}^{n\Delta
v}\vec{p_k}}{\Delta v}
\]</span>
通过电位可以把极化电介质使用一个等效极化面电荷密度和一个等效极化体电荷密度替代：
<span class="math display">\[
\rho_{ps} = \vec{P} \cdot \vec{a_n}\\
\rho_p = \vec{\nabla} \cdot \vec{P}
\]</span> 由于极化电介质会引起等效体电荷密度 <span class="math inline">\(\rho_p\)</span>，所以电介质中给定源产生的电场强度将与真空中不同。</p>
<p>计算真空中给定源产生的场强的方法是应用静电学基本公理：<span class="math inline">\(\vec{\nabla} \cdot \vec{E} =
\frac{\rho}{\varepsilon_0}\)</span>，但这个式子只适用于真空环境中，在电介质中必须要修改这个式子：
<span class="math display">\[
\vec{\nabla} \cdot \vec{E} = \frac{\rho+\rho_p}{\varepsilon_0}
\]</span> 为了便于后面的分析，我们在此处还引入了一个新的概念：电通密度
<span class="math inline">\(\vec{D} =
\varepsilon_0\vec{E}+\vec{P}\)</span></p>
<p>使用电通密度来描述电介质中的源产生的电场的好处是：不需要涉及极化矢量和极化电荷密度：
<span class="math display">\[
\vec{\nabla} \cdot \vec{D} = \rho
\]</span>
当电介质是线性且各向同性的时候，极化强度正比于电场强度，由上面电通密度的定义式可以进一步推出此条件下非常有用的结论：
<span class="math display">\[
\vec{D} = \varepsilon\vec{E} = \varepsilon_r\varepsilon_0\vec{E}
\]</span></p>
<hr>
<h3 id="标量场梯度">标量场梯度</h3>
<h4 id="文字理解">文字理解：</h4>
<ul>
<li>导数：函数某一点的导数是过该点切线的斜率</li>
<li>偏导数：多变量函数在直角坐标系中沿某一坐标轴方向上的导数</li>
<li>方向导数：函数在任意方向上的导数是方向导数
<ul>
<li>“任意方向” 中方向使用矢量来描述而不是坐标轴平面</li>
<li>用来描述方向使用的矢量可以分解在坐标轴方向上</li>
</ul></li>
<li>梯度：标量场中有许多不同方向的方向导数，其中数值最大的方向上的方向导数称为梯度</li>
</ul>
<h4 id="数学描述">数学描述：</h4>
<ul>
<li>空间中有一<strong>标量函数</strong> <span class="math inline">\(V(u_1,u_2,u_3)\)</span></li>
<li>若其刻画的标量场在空间中分布不均匀，那么当 <span class="math inline">\(V\)</span>
发生微小变化时，变化方向不同，其大小也不同。</li>
<li>由此我们得到<strong>方向导数</strong>的定义：<span class="math inline">\(dV/dl\)</span> ，方向导数是一个标量</li>
<li>当 <span class="math inline">\(d\vec{l}\)</span>
方向发生变化并使方向导数值取最大，即该方向上有<strong>最大变化率</strong>时，设此时方向：<span class="math inline">\(d\vec{l}=d\vec{n}\)</span></li>
<li>得到<strong>梯度</strong>定义：</li>
</ul>
<p><span class="math display">\[
\nabla V = \vec{a_n}\frac{dV}{dn}
\]</span></p>
<h4 id="实用公式">实用公式：</h4>
<ul>
<li><p>使用梯度来表示方向导数： <span class="math display">\[
\frac{dV}{dl}=\frac{dV}{dn}\frac{dn}{dl}=\frac{dV}{dn}cos\alpha=\frac{dV}{dn}\vec{a_n}\cdot\vec{a_l}=\nabla
V\cdot\vec{a_l}
\]</span> 疑问：为什么 <span class="math inline">\(\frac{dn}{dl}=cos\alpha\)</span></p></li>
<li><p>将方向矢量分解到坐标系表示的梯度公式（使用梯度公式）： <span class="math display">\[
\nabla V = \left(\vec{a_{u_1}}\frac{\partial}{h_1 \partial u_1}
+  \vec{a_{u_2}}\frac{\partial}{h_2 \partial u_2} +
\vec{a_{u_3}}\frac{\partial}{h_3 \partial u_3}\right)V
\]</span></p></li>
<li><p>微分算子 <span class="math inline">\(\nabla\)</span> <span class="math display">\[
\nabla = \vec{a_{u_1}}\frac{\partial}{h_1 \partial u_1}
+  \vec{a_{u_2}}\frac{\partial}{h_2 \partial u_2} +
\vec{a_{u_3}}\frac{\partial}{h_3 \partial u_3}
\]</span></p></li>
</ul>
<h3 id="矢量场散度和旋度">矢量场散度和旋度</h3>
<h4 id="文字理解-1">文字理解：</h4>
<ul>
<li>标量场空间导数得到梯度的概念</li>
<li>矢量场空间导数得到散度和旋度两个概念</li>
</ul>
<h4 id="数学描述-1">数学描述：</h4>
<ul>
<li><p>通量：即矢量场中矢量的面积积分：<span class="math inline">\(\oint_S\vec{A}\,d\vec{s}\)</span></p></li>
<li><p>散度： 包围某点的体积趋于 <span class="math inline">\(0\)</span>
时，单位体积内流出的 <span class="math inline">\(\vec{A}\)</span>
的<strong>净通量</strong>： <span class="math display">\[
div\vec{A} = \lim_{\Delta
v\rightarrow0}{\frac{\oint_S\vec{A}\,d\vec{s}}{\Delta v}}
\]</span></p></li>
</ul>
<h4 id="实用公式-1">实用公式：</h4>
<ul>
<li><p>使用矢量微分算子表示散度 <span class="math display">\[
\nabla \cdot \vec{A} = div\vec{A}
\]</span></p></li>
<li><p>正交曲线坐标系下的公式 <span class="math display">\[
div\vec{A}=\nabla \cdot \vec{A} = \frac{1}{h_1h_2h_3}
\]</span></p></li>
</ul>
<p>&lt;iframe height='500' scrolling='100'
src='https://www.bilibili.com/video/BV1or4y1M78k/'</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/09/15/11-22-34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/11-22-34/" class="post-title-link" itemprop="url">电力电子技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-15 11:22:34 / 修改时间：14:45:24" itemprop="dateCreated datePublished" datetime="2022-09-15T11:22:34+08:00">2022-09-15</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/09/15/11-22-34/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/09/15/11-22-34/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="电力电子器件">2. 电力电子器件</h2>
<h3 id="电力电子器件概述">2.1 电力电子器件概述</h3>
<p>主电路（main power
circuit）：电力系统中直接承担电能变换或者控制任务的</p>
<p>电力电子器件（power electronic
device）：主电路中实现电能变换或者控制的电子器件</p>
<ul>
<li>分类：
<ul>
<li>电真空器件（淘汰）</li>
<li>半导体器件（主流）—— 主要材料是硅</li>
</ul></li>
<li>与信息电子器件的区别
<ul>
<li>电力电子器件处理的电功率较大</li>
<li>一般工作在开关状态：通态阻抗小，短态阻抗大，管子两端电压由外电路决定</li>
<li>电力电子器件一般使用信息电子器件来控制，需要中间电路对控制信号进行放大，因此需要驱动电路</li>
<li>因为开关损耗的存在，发热比较大，因此讲究散热设计</li>
</ul></li>
<li>分析方法：
<ul>
<li>关注电力电子器件的动态特性（开关特性）和参数</li>
<li>做电路分析时一般使用理想开关来代替</li>
</ul></li>
</ul>
<p>电力电子系统</p>
<ul>
<li>控制电路
<ul>
<li>信息电子器件：小功率</li>
<li>检测主电路信号（需要检测电路），生成控制信号（需要驱动电路）</li>
</ul></li>
<li>主电路
<ul>
<li>电力电子器件：大功率</li>
<li>电力电子器件相比于主电路中普通元器件承受过电压和过电流的能力弱，因此需要在主电路和控制电路之间加保护电路</li>
</ul></li>
<li>控制电路和主电路之间连接有检测电路和驱动电路，这些四种电路的连接中需要进行电气隔离，可以采用光或者磁信号来替代电信号</li>
</ul>
<p>电力电子器件的分类</p>
<ul>
<li><p>控制程度</p>
<ul>
<li><p>半控型器件：可以控制其导通但是不能控制其关断（晶闸管）</p></li>
<li><p>全控型器件：既可以控制导通也可以控制关断（IGBT 和
MOSEFT）</p></li>
<li><p>不可控器件：通断取决于电路，不能控制（电力二极管）</p></li>
</ul></li>
<li><p>控制信号</p>
<ul>
<li>电流控制型：控制端注入或者抽出电流形成通断</li>
<li>电压控制型：控制端和公共端施加电压信号形成通断（也成为场控器件）
<ul>
<li>施加电压信号
<ul>
<li>脉冲触发型：给脉冲，改变状态直到下一个脉冲到来</li>
<li>电平控制型：电平对应状态，电平改变即状态改变</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>载流子</p>
<ul>
<li>单极型：仅一种载流子（多子）</li>
<li>双极型：电子空穴两种载流子</li>
<li>复合型</li>
</ul></li>
</ul>
<h3 id="电力二极管">2.2 电力二极管</h3>
<p>PN结原理</p>
<ul>
<li>本征半导体：热激发使得本征半导体中产生电子空穴对，电子空穴相遇后会复合而成对消失。室温下本征半导体中存在少量的载流子</li>
<li>非本征半导体：在本征半导体中掺杂低价或者高价元素可以引入多余的电子或者空穴，得到非本征半导体。非本征半导体中N型半导体是电子为多子的半导体，P型半导体是空穴为多子的半导体</li>
<li>当P型半导体和N型半导体结合成为PN结时，由于双方中多子类型不同，因此形成了多子的浓度梯度，多子会在浓度梯度的作用下向对方扩散，此时多子扩散运动产生了扩散电流</li>
<li>当多子进入对面半导体时成为了少子，并且在新环境中很容易与该环境的多子进行复合。复合使得PN结中间结处载流子数量减少并且产生空间电荷区。空间电荷区会平衡浓度梯度，最终扩散运动消失。</li>
<li>空间电荷区会吸引附近的少子。少子会在电场加速向对面移动形成漂移电流。</li>
<li>正向偏置是，电源正极对P型，负极对N型；此时外加电源的电场方向与空间电荷区电场方向相反，从而打破平衡，产生持续的扩散电流，此时为PN结正向导通状态。</li>
<li>反向偏置时，电源正极对N型，负极对P型；此时外加电源的电场方向与空间电荷区电场方向相同，因空间电荷区加速产生的漂移电流进一步增强（不过因为是少子电流因此电流很小），而扩散电流被进一步抑制。总体上表现为几乎没有电流的反向截至状态。</li>
</ul>
<p>区别：普通的信息二极管可以认为是PN结，而电力二极管进行了一些变化以适应高电压和大电流</p>
<ul>
<li>横向导电结构改为了垂直导电结构：电流方向与硅片表面垂直，使得通过二极管的有效面积增大，显著提高了二极管的通流能力</li>
<li>电力二极管增加在PN结中间增加了低掺杂N区，也称为漂移区，形成了N-I-P结构，低掺杂区域导电性差，类似于本征半导体，因此可以承受更高的反向电压而不被击穿产生大电流
<ul>
<li>漂移区不利于正向导通——解决方案：电导调制效应（Conductivity
Modulation）
<ul>
<li>正向偏置时P区多子扩散到N区形成少子，扩散电流很大时大量少子注入N区会激发新的多子出现，从而提高N区载流子数量从而降低电阻率，使得正向导通时电力二极管表现为低阻态（压降始终维持在1V左右）</li>
</ul></li>
</ul></li>
</ul>
<p>电力二极管的反向击穿：</p>
<ul>
<li>反向偏置电压过大时电流会突然增大，称为反向击穿
<ul>
<li>雪崩击穿</li>
<li>齐纳击穿</li>
</ul></li>
<li>击穿发生时如果限制通过的电流，那么二极管不会损坏</li>
<li>如果不限制电流使得功率超过了允许的耗散功率，那么会过热烧毁，称为热击穿</li>
</ul>
<p>电力二极管的电容效应：</p>
<ul>
<li>PN结中的电荷量随外加电压变化
<ul>
<li>扩散电容：正向偏置产生</li>
<li>势垒电容：外部电压变化时产生</li>
</ul></li>
</ul>
<p>电力二极管的基本特性：</p>
<ul>
<li><p>静态特性：电力二极管的伏安特性，与信息二极管类似</p></li>
<li><p>动态特性：由于电容效应，在电力二级管发生状态变化时的电流电压特性不能使用静态描述中的伏安特性来描述。</p>
<p><strong>理解两种特性：静态伏安特性认为电压变化时电流将瞬间发生变化，因此可以描点画线表示不同电压取值下一一对应的瞬态电流取值。但是动态效应考量的时真正的半导体器件具有电容效应，电压突变的时候电流不会随即发生变化，中间具有时间差，为了刻画这种时间差，我们将时间作为横坐标，将电压和电流同时作为纵坐标，绘制两条曲线，然后只要做垂直线就可以在时间轴上采样观察电压和电流的关系，体会电容带来的延时变化。</strong></p></li>
</ul>
<p>电力二极管的动态特性：</p>
<ol type="1">
<li>从零偏到正偏，正向电流线性增长然后稳定，正向电压先过冲然后减小趋于稳定</li>
<li>正偏到反偏时，正向电流瞬间减小，下降速率由反偏电压和电路中电感决定</li>
<li>正向电压不会随之下降，因为电导调制效应会增大电阻维持正向电压</li>
<li>当正向电流减小为零时，正向电压开始下降</li>
<li>当反向电流反向达将近最大值时，正向电压达到零并以大速率下降</li>
<li>反向电流达到最值后开始下降，过程中由于外电路的电感效用会使反向电压产生过冲</li>
<li>反向电流下降到比较低的时候，速度比较慢的时候，反向电压也减小到反偏电压</li>
<li>时间：
<ul>
<li>延迟时间 = 反向电流取最值的时间点 - 正向电流减小为零的时间点</li>
<li>电流下降时间 = 反向电压等于反偏电压的时间点 -
反向电流取最值的时间点</li>
<li>电力二极管的反向恢复时间 = 延迟时间 + 电流下降时间</li>
<li>恢复系数 = 电流下降时间 / 延迟时间</li>
</ul></li>
</ol>
<p>电力二极管主要参数：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>正向平均电流</td>
<td></td>
</tr>
<tr class="even">
<td>正向压降</td>
<td></td>
</tr>
<tr class="odd">
<td>反向重复峰值压降</td>
<td></td>
</tr>
<tr class="even">
<td>最高工作结温</td>
<td></td>
</tr>
<tr class="odd">
<td>反向恢复时间</td>
<td></td>
</tr>
<tr class="even">
<td>浪涌电流</td>
<td></td>
</tr>
</tbody>
</table>
<p>电力二极管的主要类型：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>普通二极管</td>
<td></td>
</tr>
<tr class="even">
<td>快速恢复二极管</td>
<td></td>
</tr>
<tr class="odd">
<td>肖特基二极管</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="晶闸管">2.3 晶闸管</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/09/13/17-54-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/13/17-54-09/" class="post-title-link" itemprop="url">《从电路设计的角度入门VerilogHDL》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-13 17:54:09" itemprop="dateCreated datePublished" datetime="2022-09-13T17:54:09+08:00">2022-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-26 09:00:34" itemprop="dateModified" datetime="2023-08-26T09:00:34+08:00">2023-08-26</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/09/13/17-54-09/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/09/13/17-54-09/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述与特性">概述与特性</h2>
<h3 id="简介">简介</h3>
<p>VerilogHDL 不是编程语言，是硬件描述语言。学习 VerilogHDL
的过程中，我们应该从电路设计的角度去思考与 VerilogHDL
有关的问题而不是从如何编程的角度去思考。</p>
<blockquote>
<p>书籍推荐：</p>
<p>轻松成为设计高手：VerilogHDL 使用精讲</p>
<p>MOOC 课程推荐：</p>
<p>芯动力——硬件加速设计方法</p>
</blockquote>
<p>什么是 HDL？</p>
<p>HDL，全称是 Hardware <strong>Description</strong>
Language，翻译过来是“硬件描述语言”。从名字可以看出进行 HDL
开发的过程不是设计的过程，而是描述事物的过程。对于 HDL
来说，我们是要将已经存在的电路用编程语言的方式描出来。因此，HDL
的开发过程是先设计硬件电路，然后使用 HDL 对于设计好的电路进行描述。</p>
<p>VerilogHDL 由 Cadence
发明，以全定制电路设计方法学的挑战者诞生。VerilogHDL
随着芯片规模进入数亿晶体管时代，近年来受到了 HLS、Chisel
等语言的挑战。但是目前 VerilogHDL
仍是描述数字电路和数字逻辑系统的主流语言。</p>
<h4 id="veriloghdl-设计流程">VerilogHDL 设计流程</h4>
<ol type="1">
<li><p>设计一个电路（RTL）</p></li>
<li><p>对设计的电路进行仿真和验证</p></li>
<li><p>进行逻辑综合</p></li>
<li><p>将综合好的电路进行布局布线</p>
<blockquote>
<p>逻辑综合使得我们由 VerilogHDL
得到了具体的电路，布局布线则是得到了芯片上各个器件在版图上的坐标</p>
</blockquote></li>
<li><p>布局布线后的网表可以去流片得到真正可以使用的芯片</p></li>
</ol>
<h4 id="veriloghdl-的重要特性">VerilogHDL 的重要特性：</h4>
<p>VerilogHDL 具备从 “抽象表达” 到 “门级连接”
的多层次表征的能力：既可以在较高层面进行电路行为级的描述，也可以在较低层面描述门级电路的连接关系。</p>
<p>因此说 VerilogHDL 的功能非常全面。</p>
<p>为了更加方便地描述超大规模集成电路，人们希望使用抽象程度更高的 HDL
来描述硬件。这是 HLS、Chisel 等语言的发展方向。</p>
<p>VerilogHDL
可以看作是一个大工具箱，可以将其中的工具分为两类：一类是真正用于生成硬件电路的可综合语句，另一类是构建测试环境的语句。</p>
<blockquote>
<p>数字硬件电路的描述方法：</p>
<p>两类：</p>
<ul>
<li>原理图：
<ul>
<li>早期方法</li>
<li>直观，便于理解</li>
</ul></li>
<li>HDL：
<ul>
<li>适合大型设计</li>
<li>HDL 的优势体现在超大规模集成电路的设计中。HDL
的可维护性强且模块的复用非常方便</li>
</ul></li>
</ul>
</blockquote>
<h4 id="veriloghdl-的工具简介">VerilogHDL 的工具简介：</h4>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 42%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>使用场景</th>
<th>开源工具解决方案</th>
<th>商业工具解决方案</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>代码编辑器</td>
<td>VScode、Vim等</td>
<td>Vivado、Quaruts</td>
</tr>
<tr class="even">
<td>仿真</td>
<td>Iverilog、verilator、GTK-Wave</td>
<td>VCS、Modelsim、Vivado、Quaruts</td>
</tr>
<tr class="odd">
<td>逻辑综合</td>
<td>Yosys</td>
<td>Vivado、Quaruts</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="veriloghdl-的缺点">VerilogHDL 的缺点：</h4>
<ul>
<li>例化繁琐，需要手动连线</li>
<li>大量中间信号需要写声明</li>
<li>模块参数能力弱</li>
<li>对于错误的检查能力弱</li>
<li>基础电路需要重复写，电路的复用程度低</li>
<li>...</li>
</ul>
<h2 id="编写方法">编写方法</h2>
<h4 id="设计对象">设计对象</h4>
<p>我们以下图为例介绍：<img src="/2022/09/13/17-54-09/image-20220913193245926.png" alt="image-20220913193245926"></p>
<p>一个完整的数字电路工程称为一个
<strong>Design</strong>（设计），Design 由多个模块构成</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP ( A,B,C,D,CLK,OUT1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> A,B,C,D,CLK;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] OUT1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> INV1,INV0;</span><br><span class="line">    </span><br><span class="line">    ENCODER U1 (<span class="variable">.AIN</span>(A),<span class="variable">.BIN</span>(B),<span class="variable">.CIN</span>(C),<span class="variable">.DIN</span>(D),<span class="variable">.Q0</span>(BUS0),<span class="variable">.Q1</span>(BUS1));</span><br><span class="line"></span><br><span class="line">    INV U2(<span class="variable">.A</span>(BUS0),<span class="variable">.Z</span>(INV0)),</span><br><span class="line">        U3(<span class="variable">.A</span>(BUS1),<span class="variable">.Z</span>(INV1));</span><br><span class="line"></span><br><span class="line">    REGFILE U4(<span class="variable">.D0</span>(INV0),<span class="variable">.D1</span>(INV1),<span class="variable">.CLK</span>(CLK),<span class="variable">.Q</span>(OUT1));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/09/13/17-54-09/image-20220913193541195.png" alt="image-20220913193541195" style="zoom: 33%;"></p>
<p>这种情况的出现是因为我们使用了 Yosys 无法正确识别的
cells：ENCODER、INV 和 REGFILE。因为这三个 Cells
是我们自己定义的，因此我们需要自己来规定这些 cells
的输入和输出。因此我们创建三个新的 module。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ENCODER ( AIN,BIN,CIN,DIN,Q0,Q1 );</span><br><span class="line">    <span class="keyword">input</span> AIN,BIN,CIN,DIN;</span><br><span class="line">    <span class="keyword">output</span> Q0,Q1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> REGFILE ( D0,D1,CLK,Q );</span><br><span class="line">    <span class="keyword">input</span> D0,D1,CLK;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] Q;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> INV ( A,Z );</span><br><span class="line">    <span class="keyword">input</span> A;</span><br><span class="line">    <span class="keyword">output</span> Z;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>创建并保存文件后，我们重新进入 yosys，然后导入这三个 module：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_verilog ENCODER.v INV.v REGFILE.v</span><br><span class="line">show</span><br></pre></td></tr></table></figure>
<p>然后我们得到如下电路图：</p>
<figure>
<img src="/2022/09/13/17-54-09/image-20220913191735354-16630687321171.png" alt="image-20220913191735354">
<figcaption aria-hidden="true">image-20220913191735354</figcaption>
</figure>
<p>上述过程我们可以得知：</p>
<ul>
<li>在 TOP 层面进行描述的时候，我们不需要知道调用的 module
的内部实现，得到有意义的电路图只需要知道其端口中哪些是输入哪些是输出即可</li>
<li></li>
</ul>
<p>VerilogHDL 与 C 语言的区别：</p>
<p>与 C 语言相比，VerilogHDL 具备硬件设计的基本概念：</p>
<ul>
<li>互联（connectivity）：wire
类型变量可以描述各个模块之间的端口与网络的连接关系</li>
<li>并发（concurrency）：可以有效的描述并行的硬件系统</li>
<li>时间（time）：定义了绝对和相对的时间度量，可综合操作符具有物理延时</li>
</ul>
<p>VerilogHDL 中的并发执行：</p>
<p>以下方代码块所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP;</span><br><span class="line">    <span class="keyword">always</span> @ (*) 	<span class="comment">//并行</span></span><br><span class="line">        <span class="keyword">begin</span>		<span class="comment">//串行</span></span><br><span class="line">            <span class="keyword">if</span>()</span><br><span class="line">            <span class="keyword">if</span>()</span><br><span class="line">        <span class="keyword">end</span>			<span class="comment">//串行</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> a = b; 	<span class="comment">//并行</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 VerilogHDL 的 module 中，所有描述语句</p>
<ul>
<li>连续赋值语句（assign）</li>
<li>行为语句块（always、initial）</li>
<li>模块实例化</li>
</ul>
<p>都是并行发生的。</p>
<p>而 begin ... end 中的语句是顺序执行的。</p>
<ol type="1">
<li>门级建模：引用逻辑门实例并进行连接
<ul>
<li>优点：对于有数字逻辑基础的人来说非常直观</li>
<li>缺点：电路功能复杂时会变得非常繁琐且容易出错</li>
</ul></li>
<li>数据流建模：根据数据在寄存器之间的流动和处理过程对电路进行描述
<ul>
<li>优点：不用专注于电路结构的细节，更加灵活</li>
<li>缺点：这个建模层次不便于用来确定硬件设计的整体结构和算法</li>
<li>连续赋值语句：assign 语句——数据流建模的基本语句
<ul>
<li>使用运算符对 wire 或者 reg 变量进行运算，然后对 wire
变量进行赋值</li>
<li>建议工程中仅仅使用 assign 语句进行连线</li>
</ul></li>
</ul></li>
<li>行为级描述：从算法角度，或者说从电路外部行为角度进行描述
<ul>
<li>结构化过程语句：所有的行为级描述都出现在这两种结构化过程语句中
<ul>
<li>initial
语句：不可综合；用于仿真时进行初始化、信号监视、生成仿真波形；仿真期间仅执行一次</li>
<li>always
语句：可综合；反映了电路上电后反复执行的特点，只能使用断电（<code>$finish</code>）和中断（<code>$stop</code>）来停止</li>
<li>结构化过程语句如果包含多个行为语句，需要使用 <code>begin end</code>
构成一个语句块</li>
</ul></li>
<li>过程性赋值语句：阻塞赋值（=）和非阻塞赋值（&lt;=）
<ul>
<li>更新对象是：reg、real、integer、time</li>
<li>与连续赋值语句（assign）的区别：过程性赋值语句只有在执行到的时候才会起作用，连续性赋值语句是任何时刻的任何变化都会起作用。</li>
<li>阻塞赋值（=）：串行行为；建模组合逻辑的行为</li>
<li>非阻塞赋值（&lt;=）：并行行为；建模时序逻辑的行为</li>
</ul></li>
<li>行为级描述中的时序控制：
<ul>
<li>基于延时的时序控制：在结构化过程语句中加入延时</li>
<li>基于事件的时序控制：事件指 reg 或者 wire
变量发生了变化，可以使用事件来选择是哪些结构化过程语句在执行</li>
<li>电平敏感的时序控制：wait 语句</li>
</ul></li>
<li>行为语句：
<ul>
<li>条件语句：<code>if else</code></li>
<li>分支语句：<code>case</code></li>
<li>循环语句：<code>while</code>、<code>for</code>、<code>repeat</code>、<code>forever</code></li>
</ul></li>
<li></li>
</ul></li>
</ol>
<p>数字设计领域。RTL（寄存器传输级）通常是指数据流建模和行为级建模的结合</p>
<h4 id="逻辑综合将数据流设计转化为门级结构">逻辑综合：将数据流设计转化为门级结构</h4>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/09/02/09-01-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/02/09-01-15/" class="post-title-link" itemprop="url">verilog 开源工具链配置笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-02 09:01:15" itemprop="dateCreated datePublished" datetime="2022-09-02T09:01:15+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-08 17:22:24" itemprop="dateModified" datetime="2022-09-08T17:22:24+08:00">2022-09-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/09/02/09-01-15/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/09/02/09-01-15/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="效果展示">效果展示</h3>
<p>本文配置的最终效果展示如下：</p>
<p>Win11+VScode+oss-cad</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902092406126.png" alt="image-20220902092406126">
<figcaption aria-hidden="true">image-20220902092406126</figcaption>
</figure>
<h3 id="工具介绍及安装">工具介绍及安装</h3>
<p>首先介绍一下 VScode。VSCode（全称：Visual Studio
Code）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全等功能。VScode
的强大之处在于用户可以通过内置的扩展程序商店安装扩展以拓展软件功能。你可以在
<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">VScode 官网</a> 下载并安装
VScode，安装方法非常简单，这里不再进行说明。</p>
<p>在 verilog 开发中，我们可以通过添加 "<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=mshr-h.VerilogHDL">Verilog-HDL/SystemVerilog/Bluespec
SystemVerilog support for VS Code</a>" 插件实现 verilog
代码高亮和代码自动补全等功能。你可以直接在 VScode
的扩展中搜索并一键安装这个插件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902093933026.png" alt="image-20220902093933026">
<figcaption aria-hidden="true">image-20220902093933026</figcaption>
</figure>
<p>通过类似的方式，搜索并安装下面两个插件：</p>
<p>左边的插件可以帮助你查看综合出的 .dot
格式的电路图文件，右边的插件可以帮你根据 .vcd 文件生成波形图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902094417294.png" alt="image-20220902094417294">
<figcaption aria-hidden="true">image-20220902094417294</figcaption>
</figure>
<p>上面展示的 verilog 代码的编译和综合过程主要使用到了两个工具：iVerilog
和 Yosys。这两个工具，包括也是非常常用的波形查看工具 GTKwave
都被集成在了一个开源工具组件 OSS CAD Suite 中。OSS CAD
套件中还有很多用于数字逻辑设计的开源软件的二进制软件发行版。你可以在这个
<a target="_blank" rel="noopener" href="https://github.com/YosysHQ/oss-cad-suite-build">GitHub 页面</a>
中进行查看。</p>
<p>如果想要安装和使用 OSS CAD Suite ，我们可以直接在 <a target="_blank" rel="noopener" href="https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2022-09-01">这个界面</a>
下载 .exe 文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095721658.png" alt="image-20220902095721658">
<figcaption aria-hidden="true">image-20220902095721658</figcaption>
</figure>
<p>下载完成后直接运行这个 .exe 文件，即可获得这样一个文件夹：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095934878.png" alt="image-20220902095934878">
<figcaption aria-hidden="true">image-20220902095934878</figcaption>
</figure>
<p>我将这个 OSS CAD Suite 放在了我自己在 D盘 创建的 Program_Files
文件夹。在这个目录下，我们要重点关注第一个 bin 文件夹和最后标红的两个
.bat 文件。第一个 bin 文件夹里面是 OSS CAD Suite
介绍中所说的，用于数字逻辑设计的开源软件的二进制软件发行版。你可以从这个文件夹中找到包括
iVerilog、GTKwave 和 Yosys。</p>
<p>那么如何使用这些组件呢？ OSS CAD Suite 提供了两种方法，一种是直接点击
start.bat 文件，然后使用命令的方式进行操作：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902100630814.png" alt="image-20220902100630814">
<figcaption aria-hidden="true">image-20220902100630814</figcaption>
</figure>
<p>第二种方案是通过命令行工具，在 cmd 中调用 environment.bat
来使用该工具：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101420630.png" alt="image-20220902101420630">
<figcaption aria-hidden="true">image-20220902101420630</figcaption>
</figure>
<p>但是，之前我们的操作都是在 VScode 上进行的，所以我们希望也把 OSS CAD
Suite 的使用放在 VScode
内进行，有没有办法呢？我的解决方案是使用第二种方法调用 OSS CAD Suite
，只要使用 VScode 内置的 cmd （终端）来实现调用 environment.bat
即可。操作如下：</p>
<p>首先如下图提示的，我们使用快捷键调出终端</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101612341.png" alt="image-20220902101612341">
<figcaption aria-hidden="true">image-20220902101612341</figcaption>
</figure>
<p>我们可以将终端移动到编辑器区域：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101716445.png" alt="image-20220902101716445">
<figcaption aria-hidden="true">image-20220902101716445</figcaption>
</figure>
<p>然后我们注意到这个终端不是 cmd，而是
powershell，两者的区别读者可以自己去查一下，这里我们还是使用 cmd
来演示：注意在 cmd 中可以使用 tab 键进行补全。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102107905.png" alt="image-20220902102107905">
<figcaption aria-hidden="true">image-20220902102107905</figcaption>
</figure>
<p>到此为止我们已经进行了全部内容的安装。下面我们使用一个 4 选 1
多路选择器代码进行演示：</p>
<h3 id="使用方法">使用方法</h3>
<p>首先新建一个文件夹，然后选择使用 VScode 打开：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102705459.png" alt="image-20220902102705459">
<figcaption aria-hidden="true">image-20220902102705459</figcaption>
</figure>
<p>然后建立如下目录结构：红框内的第一个图标是新建文件，第二个是新建文件夹</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103003482.png" alt="image-20220902103003482">
<figcaption aria-hidden="true">image-20220902103003482</figcaption>
</figure>
<p>输入代码：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103049078.png" alt="image-20220902103049078">
<figcaption aria-hidden="true">image-20220902103049078</figcaption>
</figure>
<p>附上代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Verilog HDL 数字设计与综合（第二版）（本科教学版）例6.2</span></span><br><span class="line"><span class="comment">//用逻辑方程描述四选一多路选择器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux4_to_1 (out, i0, i1, i2, i3, s1, s0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接取自输入输出图的端口声明语句</span></span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">input</span> i0, i1, i2, i3, s1, s0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输出 out 的逻辑方程</span></span><br><span class="line">    <span class="keyword">assign</span> out = ( ~s1 &amp; ~s0 &amp; i0)|</span><br><span class="line">                 ( ~s1 &amp;  s0 &amp; i1)|</span><br><span class="line">                 (  s1 &amp; ~s0 &amp; i2)|</span><br><span class="line">                 (  s1 &amp;  s0 &amp; i3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写无端口激励模块</span></span><br><span class="line"><span class="comment">//为了使用yosys来进行综合，我们将电路描述模块和激励模块分离，然后对mux4_to_1.v进行单独的综合</span></span><br><span class="line"><span class="keyword">module</span> stimulus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明连接到输入端口的变量</span></span><br><span class="line">    <span class="keyword">reg</span> IN0,IN1,IN2,IN3;</span><br><span class="line">    <span class="keyword">reg</span> S1,S0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明输出连线</span></span><br><span class="line">    <span class="keyword">wire</span> OUTPUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用（实例引用）多路选择器</span></span><br><span class="line">    mux4_to_1 my_mux(OUTPUT,IN0,IN1,IN2,IN3,S1,S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输入激励信号</span></span><br><span class="line">    <span class="comment">//Define the stimulus module (no ports)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//设置输入线信号</span></span><br><span class="line">        IN0 = <span class="number">1</span>;</span><br><span class="line">        IN1 = <span class="number">0</span>;</span><br><span class="line">        IN2 = <span class="number">1</span>;</span><br><span class="line">        IN3 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;IN0 = %b, IN1 = %b, IN2 = %b, IN3 = %b&quot;</span>,IN0,IN1,IN2,IN3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产 VCD 文件需要的代码（非例题代码）</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="built_in">$dumpfile</span>(<span class="string">&quot;wave.vcd&quot;</span>); <span class="comment">//生成波形文件vcd的名称 </span></span><br><span class="line">        <span class="built_in">$dumpvars</span>(<span class="number">0</span>, stimulus); <span class="comment">//tb模块名称</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后保存文件，打开终端，先进入 oss-cad-suite 文件夹打开
environment.bat 然后再回到 verilog 文件目录下对目标文件进行操作</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103520387.png" alt="image-20220902103520387">
<figcaption aria-hidden="true">image-20220902103520387</figcaption>
</figure>
<p>然后进行编译等一系列操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iverilog -o mux4_to_1<span class="variable">.vvp</span> -y ./ mux4_to_1_tb<span class="variable">.v</span> mux4_to_1<span class="variable">.v</span></span><br><span class="line">vvp mux4_to_1<span class="variable">.vvp</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104216297.png" alt="image-20220902104216297">
<figcaption aria-hidden="true">image-20220902104216297</figcaption>
</figure>
<p>然后在终端可以看到 <code>$display()</code> 的内容，然后我们查看 .vcd
文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104553493.png" alt="image-20220902104553493">
<figcaption aria-hidden="true">image-20220902104553493</figcaption>
</figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104654196.png" alt="image-20220902104654196">
<figcaption aria-hidden="true">image-20220902104654196</figcaption>
</figure>
<p>接下来我们进行综合：</p>
<p>首先进入 yosys，然后读入文件，处理文件，最后导出 .dot 格式</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105334206.png" alt="image-20220902105334206">
<figcaption aria-hidden="true">image-20220902105334206</figcaption>
</figure>
<p>过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_verilog mux4_to_1.v</span><br><span class="line">hierarchy -check</span><br><span class="line">proc; opt; opt; fsm; memory; opt</span><br><span class="line">show -format dot -prefix ./mux4_to_1</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<p>最终结果展示：其中 <code>.dot</code> 文件打开后可以使用快捷键
<code>Ctrl+Shift+v</code> 得到可视化电路图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105858211.png" alt="image-20220902105858211">
<figcaption aria-hidden="true">image-20220902105858211</figcaption>
</figure>
<p>注：默认不读入工艺库的话，Yosys 使用自带的工艺库。</p>
<h3 id="isseus-and-solution">Isseus and Solution</h3>
<p>这一小节记录一下我初用这个工具链遇到的问题：</p>
<ol type="1">
<li><p><strong>Isseus：</strong>进行编译和波形测试时，发现VScode上的WaveTrace插件不能正常进行查看，但是使用GTKwave开源查看，我的编译仿真指令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iverilog -o wave -y ./  alu_tb.v  alu.v </span><br><span class="line">vvp -n wave -lxt2</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>使用下面的指令来生成 .vcd 图像：即不要携带
<code>-lxt2</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vvp wave</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Isseus：</strong>Yosys 出现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: System task `$display&#x27; called with invalid/unsupported format specifier.</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>如果出现这个报错，考虑将测试的module放在一个单独的文件中，使yosys操作的对象不包括测试使用的module</p></li>
<li><p><strong>Isseus：</strong>==待解决==在 Yosys 命令行中使用 help
指令可以看到 Yosys 中提供指令可以导出有限状态机的图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194326503.png" alt="image-20220904194326503">
<figcaption aria-hidden="true">image-20220904194326503</figcaption>
</figure>
<p>即指令
<code>fsm_export</code>，但是在实际操作中使用该指令后打印如下日志：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194520104.png" alt="image-20220904194520104">
<figcaption aria-hidden="true">image-20220904194520104</figcaption>
</figure>
<p>但是没有 KISS2 文件在操作目录下生成。</p>
<p><strong>Solution：</strong>这个问题目前没有被解决，但是这里有两个网页可以提供重要参考</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys/issues/2402">Command
"fsm_export" does not generate a .kiss2 file to represent correspondings
FSM · Issue #2402 · YosysHQ/yosys</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32645965/fsm-export-using-yosys">verilog
- FSM export using Yosys - Stack Overflow</a></li>
</ol></li>
</ol>
<h3 id="在-yosys-中使用工艺库">在 Yosys 中使用工艺库</h3>
<p>在上面的过程中，我们使用 Yosys 读入 <code>.v</code>
文件，将高层次的描述转化为寄存器传输级描述（RTL）进而得到门级描述，然后在转化中我们都进行了化简和优化。得到的门级描述使用
Yosys 自带的单元（cells）进行的描述。我们可以在 Yosys中使用指令
<code>help -cells</code> 来查看 Yosys 默认使用的单元列表：如下图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905081644337.png" alt="image-20220905081644337">
<figcaption aria-hidden="true">image-20220905081644337</figcaption>
</figure>
<p>我们可以看到 Yosys 中包含有 <code>$_AND_</code> 或者
<code>$_ANDNOT_</code>
这种单元。首先我们先用默认的单元来综合我们的电路，然后导入新的单元来构建满足新工艺库的电路。</p>
<p>用来演示的 Verilog 文件来自
<code>..\yosys-master\yosys-master\examples\cmos</code>，你可以在<a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys/tree/master/examples/cmos">这里</a>查看。</p>
<p>首先我在 <code>..\yosys-master\yosys-master\examples</code>
目录下创建了一个新的文件夹 <code>my_cmos</code>，然后将
<code>cmos</code> 中的 <code>counter.v</code> 文件移动到
<code>my_cmos</code> 中，然后复制<a target="_blank" rel="noopener" href="https://vlsiarch.ecen.okstate.edu/flows/MOSIS_SCMOS/latest/cadence/lib/tsmc025/signalstorm/osu025_stdcells.lib">这里</a>的代码到
<code>my_cmos</code> 文件夹中并命名为
<code>osu025_stdcells.lib</code>。最后使用 oss-cad 组件打开
<code>my_cmos</code> 这个文件夹进行后续操作。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905093413337.png" alt="image-20220905093413337">
<figcaption aria-hidden="true">image-20220905093413337</figcaption>
</figure>
<p>然后进入 Yosys，使用下述指令读入文件到
Yosys：这是我们导入自己的单元库的方法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_verilog counter.v</span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905094143056.png" alt="image-20220905094143056">
<figcaption aria-hidden="true">image-20220905094143056</figcaption>
</figure>
<p>现在我们使用快捷键 <code>Ctrl+D</code> 退出
Yosys。然后我们来生成电路图展示一下 yosys 对于电路图的处理。同时我们引入
yosys 指令批量处理的方法：</p>
<p>首先将下述指令复制到一个新建文件夹 <code>my_cells.ys</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读入 counter.v</span></span><br><span class="line">read_verilog counter.v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读入后不做任何处理直接显示 counter.v 电路图，生成的文件起名为 a.dot</span></span><br><span class="line">show -prefix ./a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">synth 指令由一些列综合和化简指令构成，这个命令组最后的效果是得到由 yosys 自带的 cells 构建的电路图</span></span><br><span class="line">synth</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将化简后的结果显示成电路图b</span></span><br><span class="line">show -prefix ./b</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入 osu025_stdcells.lib，用库中的 FF(flip-flop) 去替换 yosys 自带的 FF</span></span><br><span class="line">dfflibmap -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将替换触发器后的电路图导出为c</span></span><br><span class="line">show -prefix ./c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换自带的组合逻辑器件</span></span><br><span class="line">abc -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">化简</span></span><br><span class="line">opt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将替换组合逻辑器件后的电路图导出为d</span></span><br><span class="line">show -prefix ./d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读入 osu025_stdcells.lib，yosys可以将其中的cells转化为modules</span></span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最终结果e,只展示 couter module，不展示 osu025_stdcells.lib 中的modules</span></span><br><span class="line">show -prefix ./e counter</span><br></pre></td></tr></table></figure>
<p>然后在 oss-cad 组件中使用 <code>yosys -s my_cells.ys</code>
来批量执行指令</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105049582.png" alt="image-20220905105049582">
<figcaption aria-hidden="true">image-20220905105049582</figcaption>
</figure>
<p>然后打开 <code>.dot</code> 文件观察结果</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105508223.png" alt="image-20220905105508223">
<figcaption aria-hidden="true">image-20220905105508223</figcaption>
</figure>
<p>这两张图重复了使用方法一节中展现的化简过程</p>
<p>然后我们观察后面几张图</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905110336491.png" alt="image-20220905110336491">
<figcaption aria-hidden="true">image-20220905110336491</figcaption>
</figure>
<p>上图为了进行对比，可能图片不是非常清晰，大家可以自己动手做一下然后进行观察。</p>
<p>到此我们就实现了自己的cells库的导入，你可以进一步通过
<code>write_verilog</code> 指令导出综合后的电路图。</p>
<h3 id="进一步的参考">进一步的参考</h3>
<p>如果想要进一步了解 Yosys 的使用，推荐使用 <a target="_blank" rel="noopener" href="https://yosyshq.net/yosys/files/yosys_appnote_011_design_investigation.pdf">Yosys
AppNote 011</a>、<a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">Yosys
manual</a> 两篇文章进行学习</p>
<p>如果想要配置 STA 工具，可以参考此工具 <a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">OpenTimer</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/07/30/15-15-44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/30/15-15-44/" class="post-title-link" itemprop="url">Spieed Maix Duino开发板使用小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-30 15:15:44 / 修改时间：17:25:50" itemprop="dateCreated datePublished" datetime="2022-07-30T15:15:44+08:00">2022-07-30</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/07/30/15-15-44/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/07/30/15-15-44/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="sipeed-maixduino使用小记">SIPEED MaixDuino使用小记</h1>
<h2 id="开箱跑例程">开箱跑例程</h2>
<p>开箱后将摄像头、TF卡、显示屏都装到开发板上，上电后如下图所示。</p>
<figure>
<img src="/2022/07/30/15-15-44/88b4b368daca77a34d4d3d51c32b1ff.jpg" alt="88b4b368daca77a34d4d3d51c32b1ff">
<figcaption aria-hidden="true">88b4b368daca77a34d4d3d51c32b1ff</figcaption>
</figure>
<p>在<a target="_blank" rel="noopener" href="https://dl.sipeed.com/shareURL/MAIX/tools/ftdi_vcp_driver">此处</a>安装驱动：选择第二个</p>
<p><img src="/2022/07/30/15-15-44/image-20220730150511809.png" alt="image-20220730150511809"></p>
<p>解压下载好的文件，然后安装INF文件；两个INF文件都要安装：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730150747127.png" alt="image-20220730150747127">
<figcaption aria-hidden="true">image-20220730150747127</figcaption>
</figure>
<p>下载<a target="_blank" rel="noopener" href="https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/v0.2.5">官方IDE</a>：下载.exe文件进行安装</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151011092.png" alt="image-20220730151011092">
<figcaption aria-hidden="true">image-20220730151011092</figcaption>
</figure>
<p>验证摄像头：第一步点击连接后需要选择串口，MaixDuino会在电脑上产生两个串口，其中一个可以使用，自行测试。</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151246776.png" alt="image-20220730151246776">
<figcaption aria-hidden="true">image-20220730151246776</figcaption>
</figure>
<p>进行终端测试：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152150910-16591657134626.png" alt="image-20220730152150910">
<figcaption aria-hidden="true">image-20220730152150910</figcaption>
</figure>
<p>使用串口连接：直接点确定，一路确定，采用默认模式即可</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152231846.png" alt="image-20220730152231846">
<figcaption aria-hidden="true">image-20220730152231846</figcaption>
</figure>
<p>然后就进入了串口中断模式：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152322518.png" alt="image-20220730152322518">
<figcaption aria-hidden="true">image-20220730152322518</figcaption>
</figure>
<p>在官方文档的<a target="_blank" rel="noopener" href="https://wiki.sipeed.com/soft/maixpy/zh/get_started/get_started_power_on.html">此处</a>浏览例程，使用串口终端模式进行测试：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/06/24/15-48-41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/24/15-48-41/" class="post-title-link" itemprop="url">STM32G431-Nucleo-64开发板使用小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-24 15:48:41" itemprop="dateCreated datePublished" datetime="2022-06-24T15:48:41+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-26 08:53:38" itemprop="dateModified" datetime="2023-08-26T08:53:38+08:00">2023-08-26</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/06/24/15-48-41/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/06/24/15-48-41/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="stm32g431-nucleo-64开发板使用小记">STM32G431-Nucleo-64开发板使用小记</h1>
<h2 id="stm32g431-nucleo-64开发板">STM32G431-Nucleo-64开发板</h2>
<h3 id="基本介绍">基本介绍</h3>
<p>实物图片：<img src="/2022/06/24/15-48-41/en.nucleo-g431rb.jpg" alt="en.nucleo-g431rb"></p>
<p>引脚示意图：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625140101348.png" alt="image-20220625140101348">
<figcaption aria-hidden="true">image-20220625140101348</figcaption>
</figure>
<p>特别提醒：如果要设置频率为170MHz（最大频率），需要修改输入为24MHz</p>
<p><img src="/2022/06/24/15-48-41/image-20220702201055670.png" alt="image-20220702201055670" style="zoom:50%;"></p>
<h3 id="点亮led灯">点亮LED灯</h3>
<h4 id="软件选择">软件选择</h4>
<p>使用CubeMX与MAD-ARM</p>
<ul>
<li><p>STMCubeMX：</p>
<p>STMCubeMX是ST公司推出的一种自动创建单片机工程及初始化代码的工具。</p></li>
<li><p>MDK-ARM：</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序。</p></li>
</ul>
<h4 id="实验流程">实验流程</h4>
<p>使用 CubeMX 生成初始化代码 -&gt; 使用 MDK-ARM 编写主函数并编译 -&gt;
使用开发板自带的ST-LINK将编译好的程序烧录到开发板 -&gt; 搭建实物电路
-&gt; 开发板上电，观察现象。</p>
<h4 id="具体操作">具体操作</h4>
<p>打开CubeMX，可以看到如下界面。点击红色方框内的ACCESS TO MCU
SELECTRO选择芯片型号。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624155754981.png" alt="image-20220624155754981">
<figcaption aria-hidden="true">image-20220624155754981</figcaption>
</figure>
<p>输入芯片型号查找对应芯片，选择“STM32G431RBT6”芯片。具体操作如图所示，操作执行后点击Start
Progect进入配置页面。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161212803.png" alt="image-20220624161212803">
<figcaption aria-hidden="true">image-20220624161212803</figcaption>
</figure>
<p>芯片配置页面如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161504627.png" alt="image-20220624161504627">
<figcaption aria-hidden="true">image-20220624161504627</figcaption>
</figure>
<p>配置包括 “Pinout &amp; Configuration”、“Clock
Configuration”、“Project Manager” 和 “Tools”。</p>
<p>首先配置 “Project Manager”，方式如下：其中 “Code Generator” 和
“Advanced Setings” 暂时用不到。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162039334.png" alt="image-20220624162039334">
<figcaption aria-hidden="true">image-20220624162039334</figcaption>
</figure>
<p>想要点亮LED灯，我们需要对GPIO引脚进行控制，因此返回 “Pinout &amp;
Configuration” 配置选项卡，进行输入输出引脚配置。我们选择引脚 PC3
，将其初始化为高电平，并将输出电平再高低之间进行切换，使用HEL函数延时，每隔1000ms进行一次变换。具体操作如图所示：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162854160.png" alt="image-20220624162854160">
<figcaption aria-hidden="true">image-20220624162854160</figcaption>
</figure>
<p>最后点击生成代码。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624163308481.png" alt="image-20220624163308481">
<figcaption aria-hidden="true">image-20220624163308481</figcaption>
</figure>
<p>使用MDK-ARM打开工程，查看CubeMX生成的代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624164703328.png" alt="image-20220624164703328">
<figcaption aria-hidden="true">image-20220624164703328</figcaption>
</figure>
<p>在主函数中插入我们要编写的LED闪烁代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624172922991.png" alt="image-20220624172922991">
<figcaption aria-hidden="true">image-20220624172922991</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624173238440.png" alt="image-20220624173238440">
<figcaption aria-hidden="true">image-20220624173238440</figcaption>
</figure>
<p>连接电路图，结果展示：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624174456175.png" alt="image-20220624174456175" style="zoom:33%;"></p>
<h3 id="开发板配置">开发板配置</h3>
<p>开发板中的用户按键是高电平有效，默认状态下接PC13。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702140416463.png" alt="image-20220702140416463">
<figcaption aria-hidden="true">image-20220702140416463</figcaption>
</figure>
<p>ST Board 的默认配置中使用外部中断配置按键。</p>
<p>如果使用GPIO口输入模式来实现按键行为，则需要配置为 Pull-down 模式</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624174830465.png" alt="image-20220624174830465">
<figcaption aria-hidden="true">image-20220624174830465</figcaption>
</figure>
<p>基本工程配置：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175021820.png" alt="image-20220624175021820">
<figcaption aria-hidden="true">image-20220624175021820</figcaption>
</figure>
<p>直接生成工程：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175042732.png" alt="image-20220624175042732">
<figcaption aria-hidden="true">image-20220624175042732</figcaption>
</figure>
<p>可以看到，针对于这个开发板，默认芯片时钟配置如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624180243123.png" alt="image-20220624180243123">
<figcaption aria-hidden="true">image-20220624180243123</figcaption>
</figure>
<h3 id="学习使用cubemx中的example">学习使用CubeMX中的Example</h3>
<p>首先打开CubeMX进入工程选项界面，选择 “Example Selector” 。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192415831.png" alt="image-20220624192415831">
<figcaption aria-hidden="true">image-20220624192415831</figcaption>
</figure>
<p>续：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192555608.png" alt="image-20220624192555608">
<figcaption aria-hidden="true">image-20220624192555608</figcaption>
</figure>
<p>在生成选项中，选择生成目录，然后直接使用MDK-ARM打开即可：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624192653458.png" alt="image-20220624192653458" style="zoom:30%;"></p>
<p>打开文档中的readme.txt文件，阅读该例程的使用方法：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624193003158.png" alt="image-20220624193003158">
<figcaption aria-hidden="true">image-20220624193003158</figcaption>
</figure>
<p>阅读文档可知，PA08-PA11分别输出四种不同占空比的PWM波形。</p>
<p>编译文件并烧录到开发板中，使用示波器测试PWM波形，得如下结果：</p>
<p>如果对Example中的代码进行了修改并重新编译，可能烧录会出现报错，报错如下：</p>
<p><img src="/2022/06/24/15-48-41/image-20220625170231754.png" alt="image-20220625170231754" style="zoom: 25%;"></p>
<p>该报错可阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42108484/article/details/81272006">此文章</a>寻求解决方案。</p>
<h3 id="按键控制led灯">按键控制LED灯</h3>
<p>首先打开之前 Nucleo-G431RB 的 CubeMX 工程文档，打开其中的
“Nucleo-G431RB_TEST.ioc” 文件：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162251778.png" alt="image-20220625162251778">
<figcaption aria-hidden="true">image-20220625162251778</figcaption>
</figure>
<p>将其中的 PC2 GPIO口配置为输入 IO
口，具体配置为输入模式、上拉输入。</p>
<p>注意：选择 GPIO
口的输入配置要依据实际电路的连接方式。在我的电路连接中，我将按键的一端与开发板的
GND 相连，另一端与 PC2 相连。则此时应该选择上拉输入——IO
口没有外部信号输入时，STM32
检测到是高电平，有信号时（按键按下时），跟随信号电平（接地，变为低电平）。</p>
<p>将 PC3 GPIO口配置为输出，默认输出为高电平（执行初始化函数
<code>MX_GPIO_Init()</code> 时会输出高电平）。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162220949.png" alt="image-20220625162220949">
<figcaption aria-hidden="true">image-20220625162220949</figcaption>
</figure>
<p>生成代码，使用MDK-ARM打开生成好的工程文件，在工程文件中的 main.c
文件做如下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUTTON HAL_GPIO_ReadPin(Button_In_GPIO_Port, Button_In_Pin)</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_GPIO_WritePin(User_White_LED_GPIO_Port, User_White_LED_Pin, GPIO_PIN_RESET);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">      <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">        <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          HAL_Delay(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">while</span>(BUTTON == <span class="number">0</span>);</span><br><span class="line">            HAL_GPIO_TogglePin(User_White_LED_GPIO_Port, User_White_LED_Pin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，即可连接电路，检验效果。上述代码执行效果为：</p>
<p>按下按键时可以检测到按键被按下，松手后执行任务（改变LED灯亮灭）。</p>
<p>效果如图：</p>
<h3 id="串口通信">串口通信</h3>
<p>STM32中串口通信有三种方式：</p>
<ul>
<li><p>轮询</p>
<ul>
<li>轮询式串口通信：在主函数的 <code>while(1)</code>
中不停地调用串口通信函数进行通信。</li>
<li>优点：实现逻辑简单</li>
<li>缺点：查询方式下CPU的负担较重，浪费了处理器的能力，不能够很好的处理其他的事件</li>
</ul></li>
<li><p>中断</p>
<ul>
<li><p>中断式串口通信：在接收到信息或需要发送数据时产生中断，在中断服务程序中完成数据的接收与发送。</p></li>
<li><p>优点：相比于轮询式，中断式对CPU利用率要高。</p></li>
<li><blockquote>
<p>缺点：</p>
<p>复杂的系统中，比如移动机器人，处理器需要处理串行口通信，多个传感器数据的采集以及处理，实时轨迹的生成，运动轨迹插补以及位置闭环控制等等任务，牵扯到多个中断的优先级分配问题。为了保证数据发送与接收的可靠性，需要把UART的中断优先级设计较高，但是系统可能还有其他的需要更高优先级的中断，必须保证其定时的准确，这样就有可能造成串行通讯的中断不能及时响应，从而造成数据丢失。</p>
</blockquote></li>
</ul></li>
<li><p>DMA</p>
<ul>
<li>DMA：Direct Memory Access
（直接内存访问）。使用DMA进行串口通信时，CPU只需要数据传输开始和结束时做一点处理外，在传输过程中可以进行其他的工作。</li>
<li>如果传输的数据量较大，或者传输速度超过115200时，建议选择DMA方式实现串口通信。</li>
</ul></li>
</ul>
<p>串口通信函数：推荐使用C标准库中的 <code>printf()</code>
函数进行串口通信。想要在单片机使用 <code>printf()</code> 需要：</p>
<ol type="1">
<li>包含头文件 <code>#include &lt;stdio.h&gt;</code></li>
<li>在 Options for Target... 选项卡的 Target 选项栏中的 Code Generation
区域勾选 Use MicroLIB</li>
<li>进行串口重定向——即重新实现 <code>fputc()</code></li>
</ol>
<h4 id="查询模式-printf函数重定向">查询模式 &amp;
printf()函数重定向</h4>
<p>配置串口：注意在Nucleo-G431RB开发板上只能使用 PA2 和 PA3
引脚来实现开发板接usb线与电脑进行串口通信。其中 PA2 和 PA3 引脚可以选择
LPUART1 和 USART2 两种。这里我们选择 LPUART1
进行测试。串口调试的配置与串口测试软件保持一致即可。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627201123958.png" alt="image-20220627201123958">
<figcaption aria-hidden="true">image-20220627201123958</figcaption>
</figure>
<p>生成代码，打开工程，进行工程设置：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201706218.png" alt="image-20220627201706218" style="zoom: 40%;"></p>
<p>如果不设置使用 Use MicroLIB，也可以添加如下代码实现串口重定向：</p>
<p><img src="/2022/06/24/15-48-41/image-20220703135818223.png" alt="image-20220703135818223" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>添加代码：</p>
<ol type="1">
<li><p>添加头文件：user_log.h文件见目录： “HAL库小记 -&gt; 串口调试策率
-&gt; 日志打印文件”</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202133564.png" alt="image-20220627202133564" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>重写 <code>fputc()</code> 函数：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201930878.png" alt="image-20220627201930878" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录另一种写法，或许会更加规范（适用范围广）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	HAL_UART_Transmit(&amp;huart2, (<span class="type">uint8_t</span>*) &amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//网上说现在还需要加上这个函数，但是我没使用过gcc编译所以没有验证过这部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_write函數在syscalls.c中， 使用__weak定義， 所以可以直接在其他文件中定義_write函數</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((weak)) <span class="type">int</span> _write(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> DataIdx;</span><br><span class="line">	<span class="keyword">for</span> (DataIdx = <span class="number">0</span>; DataIdx &lt; len; DataIdx++)</span><br><span class="line">	&#123;</span><br><span class="line">		__io_putchar(*ptr++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加测试代码：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202102623.png" alt="image-20220627202102623" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">user_main_info(<span class="string">&quot;init HAL&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;Config System Clock&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;GPIO init finished&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;UART init finished&quot;</span>);</span><br><span class="line"> <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* Infinite loop */</span></span><br><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br><span class="line"></span><br><span class="line">user_main_info(<span class="string">&quot;Enter while(1)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>测试结果：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202356953.png" alt="image-20220627202356953" style="zoom:50%;"></p>
<h4 id="中断方式">中断方式</h4>
<p>使用CubeMX配置串口，打开相应串口中断</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220703175857659.png" alt="image-20220703175857659">
<figcaption aria-hidden="true">image-20220703175857659</figcaption>
</figure>
<p>打开工程，修改 uart.c 实现串口重定向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>打开 main.c，配置中断服务函数</p>
<h4 id="dma">DMA</h4>
<p><strong>DMA传输方式</strong></p>
<p><strong>方法1</strong>：DMA_Mode_Normal，正常模式，</p>
<p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次　</p>
<p><strong>方法2</strong>：DMA_Mode_Circular ，循环传输模式</p>
<p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。也就是多次传输模式</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MDg4OTMwMw==&amp;mid=2247496701&amp;idx=3&amp;sn=f5876279a224d3f4fb3eca76c7027e00&amp;chksm=e9f9e6c5de8e6fd3609e133873cf85c922fd9243579cf11cf14a658b248484579659288a0518&amp;scene=21#wechat_redirect">DMA原理</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92379957">Map回调函数</a></p>
<p>https://www.its203.com/article/qq_26575553/89374803#:~:text=%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8F1%E7%9A%84MCU%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AFF2...F4%EF%BC%8C%E7%94%9A%E8%87%B3</p>
<h3 id="寸-tft-lcd显示">1.8寸 TFT LCD显示</h3>
<p>使用CubeMX配置引脚，其中 PA5 引脚连接VCC供电。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627183433259.png" alt="image-20220627183433259">
<figcaption aria-hidden="true">image-20220627183433259</figcaption>
</figure>
<p>生成代码，然后对代码进行修改：</p>
<ol type="1">
<li><p>解压LCD_Driver.zip到CubeMX生成的MDK-ARM文件加中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200134162.png" alt="image-20220627200134162" style="zoom:50%;"></p></li>
<li><p>打开工程，将解压的文件添加的你的工程中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200249439.png" alt="image-20220627200249439" style="zoom:50%;"></p></li>
<li><p>将头文件包含到main.c文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pic.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开lcd_init.h文件，修改其中的 “LCD端口定义”
，将端口定义与连线相匹配。</p></li>
<li><p>注释掉主函数中的 <code>MX_GPIO_Init();</code>
并将复制下述代码进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LCD_Init();<span class="comment">//LCD初始化</span></span><br><span class="line">LCD_Fill(<span class="number">0</span>,<span class="number">0</span>,LCD_W,LCD_H,WHITE);</span><br><span class="line">LCD_ShowString(<span class="number">24</span>,<span class="number">30</span>,<span class="string">&quot;Hello,World!&quot;</span>,RED,WHITE,<span class="number">16</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627200731016.png" alt="image-20220627200731016">
<figcaption aria-hidden="true">image-20220627200731016</figcaption>
</figure></li>
</ol>
<h3 id="定时器">定时器</h3>
<p>使用STM32的定时器首先要理解STM32的时钟树，STM32中的时钟源是可配置的。有三种时钟源供选择：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628140231418.png" alt="image-20220628140231418" style="zoom: 25%;"></p>
<p>由一个三路选择器组成的系统时钟选择器，可以选择下面三种时钟源的一种作为系统时钟源：</p>
<ul>
<li>高速外部时钟HSE
<ul>
<li>优点：外部时钟产生的时钟频率较为精确</li>
</ul></li>
<li>高速内部时钟HSI
<ul>
<li>优点：功耗低，不需要额外的器件，起震快</li>
<li>缺点：但是精度不能保证</li>
</ul></li>
<li>锁相环时钟PLLCLK
<ul>
<li>锁相环可以用来倍频，开发板上外接8M晶振，但是STM32主频却能跑72M，这离不开锁相环（PLL）的作用。</li>
</ul></li>
</ul>
<p>定时器要实现计数必须有个时钟源，<strong>基本定时器时钟只能来自内部时钟，高级控制定时器和通用定时器还可以选择外部时钟源或者直接来自其他定时器等待模式</strong>。</p>
<blockquote>
<p>F407有三种时钟源可以用作系统时钟：内部高速时钟、外部高速时钟、PLL时钟。
一般我们希望芯片工作在最高频率168MHz，而无论是内部还是外部时钟都是达不到的，所以通常都是用PLL时钟作为系统时钟。
外部时钟通常都比内部时钟要稳定精确，所以一般还会用外部时钟作为PLL的输入。
F407还有一个低速时钟用来驱动RTC，以及满足低电压模式下的功能需求。</p>
<p>通常系统总线AHB的频率设置为168MHz，高速外设总线APB2频率设置为84MHz，低速外设总线APB1频率设置为42MHz。
这些总线频率可以通过配置RCC_CFGR和RCC_PLLCFGR实现。</p>
</blockquote>
<h3 id="gps模块">GPS模块</h3>
<p>GPS模块硬件可以将卫星传来的信号进行收集，然后我们可以通过串口通信的方式从GPS模块中读取卫星报文。读取后的报文我们可以将其缓存下来，然后进行译码。</p>
<p>了解了 NMEA 格式有之后，我们就可以编写相应的解码程序了，而程序员
Tim(<a href="mailto:xtimor@gmail.com">xtimor@gmail.com</a>)提供了一个非常完善的
NMEA 解码库，在以下网址可以下载到：http://nmea.sourceforge.net/
，直接使用该解码库，可以避免重复发明轮子的工作。</p>
<h3 id="移植-multibutton">移植 <a target="_blank" rel="noopener" href="https://github.com/0x1abin/MultiButton">MultiButton</a></h3>
<h4 id="multibutton简介">MultiButton简介</h4>
<p>Github里面的嵌入式开源项目，一个小巧简单易用的事件驱动型按键驱动模块，可无限量扩展按键，能够实现下述按键事件：</p>
<table>
<thead>
<tr class="header">
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRESS_DOWN</td>
<td>按键按下，每次按下都触发</td>
</tr>
<tr class="even">
<td>PRESS_UP</td>
<td>按键弹起，每次松开都触发</td>
</tr>
<tr class="odd">
<td>PRESS_REPEAT</td>
<td>重复按下触发，变量repeat计数连击次数</td>
</tr>
<tr class="even">
<td>SINGLE_CLICK</td>
<td>单击按键事件</td>
</tr>
<tr class="odd">
<td>DOUBLE_CLICK</td>
<td>双击按键事件</td>
</tr>
<tr class="even">
<td>LONG_PRESS_START</td>
<td>达到长按时间阈值时触发一次</td>
</tr>
<tr class="odd">
<td>LONG_PRESS_HOLD</td>
<td>长按期间一直触发</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用">在STM32G431-Nucleo-64开发板中使用</h4>
<p>首先使用CubeMX建立一个工程，初始化串口、测试LED和测试按键的GPIO口：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160405595.png" alt="image-20220702160405595" style="zoom:67%;"></p>
<p>生成代码，打开工程文件夹：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160514425.png" alt="image-20220702160514425" style="zoom:50%;"></p>
<p>然后在<a target="_blank" rel="noopener" href="https://github.com/0x1abin/MultiButton">此处</a>下载项目文件到本地：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160023733.png" alt="image-20220702160023733" style="zoom:50%;"></p>
<p>将红框内的源文件放入到工程文件夹的MDK-ARM文件夹中，这里我给源文件了一个单独的文件夹</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160647623.png" alt="image-20220702160647623" style="zoom:50%;"></p>
<p>同时我也移植了我们之前使用的 “user_log.h” 文件。</p>
<p>打开工程，从工程外部添加文件：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702161216790.png" alt="image-20220702161216790" style="zoom: 50%;"></p>
<p><img src="/2022/06/24/15-48-41/image-20220702161310298.png" alt="image-20220702161310298" style="zoom:50%;"></p>
<p>源文件中的头文件，可以添加进来，也可以不添加，只要添加头文件的查找地址，然后在写代码时包含头文件即可：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702161547708.png" alt="image-20220702161547708">
<figcaption aria-hidden="true">image-20220702161547708</figcaption>
</figure>
<h4 id="编写测试代码">编写测试代码</h4>
<ol type="1">
<li><p>打开 uart.c 文件，添加串口重定向代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开 main.c 文件</p>
<ol type="1">
<li><p>添加新的包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multi_button.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加新的变量声明——按键结构体声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Button</span> <span class="title">button1</span>;</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br></pre></td></tr></table></figure></li>
<li><p>回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">read_button1_GPIO</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_callback</span><span class="params">(<span class="type">void</span> *button)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> btn_event_val; </span><br><span class="line">    btn_event_val = get_button_event((<span class="keyword">struct</span> Button *)button); </span><br><span class="line">    <span class="keyword">switch</span>(btn_event_val)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> PRESS_DOWN:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press down! &lt;---\r\n&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_UP: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 press up! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_REPEAT: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press repeat! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> SINGLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 single click! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> DOUBLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 double click! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_START: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 long press start! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_HOLD: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 long press hold! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入 <code>main()</code> 函数，<code>while(1)</code>
之前：初始化对象 -&gt; 注册函数 -&gt; 启动函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_LPUART1_UART_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">	HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MultiButton Test...\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化按键对象</span></span><br><span class="line">	button_init(&amp;button1, read_button1_GPIO, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册函数</span></span><br><span class="line">	button_attach(&amp;button1, PRESS_DOWN,       button_callback);</span><br><span class="line">	button_attach(&amp;button1, PRESS_UP,         button_callback);</span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, PRESS_REPEAT,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, SINGLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, DOUBLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_START, button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_HOLD,  button_callback);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动按键</span></span><br><span class="line">	button_start(&amp;button1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置一个5ms间隔的定时器循环调用后台处理函数，可以在while(1)中使用滴答定时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每隔5ms调用一次后台处理函数</span></span><br><span class="line">button_ticks();</span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>勾选使用 MicroLIB</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162518916.png" alt="image-20220702162518916" style="zoom: 33%;"></p></li>
<li><p>编译，烧录，打开串口助手，测试：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162754097.png" alt="image-20220702162754097" style="zoom: 33%;"></p></li>
</ol>
<h3 id="移植-guilite">移植 <a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLite">GuiLite</a></h3>
<h4 id="简介">简介</h4>
<p>GuiLite是一个轻量的，可以运行在MPU平台的开源图形库。</p>
<p>只要能点亮你的显示屏上一个像素点，就可以使用这个图形库绘制出复杂的图形。</p>
<p>GuiLite还支持多个平台：</p>
<ul>
<li><p>支持的操作系统：iOS/macOS/WatchOS，Android，Linux（ARM/x86-64），Windows（包含VR），RTOS...
甚至<strong>无操作系统的单片机</strong></p></li>
<li><p>支持的开发语言： C/C++, Swift, Java, Javascript, C#,
Golang...</p></li>
<li><p>支持的第3方库：Qt, MFC, Winforms, CoCoa...</p></li>
</ul>
<p>⚙️️最低硬件要求:</p>
<table>
<thead>
<tr class="header">
<th>Processor</th>
<th>Disk/ROM space</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>24 MHZ</td>
<td>29 KB</td>
<td>9 KB</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用-1">在STM32G431-Nucleo-64开发板中使用</h4>
<p>在TFT屏示例的基础上进行GUI测试：</p>
<p>此处注意，可能会需要扩大默认的堆空间长度，具体操作如下：</p>
<ol type="1">
<li><p>CubeMX中修改堆的大小：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213417565.png" alt="image-20220702213417565" style="zoom: 25%;"></p></li>
<li><p>打开stm32的启动代码（汇编代码）即可看到修改成功：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213543120.png" alt="image-20220702213543120" style="zoom: 25%;"></p></li>
</ol>
<p>移植过程：</p>
<ol type="1">
<li><p>点击<a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLite">此处</a>下载源代码，在<a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLiteSamples">此处</a>下载Example；我们需要Example进行测试。</p></li>
<li><p>将Example中的实例代码放到自己的工程中，以Hello3DWave为例：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214620179.png" alt="image-20220702214620179" style="zoom: 50%;"></p>
<p>将这两个文件复制到自己的工程中，可以新建一个名为UIcode的文件夹存放。</p></li>
<li><p>在自己的keil工程中的Target中新建一个Group：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214000568.png" alt="image-20220702214000568" style="zoom:33%;"></p></li>
<li><p>将例程代码添加到Group中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214312012.png" alt="image-20220702214312012" style="zoom:50%;"></p></li>
<li><p>添加完成后即可编写代码，注意：检查自己的工程中是否勾选了Use
MicroLIB，如果勾选了就要取消勾选，因为我们需要编译器去解析.cpp文件，不能使用C库</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214859697.png" alt="image-20220702214859697" style="zoom:50%;"></p>
<h4 id="编写测试代码-1">编写测试代码</h4>
<ol type="1">
<li><p>在 main.c 中重新实现延时和绘制像素点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">//延时1ms函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	HAL_Delay(ms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB888转RGB565</span></span><br><span class="line"><span class="comment">//Transfer GuiLite 32 bits color to your LCD color</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_RGB_32_to_16(rgb) (((((unsigned int)(rgb)) &amp; 0xFF) &gt;&gt; 3) | ((((unsigned int)(rgb)) &amp; 0xFC00) &gt;&gt; 5) | ((((unsigned int)(rgb)) &amp; 0xF80000) &gt;&gt; 8))</span></span><br><span class="line"><span class="comment">//Encapsulate your LCD driver:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gfx_draw_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//LCD_Fast_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span></span><br><span class="line">  <span class="comment">//添加带颜色的画点函数</span></span><br><span class="line">  LCD_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UI entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DISPLAY_DRIVER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span> (*draw_pixel)(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">	<span class="type">void</span> (*fill_rect)(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">&#125; my_driver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//extern function</span></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>上面代码中的倒数第二行 <code>//extern function</code>
中的函数声明要去 UIcode.cpp 的最后去找</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220704151857006.png" alt="image-20220704151857006">
<figcaption aria-hidden="true">image-20220704151857006</figcaption>
</figure></li>
<li><p>将此函数声明复制到 <code>//extern function</code> 处，然后在
<code>while(1)</code> 前添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_driver.draw_pixel = gfx_draw_pixel;</span><br><span class="line">my_driver.fill_rect = <span class="literal">NULL</span>;<span class="comment">//gfx_fill_rect;</span></span><br><span class="line"><span class="comment">//function like: startHelloStar(NULL,128,160,2,&amp;my_driver);</span></span><br></pre></td></tr></table></figure></li>
<li><p>编译然后烧录，不需要管警告信息。</p></li>
</ol></li>
</ol>
<h2 id="hal库小记">HAL库小记</h2>
<blockquote>
<p><strong>硬件抽象层</strong>（HAL，Hardware Abstraction
Layer）驱动程序提供了一组功能丰富，易于与应用上层交互的
API，它们涵盖了常见的外围设备，可以非常方便的向其它型号 STM32
微控制器移植。同时还实现了用户回调函数机制，允许并发调用
<code>USART1</code> 以及 <code>USART2</code>
等外设，并且支持<strong>轮询</strong>、<strong>中断</strong>、<strong>DMA</strong>
三种 API 编程模式。</p>
<p><a target="_blank" rel="noopener" href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">对于HAL库的介绍</a></p>
</blockquote>
<h4 id="gpio口">GPIO口</h4>
<h5 id="初始化及重置函数">初始化及重置函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span>; </span><br><span class="line"><span class="comment">//重置引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_DeInit</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint32_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="gpio-口操作相关函数">GPIO 口操作相关函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取电平状态 </span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//设置引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>; </span><br><span class="line"><span class="comment">//转换引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//锁定引脚状态 </span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_LockPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br></pre></td></tr></table></figure>
<h5 id="gpio口枚举常量">GPIO口枚举常量</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0U</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125; GPIO_PinState;</span><br></pre></td></tr></table></figure>
<h5 id="gpio口名称">GPIO口名称</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IO口默认定义 -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_0                 ((uint16_t)0x0001)  <span class="comment">/* Pin 0 selected    */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private defines -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_Pin GPIO_PIN_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_GPIO_Port GPIOA</span></span><br></pre></td></tr></table></figure>
<p>GPIO的API</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_ReadPin()</code></td>
<td style="text-align: left;">读取指定输入端口的引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_WritePin()</code></td>
<td style="text-align: left;">设置或者清除指定的数据端口位；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_TogglePin()</code></td>
<td style="text-align: left;">切换指定的 GPIO 引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_LockPin()</code></td>
<td style="text-align: left;">锁定 GPIO 引脚配置寄存器；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_IRQHandler()</code></td>
<td style="text-align: left;">该函数用于处理 EXTI 中断请求；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_Callback()</code></td>
<td style="text-align: left;">EXTI 线检测回调函数；</td>
</tr>
</tbody>
</table>
<h4 id="串口通信-1">串口通信</h4>
<h5 id="收发函数">收发函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//发送中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//接收中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData</span></span><br><span class="line"><span class="params">, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA发送</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA接收</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//DMA暂停</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAPause</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA恢复</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAResume</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA停止</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAStop</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="printf-重定向"><code>printf()</code> 重定向</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 USER CODE BEGIN 0 区域内添加：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//huart1需要根据你的配置修改</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口调试策略">串口调试策略</h4>
<h5 id="日志打印文件">日志打印文件</h5>
<p>keil编译器要求文件的结尾必须要有一个空行，如果没有将给出一个警告</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @file           : user_log.h</span></span><br><span class="line"><span class="comment">  *  @brief          : Print your Log information</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @useage</span></span><br><span class="line"><span class="comment">  * Include this header file in the program file that you want to print logs.</span></span><br><span class="line"><span class="comment">	* Using the function: </span></span><br><span class="line"><span class="comment">	* `user_printf()`</span></span><br><span class="line"><span class="comment">	* `user_main_info()`</span></span><br><span class="line"><span class="comment">	* `user_main_debug()`</span></span><br><span class="line"><span class="comment">	* `user_main_error()`  to print the log.</span></span><br><span class="line"><span class="comment">  * Define &quot;PRINT_USER_LOG&quot; if you want to print logs and annotations it if you don&#x27;t.</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USER_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_USER_LOG	<span class="comment">//define for print log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PRINT_USER_LOG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...) printf( format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...) printf(<span class="string">&quot; [info] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...) printf(<span class="string">&quot; [debug] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...) printf(<span class="string">&quot; [error] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...) printf(<span class="string">&quot; [info] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...) printf(<span class="string">&quot; [debug] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...) printf(<span class="string">&quot; [error] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* PRINT_USER_LOG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __USER_LOG_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加文件时若出现报错，则需要手动增加头文件搜索路径：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627212005510.png" alt="image-20220627212005510">
<figcaption aria-hidden="true">image-20220627212005510</figcaption>
</figure>
<h5 id="日志打印个性化文字">日志打印个性化文字</h5>
<p><a target="_blank" rel="noopener" href="http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20">Text
to ASCII Art Generator (TAAG)</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">___  ___        _                   </span><br><span class="line">|  \/  |       | |                  </span><br><span class="line">| .  . | _   _ | |      ___    __ _ </span><br><span class="line">| |\/| || | | || |     / _ \  / _` |</span><br><span class="line">| |  | || |_| || |____| (_) || (_| |</span><br><span class="line">\_|  |_/ \__, |\_____/ \___/  \__, |</span><br><span class="line">          __/ |                __/ |</span><br><span class="line">         |___/                |___/ </span><br></pre></td></tr></table></figure>
<p>代码：要在报错的符号前面加上一个反斜杠，因此代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>分割线内内容摘自<a target="_blank" rel="noopener" href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">Uinlo</a>的个人博客：</p>
<h3 id="hal-通用命名规则">HAL 通用命名规则</h3>
<p>对于共有的系统外设，无需使用指针或者实例对象，这个规则适用于
<strong>GPIO</strong>、<strong>SYSTICK</strong>、<strong>NVIC</strong>、<strong>RCC</strong>、<strong>FLASH</strong>
外设，例如函数 <code>HAL_GPIO_Init()</code> 只需要 GPIO
的地址及其配置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *Init) &#123;</span><br><span class="line">  /* GPIO 初始化体 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个外设驱动程序当中都定义有处理中断和特定时钟配置的<strong>宏</strong>，这些宏会被导出到外设驱动的<strong>头文件</strong>，以便于<strong>扩展文件</strong>使用，这些用于处理中断和特定时钟配置的宏如下所示：</p>
<table>
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">宏定义</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个特定的外设中断；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个特定的外设中断；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个外设；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个外设；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_XXXX (__HANDLE__, __PARAM__)</code></td>
<td style="text-align: left;">指定 PPP
外设驱动的<strong>宏</strong>；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_GET_ IT_SOURCE (__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;">检查指定的<strong>中断源</strong>；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>NVIC</strong> 和
<strong>SYSTICK</strong> 是 ARM Cortex-M4 提供的两个核心功能，与之相关的
API 都位于 <code>stm32f4xx_hal_cortex.c</code> 源文件。</p>
</blockquote>
<p>当从寄存器读取<strong>状态标志位</strong>时，其结果由移位值组成，具体取决于读取值的数量与大小。这种情况下，返回的状态宽度为
<strong>32</strong> 位，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATUS = XX | (YY &lt;&lt; 16)</span><br><span class="line">/* 或者 */</span><br><span class="line">STATUS = XX | (YY &lt;&lt; 8) | (YY &lt;&lt; 16) | (YY &lt;&lt; 24)</span><br></pre></td></tr></table></figure>
<p>外设 PPP 的指针在调用 <code>HAL_PPP_Init()</code>
之前有效，初始化函数会在修改指针字段之前进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_Init(PPP_HandleTypeDef)</span><br><span class="line">if (hppp == NULL) &#123;</span><br><span class="line">  return HAL_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<strong>条件式宏定义</strong>或者<strong>伪代码宏定义</strong>：</p>
<ul>
<li><p>条件式宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ABS(x) (((x) &gt; 0) ? (x) : -(x))</span><br></pre></td></tr></table></figure></li>
<li><p>伪代码宏定义（多指令宏）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_) \</span><br><span class="line">  do &#123;                                                             \</span><br><span class="line">    (__HANDLE__)-&gt;__PPP_DMA_FIELD_ = &amp;(__DMA_HANDLE_);             \</span><br><span class="line">    (__DMA_HANDLE_).Parent = (__HANDLE__);                         \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="中断处理程序与回调函数">中断处理程序与回调函数</h4>
<p>除了各种 API 函数之外，HAL 固件库外设驱动程序当中还包含有：</p>
<ul>
<li>用户回调函数；</li>
<li>由 <code>stm32f4xx_it.c</code> 调用的
<code>HAL_PPP_IRQHandler()</code> 外设中断处理程序；</li>
</ul>
<p>回调函数被定义为带有 <code>weak</code>
属性的空函数，使用时必须在用户代码当中进行定义，HAL
固件库当中存在三种类型的用户回调函数：</p>
<ul>
<li>外围系统级初始化与反向初始化回调函数 <code>HAL_PPP_MspInit()</code>
和 <code>HAL_PPP_MspDeInit</code>；</li>
<li>外理完成回调函数 <code>HAL_PPP_ProcessCpltCallback</code>；</li>
<li>错误的回调函数 <code>HAL_PPP_ErrorCallback</code>；</li>
</ul>
<table>
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">回调函数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_MspInit()</code>
<code>HAL_PPP_MspDeInit()</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_MspInit()</code>，由
API 函数 <code>HAL_PPP_Init()</code>
进行调用，用于进行外设的系统级初始化（GPIO、时钟、DMA、中断）；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_PPP_ProcessCpltCallback</code></td>
<td style="text-align: left;">例如
<code>HAL_USART_TxCpltCallback</code>，当处理执行完成时，由外设或者 DMA
中断处理程序进行调用；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_ErrorCallback</code></td>
<td style="text-align: left;">例如
<code>HAL_USART_ErrorCallback</code>，当发生错误时，由外设或者 DMA
中断处理程序进行调用；</td>
</tr>
</tbody>
</table>
<h4 id="hal-全局初始化">HAL 全局初始化</h4>
<p><code>stm32f4xx_hal.c</code> 提供了一组 API 来初始化 HAL
核心实现：</p>
<ul>
<li><code>HAL_Init()</code>：该函数必须在应用程序启动时调用，用于初始化数据和指令，缓存预获取队列，设置
SysTick 定时器（基于 HSI 时钟）每间隔 <code>1ms</code>
产生一个最低优先级中断，将优先级分组设置为 <code>4</code> 位，调用
<code>HAL_MspInit()</code>
用户回调函数来执行系统级初始化（时钟、GPIO、DMA、中断）；</li>
<li><code>HAL_DeInit()</code>：重置所有外设，调用用户回调函数
<code>HAL_MspDeInit()</code> 执行系统级反向初始化；</li>
<li><code>HAL_GetTick()</code>：获取当前 <strong>SysTick</strong>
定时器的计数值（在 SysTick
中断内递增），用于外设驱动程序处理<strong>超时</strong>；</li>
<li><code>HAL_Delay()</code>：通过 <strong>SysTick</strong>
定时器实现一个以毫秒为单位的延迟；</li>
</ul>
<h4 id="io-操作">IO 操作</h4>
<p>带有内部数据处理（发送、接收、读/写）的 HAL
函数，通常具备<code>轮询（Polling）</code>、<code>中断（Interrupt）</code>、<code>DMA</code>
三种处理方式：</p>
<hr>
<h2 id="底层探究">底层探究</h2>
<h3 id="新建工程">新建工程</h3>
<p>使用windows系统的PowerShell生成Blank template文件的目录树：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br></pre></td></tr></table></figure>
<p>添加 “startup_stm32g431xx.s” <del>和 “system_stm32g4xx.c”
两个文件</del>到 Blank template 文件夹目录下：</p>
<p>新建两个文件，编写系统初始化函数和主函数，如图。然后编译。</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171400275.png" alt="image-20220628171400275" style="zoom:50%;"></p>
<p>编译成功，包含一个警告，内容为：<code>void SystemInit(void)</code>
函数没有函数原型，此处可以忽略该警告。</p>
<p>编译后的工程目录树如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvguix.qjy</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│  <span class="title">main.c</span></span></span><br><span class="line"><span class="function">│  <span class="title">startup_stm32g431xx.s</span></span></span><br><span class="line"><span class="function">│  <span class="title">system_stm32g4xx.c</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">│      <span class="title">Blank_Template.map</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.axf</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.build_log.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.lnp</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template_Target</span> 1.<span class="title">dep</span></span></span><br><span class="line"><span class="function">        <span class="title">main.d</span></span></span><br><span class="line"><span class="function">        <span class="title">main.o</span></span></span><br><span class="line"><span class="function">        <span class="title">startup_stm32g431xx.o</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.d</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.o</span></span></span><br></pre></td></tr></table></figure>
<p>其中keil中的project目录树为：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171454899.png" alt="image-20220628171454899" style="zoom: 50%;"></p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181017627.png" alt="image-20220628181017627">
<figcaption aria-hidden="true">image-20220628181017627</figcaption>
</figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181229406.png" alt="image-20220628181229406">
<figcaption aria-hidden="true">image-20220628181229406</figcaption>
</figure>
<p>我们知道系统的时钟是通过系统复位和时钟控制(RCC)寄存器配置的。
在第6.3节中列举了25个RCC寄存器的位定义和偏移地址。参考CubeMX中生成的stm32g431xx.h文件，定义如下的结构体用于访问RCC的每个寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Reset and Clock Control</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR;          <span class="comment">/*!&lt; RCC clock control register,                                              Address offset: 0x00 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICSCR;       <span class="comment">/*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CFGR;        <span class="comment">/*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PLLCFGR;     <span class="comment">/*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED0;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x10 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED1;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIER;        <span class="comment">/*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIFR;        <span class="comment">/*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CICR;        <span class="comment">/*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED2;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x24 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1RSTR;    <span class="comment">/*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2RSTR;    <span class="comment">/*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3RSTR;    <span class="comment">/*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED3;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x34 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR1;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR2;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2RSTR;    <span class="comment">/*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED4;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x44 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1ENR;     <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2ENR;     <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3ENR;     <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED5;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x54 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR1;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR2;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2ENR;     <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED6;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x64 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1SMENR;   <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2SMENR;   <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3SMENR;   <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED7;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x74 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR1;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR2;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2SMENR;   <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED8;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x84 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR;       <span class="comment">/*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED9;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x8C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BDCR;        <span class="comment">/*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CSR;         <span class="comment">/*!&lt; RCC clock control &amp; status register,                                     Address offset: 0x94 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CRRCR;       <span class="comment">/*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR2;      <span class="comment">/*!&lt; RCC peripherals independent clock configuration register 2,              Address offset: 0x9C */</span></span><br><span class="line">&#125; RCC_TypeDef;</span><br></pre></td></tr></table></figure>
<p>RCC基地址宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE           (0x40000000UL) <span class="comment">/*!&lt; Peripheral base address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE              (AHB1PERIPH_BASE + 0x1000UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC ((rcc_regs_t *)RCC_BASE)</span></span><br></pre></td></tr></table></figure>
<p>那么我们就可以通过如下的形式来访问RCC的寄存器了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC-&gt;CR</span><br><span class="line">RCC-&gt;CFGR</span><br></pre></td></tr></table></figure>
<h2 id="cubemx小记">CubeMX小记</h2>
<figure>
<img src="/2022/06/24/15-48-41/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM0NDQxMg==,size_16,color_FFFFFF,t_70-16566001142753.png" alt="SYS配置介绍">
<figcaption aria-hidden="true">SYS配置介绍</figcaption>
</figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/439705800">引用</a>：调试接口配置。讲道理SWD应该是首选，如图5所示。如果不设置的话，编译下载后，你就会发现下载不了程序了，有复位键还好，没<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=复位键&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22439705800%22%7D">复位键</a>就有得愁了。</p>
</blockquote>
<p>选择Serial Wire是与下图中的SW相匹配</p>
<p><img src="/2022/06/24/15-48-41/image-20220630224454477.png" alt="image-20220630224454477" style="zoom: 50%;"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41344412/article/details/114153416">引用</a>：如果在STM32CubeMX中选择SW协议，MDK
也必须
选择SW协议。JTAG协议配置也同理。否则会造成下载和调试失败。在实际项目中SW协议使用使用的比较多，SW与JTAG相比，速度更快，占用的引脚更少，推荐大家配置成SW协议。</p>
</blockquote>
<h2 id="keil配置">Keil配置</h2>
<p>Edit—&gt;Configuration 进行配置</p>
<p>Configuration</p>
<ul>
<li>Editor
<ul>
<li>General—&gt;Encoding—&gt;Chinese GB2312(Simplifies)</li>
<li>Funcition—&gt;default</li>
<li>Look &amp; Feel—&gt;default</li>
<li>Feil &amp; Project Handling—&gt;choose all expect first one</li>
<li>C/C++ Files—&gt;Change Tab Size to 4</li>
<li>ASM Files—&gt;default</li>
<li>Other Files—&gt;default</li>
</ul></li>
<li>Colors &amp; Fonts
<ul>
<li>C/C++ Editor files—&gt;Test—&gt;Font: Cascadis Code/Size: 20</li>
</ul></li>
<li>Shortcut Keys
<ul>
<li>Project: Rebulid all target files—&gt;Ctrl+R</li>
<li>View: Bulid Output Windows—&gt;Ctrl+B</li>
<li>View: Project Windows—&gt;Ctrl+D</li>
<li></li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/04/10/11-17-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/10/11-17-01/" class="post-title-link" itemprop="url">概率论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-10 11:17:01 / 修改时间：17:55:32" itemprop="dateCreated datePublished" datetime="2022-04-10T11:17:01+08:00">2022-04-10</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/10/11-17-01/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/10/11-17-01/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概率与统计">概率与统计</h1>
<h3 id="随机实验">随机实验</h3>
<p>满足条件：</p>
<ol type="1">
<li>可以被重复；</li>
<li>具有多种可能结果并均明确可知；</li>
<li>试验结果不可预先获知。</li>
</ol>
<p>随机实验可能出现的每一种结果称为<strong>样本点</strong>，每一个样本点都彼此不相容，因而它是构成试验结果的最基础原子，故而样本点也被称为<strong>基本事件</strong>。</p>
<p>所有样本点（也即所有的可能结果）的集合就被称为<strong>样本空间</strong></p>
<p>一次试验可能出现的结果称为<strong>随机事件</strong>，随机事件是一个集合，内部元素均为随机实验的样本点</p>
<p>为什么要引入样本空间：</p>
<p>引入样本空间是为了给予“随机”这一相对较为暧昧的机制一个严格的数学范围。在这以后，一切事件的概率才得以在其相对应的样本空间之下具备良好的定义。</p>
<p>这就像样本空间（Sample
space）产生出了事件域，而我们讨论相应的事件概率，就只在其定义的样本空间下具有意义，而同一事件在不同样本空间下，其发生的概率可能截然不同</p>
<p>样本空间的引入实际上是在为概率的定义提供了一个严格的范围。</p>
<p>一个样本空间可以是有限的，可数无穷的和不可数无穷的</p>
<p>假如S是可数的，包括有限和可数无穷的，那么S为一个离散的样本空间</p>
<p>假如S是不可数的，即不可数无穷的，那么S为一个连续的样本空间</p>
<p>对于随机试验的结果，即随机事件，其描述可以由多个观测量组成，因此样本空间可以是有不同维度的，维度数即描述一个随机时间的测量量的数目</p>
<p>概率的定义：（概率的本质）</p>
<p>直觉：概率就是事件发生的可能性。</p>
<p>古典概型：</p>
<p>进行<span class="math inline">\(n\)</span>次随机实验，得到的某一结果的次数记作<span class="math inline">\(N_k(n)\)</span>，则得到该结果的相对次数为<span class="math inline">\(f_k(n)=\frac{N_k(n)}{n}\)</span></p>
<p>当<span class="math inline">\(n\)</span>的数值足够大时，<span class="math inline">\(f_k(n)\)</span>则收敛于一个稳定的数值，即<span class="math inline">\(lim_{n-&gt;\infty}f_k(n)=p_k\)</span>，<span class="math inline">\(p_k\)</span>称作概率</p>
<p>古典概型的前提：</p>
<ol type="1">
<li>在古典概型的样本空间中，样本点也即基本事件的个数是有限的（骰子只能掷出6个数字）</li>
<li>每个样本点也即每个基本事件发生的可能性是相等的（投出6和投出1或任意其它一种结果的可能性完全一致）</li>
</ol>
<p>古典概型是<strong>先验</strong>的，因为我们<strong>先验</strong>的认为，这个骰子掷出任意一个数字的可能性都是相同的。并且同样<strong>先验</strong>的确定，掷出任意一个数字的频率都会稳定于古典概型计算出的这个先验概率附近。</p>
<p>先验来自于我们的直觉，来自于实践中的观察</p>
<p><strong>后验</strong>认为，对于事件发生的先验假设，我们不应当存在任何的偏好——即基本事件等可能这种事，并不是理所当然的</p>
<p>后验中我们可以随意假设一个估计性质的开始概率，重要的是，我们可以通过后续的重复试验，来不断的更新纠正这一概率，而当通过试验获取的信息趋近于无穷时，我们最终就可以获得一个收敛于某个具体数值的<strong>后验</strong>概率。</p>
<p>让我们能够摆脱“可能性”的束缚，从而绕开先验与后验的争论，来在数学上精确的定义概率呢？</p>
<p>在有了样本空间将事件构造成的集合以后，再通过测度的方式，将它们映射至0到1取值范围内的实数域
<span class="math inline">\([0,1]\)</span>上。</p>
<p>若以这样的方式来定义概率，我们不就可以将它从事件发生可能性这样的束缚上解脱出来，从而获得一个纯粹的数学定义。为了实现这种测度的构造，就可以人为的对样本空间到实数域的映射规则进行规定，即：</p>
<ol type="1">
<li>概率必然是非负的，即 <span class="math inline">\(P(A)\ge
0\)</span></li>
<li>样本空间所代表的全集，概率规定为1，即 <span class="math inline">\(P(\Omega)=1\)</span></li>
<li>对于任意可列的互不相容事件（即两两交集均为 <span class="math inline">\(\varnothing\)</span>
的子集），它们并集的概率等于它们概率的和，即 <span class="math inline">\(P(A\cup B)=P(A)+P(B)\)</span></li>
</ol>
<p>满足这三个条件的映射，即有概率 <span class="math inline">\(P\)</span>
，这也被称为概率的公理化定义。</p>
<p>也由于这种定义的实质就是将样本空间对实数进行映射，故而这种映射也被称为<strong>概率测度</strong>。</p>
<p>条件概率公式所反映的，实际上是决策树的<strong>剪枝</strong>过程。而条件概率的本质，则是<strong>由于前提事件的发生所导致的待计算事件其样本点与样本空间的同时缩小（如同上文中文氏图所示的右侧聚焦过程）</strong>。</p>
<p><strong>全概率公式</strong>：</p>
<p>假设：样本空间 <span class="math inline">\(S\)</span>
有一个完备的事件组 <span class="math inline">\(A_1,A_2,A_3\)</span>：也就是样本空间被这三个事件瓜分完了</p>
<p>满足两个条件：三个事件：</p>
<ol type="1">
<li><span class="math inline">\(A_1 \cup A_2 \cup
A_3=\Omega\)</span></li>
<li><span class="math inline">\(A_1 \cap A_2 \cap
A_3=\varnothing\)</span></li>
</ol>
<p>则又有一事件 <span class="math inline">\(B\)</span> 时，<span class="math inline">\(P(B)=P(B \cap \Omega)=P[B\cup (A_1 \cup A_2 \cup
A_3)]=P(BA_1 \cup BA_2 \cup BA_3)\)</span></p>
<p>因为 <span class="math inline">\(A_1 \cap A_2 \cap
A_3=\varnothing\)</span>，所以 <span class="math inline">\(BA_1 \cup
BA_2 \cup BA_3=\varnothing\)</span></p>
<p>所以：<span class="math inline">\(P(BA_1 \cup BA_2 \cup
BA_3)=P(BA_1)+P(BA_2)+P(BA_3)\)</span></p>
<p>由条件概率公式可得：</p>
<p><span class="math inline">\(P(B)=P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)\)</span></p>
<p>即全概率公式事实上是一种<strong>对事件的先验分解</strong>。</p>
<p>全概率公式的使用条件，就是连续做多次实验，可以画出决策树，然后每一种分支可能性会发生变化，即前一次的选择会对下一次的选择产生影响；这是若求解第二轮即以后某个结果发生的可能性，则使用全概率公式</p>
<p>贝叶斯公式：</p>
<p>贝叶斯公式是后验的，即，我们已经做了实验，然后通过实验结果我们不断去修正导致这一结果发生的某些概率值</p>
<p>贝叶斯公式可以由全概率公式变形得来： <span class="math display">\[
\begin{aligned}
P(A_1|B)&amp;=\frac{P(A_1B)}{P(B)}\\
&amp;=\frac{P(A_1B)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}\\
&amp;=\frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}
\end{aligned}
\]</span></p>
<p>随机变量：随机变量的本质实际上就是<strong>随机事件的数字化</strong>。</p>
<p>现实世界中各色各样具象的随机事件，可以被映射成数学世界中抽象的数字，而这种映射规则就叫做随机变量。</p>
<p>离散随机变量的（概率分布律）概率质量函数（<span class="math inline">\(pmf\)</span>）：</p>
<p>离散性随机变量记作 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的可能值是一个可数集合中的元素：<span class="math inline">\(S_X={x_1,x_2,x_3...}\)</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span></th>
<th><span class="math inline">\(x=1\)</span></th>
<th><span class="math inline">\(x=0\)</span></th>
<th><span class="math inline">\(x=2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(pmf\)</span></td>
<td><span class="math inline">\(P(x=1)=0.125\)</span></td>
<td><span class="math inline">\(p(x=0)=0.25\)</span></td>
<td><span class="math inline">\(P(x=2)=0.625\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(pmf\)</span> 的性质：</p>
<ul>
<li><p><span class="math display">\[
对于所有\;x\; 都有 \;P_X(x)\ge 0
\]</span></p></li>
<li><p><span class="math display">\[
\sum_{x\in S}P_X(x)=1
\]</span></p></li>
<li><p><span class="math display">\[
P(X\;in\;B)=\sum_{x\in B}P_X(x)\;其中B\subset S_X
\]</span></p></li>
</ul>
<p>随机变量可以是离散的，连续的和混合的</p>
<p>累积分布函数（<span class="math inline">\(cdf\)</span>：cumulative
distribution
function），常被使用在随机变量的正式定义中，可以处理三种类型的随机变量</p>
<p>一个离散性随机变量的 <span class="math inline">\(pmf\)</span> 是由
<span class="math inline">\(\{X=b\}\)</span>
来定义的，累计分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution
function）则是由 <span class="math inline">\(\{X\le b\}\)</span>
来定义的。</p>
<p>累计分布函数的优点在于它不局限于离散型随机变量，而是可以在所有类型的随机变量中使用</p>
<ol type="1">
<li><span class="math inline">\(F_X(x)\)</span>必然是一个单调不减函数——因概率不可为负，随着对应样本点的增多，概率的累加必然是单调不减的；</li>
<li><span class="math inline">\(F_X(x)\)</span>
必然是一个右连续函数；</li>
<li><span class="math inline">\(\lim_{n \to
-\infty}F_X(x)=0\)</span>，<span class="math inline">\(\lim_{n \to
\infty}F_X(x)=1\)</span>
——即对应样本点集合为空时，概率必然为0，而对应样本点集合为整个样本空间时，概率必然为1。</li>
</ol>
<p>可以看到，无论分布函数以何种形式构造，又呈现出何种性质，其最最核心的效用，就是为了能够良好的表示出样本空间的这一性质：
<span class="math display">\[
P_1+P_2+P_3+...+P_n=\sum_iP_i=1
\]</span> 即实现样本空间 <span class="math inline">\(S\)</span>
对应的概率<strong>归向于1</strong>，从而完成样本空间向值域 <span class="math inline">\([0,1]\)</span>
的映射。因此，分布函数的本质实际上是<strong>随机变量的归一化</strong>。</p>
<p>而当随机变量由离散型扩展至连续型时，在把握到分布函数的本质是样本点概率的累加函数以后，便可以推测连续型随机变量的分布函数
<span class="math inline">\(F_X(x)\)</span>
必然会表现为一种积分形式。</p>
<p>但是与离散型概率分布中，每个随机变量对应着一个确定的概率值所不同，若以类似的方式来通过分布函数计算连续型随机变量中任意一点的概率，即用这一点的分布函数值减去这一点处左极限的分布函数值：
<span class="math display">\[
P\{x=x_0\}=F_X(x_0)-\lim_{n \to x_0^-}F_X(x_0)
\]</span> 由于 <span class="math inline">\(F_X(x)\)</span>
是连续的概率累加，因此它在性质上也必然是一个非负不减的连续函数，故根据连续的性质，有：
<span class="math display">\[
F_X(x_0)=\lim_{n \to x_0^+}F_X(x_0)= \lim_{n \to x_0^-}F_X(x_0)
\]</span> 故有： <span class="math display">\[
P\{x=x_0\}=0
\]</span>
由此可以看到，无论我们怎么计算，在连续型随机变量的分布函数上想要直接计算某一点处的概率，它将始终都会是0。</p>
<p>从这一结论，你应该就能明白，在概率论的开篇中，我们提到通过引入测度，将事件的概率测度与它在现实中发生的可能性这两个概念分开具有怎样重要的意义。</p>
<p>可以看到，在连续型随机变量中，某一点出的概率为0，并不意味着它在事件发生的角度来看是不可能的，而只是意味着这一点处的概率测度为0。</p>
<p>而之所以会出现概率测度为0的原因，是因为在这里一开始所着眼的计算目标就错了。打个比方来说就相当于，你并不会去计算一个点的长度，不会去计算一条线的面积，不会去计算一个面的体积。换句话说，在连续型随机变量中，计算某一点处的概率就相当于在求一条线的面积。</p>
<p>在认识到这一点之后，为了刻画连续型随机变量中某点处局部的概率性质就需要另外的工具，而这个工具在微积分的阶段就已经准备好早已被我们熟稔于胸——当然就是导数，即有：
<span class="math display">\[
F^{&#39;}_X(x_0)=\lim_{x\to x_0}\frac{F_X(x)-F_X(x_0)}{x-x_0}
\]</span>
换句话说，对于连续型随机变量，我们用以刻画在一点处局部性质的量不是概率，而应该是<strong>概率测度的变化率。</strong></p>
<p>借用我们在散度与测度一章中的两个相类似的例子来说，就是：</p>
<ul>
<li>在位移运动中，刻画某一瞬时性质的不是位移而是速度；</li>
<li>在有质物体中，刻画某一质点性质的不是质量而是密度。</li>
</ul>
<p>也因此，以质量与密度的关系来考量概率与概率变化率，才会将连续型随机变量的分布函数，一个变上限积分：<span class="math inline">\(F(x)=\int^x_{-\infty}f(t)dt\)</span> 的导函数：
<span class="math inline">\(F&#39;(x)=f(x)\)</span>
命名为<strong>概率密度</strong>。</p>
<p>更要值得一提的是，如果用离散型随机变量的概率分布即：</p>
<p>一个随机变量对应一个确定的概率测度 <span class="math inline">\(x_i\sim P_i\)</span></p>
<p>来进行类比的话，连续型随机变量的概率分布实际上应当为：</p>
<p>一个随机变量对应其<strong>附近领域</strong>的概率测度 <span class="math inline">\(x_i\sim f(x_i)dx_i\)</span></p>
<p>而非直接对应概率密度函数 <span class="math inline">\(f(x)\)</span>，从这个类比，可以更直观的认为，若视离散型随机变量的分布函数为一个楼层分明的阶梯，那么连续型随机变量的分布函数就是一个将楼层无限增加细分从而使层次分明的阶梯最终转换为一个<strong>平滑化</strong>的斜坡。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/30/11-27-50/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/30/11-27-50/" class="post-title-link" itemprop="url">OpenCv笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-30 11:27:50" itemprop="dateCreated datePublished" datetime="2022-03-30T11:27:50+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-24 14:46:28" itemprop="dateModified" datetime="2022-04-24T14:46:28+08:00">2022-04-24</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/30/11-27-50/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/30/11-27-50/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR
8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或
-1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如
<span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>，
<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong>
等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span>
中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数
<code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span>
转换，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于
<span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在
<span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较
<span class="math inline">\(OpenCV\)</span>
值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span>
图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在
$ HSV$ 中，比在 <span class="math inline">\(BGR\)</span>
颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span>
图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a target="_blank" rel="noopener" href="https://www.stackoverflow.com/">stackoverflow.com</a>
中发现的一个常见问题。它非常简单，你可以使用相同的函数<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的
<span class="math inline">\(BGR\)</span>
值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$
终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和
<span class="math inline">\([H+10, 255,255]\)</span>
为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整
<span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong>
和 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为
<span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span>
用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span>
提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code>
函数。详情请查看 <span class="math inline">\(matplotlib\)</span>
文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a>
接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span>
是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv.imread(r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;,0)</span><br><span class="line">kernel = np.ones((2,1),np.uint8)</span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line">#erosion = cv.erode(img,kernel,iterations = 1)</span><br><span class="line">cv.imshow(&#x27;res&#x27;,closing)</span><br><span class="line">k = cv.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span>
的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span>
的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a>
函数，其中 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a>
是 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a>
被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为
<span class="math inline">\(127\)</span>
的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span>
阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span>
实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span>
的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted
within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad
\mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad
\mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad
\&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2
\frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span>
的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在
<span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You
can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span>
有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong>
来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示：
<span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1
&amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
\]</span>
操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数
<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong>
或 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>
完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个
<span class="math inline">\(3x3\)</span>
标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1
\\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数
<code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span>
内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong>
完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是
$ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了
<span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$
取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong>
创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong>
取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。2</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span>
的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong>
在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a target="_blank" rel="noopener" href="https://people.csail.mit.edu/sparis/bf_course/">bilateral
filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">2</span>,<span class="number">2</span>),np.uint8)</span><br><span class="line"><span class="comment">#closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span></span><br><span class="line"><span class="comment">#erosion = cv.erode(img,kernel,iterations = 1)</span></span><br><span class="line"><span class="comment">#dilation = cv.dilate(img,kernel,iterations = 1)</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,opening)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>,
<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>,
<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong>
等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是
<span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image">
<figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span>
的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological
Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut
算法的交互式前景提取</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="page-number" href="/default-index/page/3/">3</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邱金羽</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"Bolgqjy","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
