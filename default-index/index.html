<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y006.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1},"gitalk":{"order":-2}}},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="联系我：2420457716@qq.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://y006.github.io/default-index/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="联系我：2420457716@qq.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="邱金羽">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y006.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">邱金羽的技术博客！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="邱金羽"
      src="/images/custom-logo.jpg">
  <p class="site-author-name" itemprop="name">邱金羽</p>
  <div class="site-description" itemprop="description">联系我：2420457716@qq.com</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/32844822/dynamic" title="Bilibili个人空间 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;32844822&#x2F;dynamic" rel="noopener" target="_blank">Bilibili个人空间</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/qiu-jin-yu-60" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qiu-jin-yu-60" rel="noopener" target="_blank">知乎</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://uinika.github.io/" title="https:&#x2F;&#x2F;uinika.github.io&#x2F;" rel="noopener" target="_blank">UinIO</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fazzie-key.cool/" title="https:&#x2F;&#x2F;fazzie-key.cool&#x2F;" rel="noopener" target="_blank">摸黑干活</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://eater.net/" title="https:&#x2F;&#x2F;eater.net&#x2F;" rel="noopener" target="_blank">Ben Eater</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/04/10/11-17-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/10/11-17-01/" class="post-title-link" itemprop="url">概率论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-10 11:17:01 / 修改时间：17:07:26" itemprop="dateCreated datePublished" datetime="2022-04-10T11:17:01+08:00">2022-04-10</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/10/11-17-01/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/10/11-17-01/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概率与统计">概率与统计</h1>
<h3 id="随机实验">随机实验</h3>
<p>满足条件：</p>
<ol type="1">
<li>可以被重复；</li>
<li>具有多种可能结果并均明确可知；</li>
<li>试验结果不可预先获知。</li>
</ol>
<p>随机实验可能出现的每一种结果称为<strong>样本点</strong>，每一个样本点都彼此不相容，因而它是构成试验结果的最基础原子，故而样本点也被称为<strong>基本事件</strong>。</p>
<p>所有样本点（也即所有的可能结果）的集合就被称为<strong>样本空间</strong></p>
<p>一次试验可能出现的结果称为<strong>随机事件</strong>，随机事件是一个集合，内部元素均为随机实验的样本点</p>
<p>为什么要引入样本空间：</p>
<p>引入样本空间是为了给予“随机”这一相对较为暧昧的机制一个严格的数学范围。在这以后，一切事件的概率才得以在其相对应的样本空间之下具备良好的定义。</p>
<p>这就像样本空间（Sample space）产生出了事件域，而我们讨论相应的事件概率，就只在其定义的样本空间下具有意义，而同一事件在不同样本空间下，其发生的概率可能截然不同</p>
<p>样本空间的引入实际上是在为概率的定义提供了一个严格的范围。</p>
<p>一个样本空间可以是有限的，可数无穷的和不可数无穷的</p>
<p>假如S是可数的，包括有限和可数无穷的，那么S为一个离散的样本空间</p>
<p>假如S是不可数的，即不可数无穷的，那么S为一个连续的样本空间</p>
<p>对于随机试验的结果，即随机事件，其描述可以由多个观测量组成，因此样本空间可以是有不同维度的，维度数即描述一个随机时间的测量量的数目</p>
<p>概率的定义：（概率的本质）</p>
<p>直觉：概率就是事件发生的可能性。</p>
<p>古典概型：</p>
<p>进行<span class="math inline">\(n\)</span>次随机实验，得到的某一结果的次数记作<span class="math inline">\(N_k(n)\)</span>，则得到该结果的相对次数为<span class="math inline">\(f_k(n)=\frac{N_k(n)}{n}\)</span></p>
<p>当<span class="math inline">\(n\)</span>的数值足够大时，<span class="math inline">\(f_k(n)\)</span>则收敛于一个稳定的数值，即<span class="math inline">\(lim_{n-&gt;\infty}f_k(n)=p_k\)</span>，<span class="math inline">\(p_k\)</span>称作概率</p>
<p>古典概型的前提：</p>
<ol type="1">
<li>在古典概型的样本空间中，样本点也即基本事件的个数是有限的（骰子只能掷出6个数字）</li>
<li>每个样本点也即每个基本事件发生的可能性是相等的（投出6和投出1或任意其它一种结果的可能性完全一致）</li>
</ol>
<p>古典概型是<strong>先验</strong>的，因为我们<strong>先验</strong>的认为，这个骰子掷出任意一个数字的可能性都是相同的。并且同样<strong>先验</strong>的确定，掷出任意一个数字的频率都会稳定于古典概型计算出的这个先验概率附近。</p>
<p>先验来自于我们的直觉，来自于实践中的观察</p>
<p><strong>后验</strong>认为，对于事件发生的先验假设，我们不应当存在任何的偏好——即基本事件等可能这种事，并不是理所当然的</p>
<p>后验中我们可以随意假设一个估计性质的开始概率，重要的是，我们可以通过后续的重复试验，来不断的更新纠正这一概率，而当通过试验获取的信息趋近于无穷时，我们最终就可以获得一个收敛于某个具体数值的<strong>后验</strong>概率。</p>
<p>让我们能够摆脱“可能性”的束缚，从而绕开先验与后验的争论，来在数学上精确的定义概率呢？</p>
<p>在有了样本空间将事件构造成的集合以后，再通过测度的方式，将它们映射至0到1取值范围内的实数域 <span class="math inline">\([0,1]\)</span>上。</p>
<p>若以这样的方式来定义概率，我们不就可以将它从事件发生可能性这样的束缚上解脱出来，从而获得一个纯粹的数学定义。为了实现这种测度的构造，就可以人为的对样本空间到实数域的映射规则进行规定，即：</p>
<ol type="1">
<li>概率必然是非负的，即 <span class="math inline">\(P(A)\ge 0\)</span></li>
<li>样本空间所代表的全集，概率规定为1，即 <span class="math inline">\(P(\Omega)=1\)</span></li>
<li>对于任意可列的互不相容事件（即两两交集均为 <span class="math inline">\(\varnothing\)</span> 的子集），它们并集的概率等于它们概率的和，即 <span class="math inline">\(P(A\cup B)=P(A)+P(B)\)</span></li>
</ol>
<p>满足这三个条件的映射，即有概率 <span class="math inline">\(P\)</span> ，这也被称为概率的公理化定义。</p>
<p>也由于这种定义的实质就是将样本空间对实数进行映射，故而这种映射也被称为<strong>概率测度</strong>。</p>
<p>条件概率公式所反映的，实际上是决策树的<strong>剪枝</strong>过程。而条件概率的本质，则是<strong>由于前提事件的发生所导致的待计算事件其样本点与样本空间的同时缩小（如同上文中文氏图所示的右侧聚焦过程）</strong>。</p>
<p><strong>全概率公式</strong>：</p>
<p>假设：样本空间 <span class="math inline">\(S\)</span> 有一个完备的事件组 <span class="math inline">\(A_1,A_2,A_3\)</span>：也就是样本空间被这三个事件瓜分完了</p>
<p>满足两个条件：三个事件：</p>
<ol type="1">
<li><span class="math inline">\(A_1 \cup A_2 \cup A_3=\Omega\)</span></li>
<li><span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span></li>
</ol>
<p>则又有一事件 <span class="math inline">\(B\)</span> 时，<span class="math inline">\(P(B)=P(B \cap \Omega)=P[B\cup (A_1 \cup A_2 \cup A_3)]=P(BA_1 \cup BA_2 \cup BA_3)\)</span></p>
<p>因为 <span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span>，所以 <span class="math inline">\(BA_1 \cup BA_2 \cup BA_3=\varnothing\)</span></p>
<p>所以：<span class="math inline">\(P(BA_1 \cup BA_2 \cup BA_3)=P(BA_1)+P(BA_2)+P(BA_3)\)</span></p>
<p>由条件概率公式可得：</p>
<p><span class="math inline">\(P(B)=P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)\)</span></p>
<p>即全概率公式事实上是一种<strong>对事件的先验分解</strong>。</p>
<p>全概率公式的使用条件，就是连续做多次实验，可以画出决策树，然后每一种分支可能性会发生变化，即前一次的选择会对下一次的选择产生影响；这是若求解第二轮即以后某个结果发生的可能性，则使用全概率公式</p>
<p>贝叶斯公式：</p>
<p>贝叶斯公式是后验的，即，我们已经做了实验，然后通过实验结果我们不断去修正导致这一结果发生的某些概率值</p>
<p>贝叶斯公式可以由全概率公式变形得来： <span class="math display">\[
\begin{aligned}
P(A_1|B)&amp;=\frac{P(A_1B)}{P(B)}\\
&amp;=\frac{P(A_1B)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}\\
&amp;=\frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}
\end{aligned}
\]</span></p>
<p>随机变量：随机变量的本质实际上就是<strong>随机事件的数字化</strong>。</p>
<p>现实世界中各色各样具象的随机事件，可以被映射成数学世界中抽象的数字，而这种映射规则就叫做随机变量。</p>
<p>离散随机变量的概率质量函数（<span class="math inline">\(pmf\)</span>）：</p>
<p>离散性随机变量记作 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的可能值是一个可数集合中的元素：<span class="math inline">\(S_X={x_1,x_2,x_3...}\)</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span></th>
<th><span class="math inline">\(x=1\)</span></th>
<th><span class="math inline">\(x=0\)</span></th>
<th><span class="math inline">\(x=2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(pmf\)</span></td>
<td><span class="math inline">\(P(x=1)=0.125\)</span></td>
<td><span class="math inline">\(p(x=0)=0.25\)</span></td>
<td><span class="math inline">\(P(x=2)=0.625\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(pmf\)</span> 的性质：</p>
<ul>
<li><p><span class="math display">\[
对于所有\;x\; 都有 \;P_X(x)\ge 0
\]</span></p></li>
<li><p><span class="math display">\[
\sum_{x\in S}P_X(x)=1
\]</span></p></li>
<li><p><span class="math display">\[
P(X\;in\;B)=\sum_{x\in B}P_X(x)\;其中B\subset S_X 
\]</span></p></li>
</ul>
<p>随机变量可以是离散的，连续的和混合的</p>
<p>累积分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function），常被使用在随机变量的正式定义中，可以处理三种类型的随机变量</p>
<p>一个离散性随机变量的 <span class="math inline">\(pmf\)</span> 是由 <span class="math inline">\(\{X=b\}\)</span> 来定义的，累计分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function）则是由 <span class="math inline">\(\{X\le b\}\)</span> 来定义的。</p>
<p>累计分布函数的优点在于它不局限于离散型随机变量，而是可以在所有类型的随机变量中使用</p>
<ol type="1">
<li><span class="math inline">\(F_X(x)\)</span>必然是一个单调不减函数——因概率不可为负，随着对应样本点的增多，概率的累加必然是单调不减的；</li>
<li><span class="math inline">\(F_X(x)\)</span> 必然是一个右连续函数；</li>
<li><span class="math inline">\(\lim_{n \to -\infty}F_X(x)=0\)</span>，<span class="math inline">\(\lim_{n \to \infty}F_X(x)=1\)</span> ——即对应样本点集合为空时，概率必然为0，而对应样本点集合为整个样本空间时，概率必然为1。</li>
</ol>
<p>可以看到，无论分布函数以何种形式构造，又呈现出何种性质，其最最核心的效用，就是为了能够良好的表示出样本空间的这一性质： <span class="math display">\[
P_1+P_2+P_3+...+P_n=\sum_iP_i=1
\]</span> 即实现样本空间 <span class="math inline">\(S\)</span> 对应的概率<strong>归向于1</strong>，从而完成样本空间向值域 <span class="math inline">\([0,1]\)</span> 的映射。因此，分布函数的本质实际上是<strong>随机变量的归一化</strong>。</p>
<p>而当随机变量由离散型扩展至连续型时，在把握到分布函数的本质是样本点概率的累加函数以后，便可以推测连续型随机变量的分布函数 <span class="math inline">\(F_X(x)\)</span> 必然会表现为一种积分形式。</p>
<p>但是与离散型概率分布中，每个随机变量对应着一个确定的概率值所不同，若以类似的方式来通过分布函数计算连续型随机变量中任意一点的概率，即用这一点的分布函数值减去这一点处左极限的分布函数值： <span class="math display">\[
P\{x=x_0\}=F_X(x_0)-\lim_{n \to x_0^-}F_X(x_0)
\]</span> 由于 <span class="math inline">\(F_X(x)\)</span> 是连续的概率累加，因此它在性质上也必然是一个非负不减的连续函数，故根据连续的性质，有： <span class="math display">\[
F_X(x_0)=\lim_{n \to x_0^+}F_X(x_0)= \lim_{n \to x_0^-}F_X(x_0)
\]</span> 故有： <span class="math display">\[
P\{x=x_0\}=0
\]</span> 由此可以看到，无论我们怎么计算，在连续型随机变量的分布函数上想要直接计算某一点处的概率，它将始终都会是0。</p>
<p>从这一结论，你应该就能明白，在概率论的开篇中，我们提到通过引入测度，将事件的概率测度与它在现实中发生的可能性这两个概念分开具有怎样重要的意义。</p>
<p>可以看到，在连续型随机变量中，某一点出的概率为0，并不意味着它在事件发生的角度来看是不可能的，而只是意味着这一点处的概率测度为0。</p>
<p>而之所以会出现概率测度为0的原因，是因为在这里一开始所着眼的计算目标就错了。打个比方来说就相当于，你并不会去计算一个点的长度，不会去计算一条线的面积，不会去计算一个面的体积。换句话说，在连续型随机变量中，计算某一点处的概率就相当于在求一条线的面积。</p>
<p>在认识到这一点之后，为了刻画连续型随机变量中某点处局部的概率性质就需要另外的工具，而这个工具在微积分的阶段就已经准备好早已被我们熟稔于胸——当然就是导数，即有： <span class="math display">\[
F^{&#39;}_X(x_0)=\lim_{x\to x_0}\frac{F_X(x)-F_X(x_0)}{x-x_0}
\]</span> 换句话说，对于连续型随机变量，我们用以刻画在一点处局部性质的量不是概率，而应该是<strong>概率测度的变化率。</strong></p>
<p>借用我们在散度与测度一章中的两个相类似的例子来说，就是：</p>
<ul>
<li>在位移运动中，刻画某一瞬时性质的不是位移而是速度；</li>
<li>在有质物体中，刻画某一质点性质的不是质量而是密度。</li>
</ul>
<p>也因此，以质量与密度的关系来考量概率与概率变化率，才会将连续型随机变量的分布函数，一个变上限积分：<span class="math inline">\(F(x)=\int^x_{-\infty}f(t)dt\)</span> 的导函数： <span class="math inline">\(F&#39;(x)=f(x)\)</span> 命名为<strong>概率密度</strong>。</p>
<p>更要值得一提的是，如果用离散型随机变量的概率分布即：</p>
<p>一个随机变量对应一个确定的概率测度 <span class="math inline">\(x_i\sim P_i\)</span></p>
<p>来进行类比的话，连续型随机变量的概率分布实际上应当为：</p>
<p>一个随机变量对应其<strong>附近领域</strong>的概率测度 <span class="math inline">\(x_i\sim f(x_i)dx_i\)</span></p>
<p>而非直接对应概率密度函数 <span class="math inline">\(f(x)\)</span>，从这个类比，可以更直观的认为，若视离散型随机变量的分布函数为一个楼层分明的阶梯，那么连续型随机变量的分布函数就是一个将楼层无限增加细分从而使层次分明的阶梯最终转换为一个<strong>平滑化</strong>的斜坡。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/30/11-27-50/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/30/11-27-50/" class="post-title-link" itemprop="url">OpenCv笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-30 11:27:50" itemprop="dateCreated datePublished" datetime="2022-03-30T11:27:50+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-04 17:25:07" itemprop="dateModified" datetime="2022-04-04T17:25:07+08:00">2022-04-04</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/30/11-27-50/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/30/11-27-50/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR 8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或 -1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如 <span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>， <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong> 等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span> 中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数 <code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span> 转换，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于 <span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在 <span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较 <span class="math inline">\(OpenCV\)</span> 值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span> 图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在 $ HSV$ 中，比在 <span class="math inline">\(BGR\)</span> 颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span> 图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a target="_blank" rel="noopener" href="https://www.stackoverflow.com/">stackoverflow.com</a> 中发现的一个常见问题。它非常简单，你可以使用相同的函数<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的 <span class="math inline">\(BGR\)</span> 值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$ 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和 <span class="math inline">\([H+10, 255,255]\)</span> 为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整 <span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong> 和 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为 <span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span> 用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span> 提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code> 函数。详情请查看 <span class="math inline">\(matplotlib\)</span> 文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a> 接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span> 是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv.imread(r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;,0)</span><br><span class="line">kernel = np.ones((2,1),np.uint8)</span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line">#erosion = cv.erode(img,kernel,iterations = 1)</span><br><span class="line">cv.imshow(&#x27;res&#x27;,closing)</span><br><span class="line">k = cv.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span> 的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span> 的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 函数，其中 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 是 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a> 被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为 <span class="math inline">\(127\)</span> 的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span> 阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span> 实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span> 的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad \&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2 \frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span> 的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在 <span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span> 有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong> 来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示： <span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span> 操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong> 或 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong> 完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个 <span class="math inline">\(3x3\)</span> 标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数 <code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span> 内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong> 完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是 $ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了 <span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$ 取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong> 创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong> 取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span> 的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong> 在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a target="_blank" rel="noopener" href="https://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">2</span>,<span class="number">2</span>),np.uint8)</span><br><span class="line"><span class="comment">#closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span></span><br><span class="line"><span class="comment">#erosion = cv.erode(img,kernel,iterations = 1)</span></span><br><span class="line"><span class="comment">#dilation = cv.dilate(img,kernel,iterations = 1)</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,opening)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong> 等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是 <span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span> 的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut 算法的交互式前景提取</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/29/16-12-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/29/16-12-02/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-29 16:12:02" itemprop="dateCreated datePublished" datetime="2022-03-29T16:12:02+08:00">2022-03-29</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/29/16-12-02/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/29/16-12-02/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">clc; </span><br><span class="line">close all; </span><br><span class="line">clear all; </span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;);%要求你.m文件下有test.bmp这个图像文件 </span><br><span class="line">PR=I(:,:,1);%提取红色分量 </span><br><span class="line">PG=I(:,:,2);%提取绿色分量 </span><br><span class="line">PB=I(:,:,3);%提取蓝色分量 </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(PR);title(&#x27;提取红分量后&#x27;); </span><br><span class="line">subplot(2,2,3);imshow(PG);title(&#x27;提取绿色分量后&#x27;); </span><br><span class="line">subplot(2,2,4);imshow(PB);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;); </span><br><span class="line">[m,n,d]=size(I); </span><br><span class="line"> </span><br><span class="line">level=15;%设置阈值 </span><br><span class="line">level2=70;%设置阈值 </span><br><span class="line"> </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,1)-I(i,j,2)&gt;level2)&amp;&amp;(I(i,j,1)-I(i,j,3)&gt;level2)) </span><br><span class="line">            r(i,j,1)=I(i,j,1); </span><br><span class="line">            r(i,j,2)=I(i,j,2); </span><br><span class="line">            r(i,j,3)=I(i,j,3); </span><br><span class="line">       else  </span><br><span class="line">            r(i,j,1)=255; </span><br><span class="line">            r(i,j,2)=255; </span><br><span class="line">            r(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(r);title(&#x27;提取红分量后&#x27;);%显示提取红分量后的图 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取绿分量，不满足阈值的变为白色 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,2)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,2)-I(i,j,3)&gt;level)) </span><br><span class="line">            g(i,j,1)=I(i,j,1); </span><br><span class="line">            g(i,j,2)=I(i,j,2); </span><br><span class="line">            g(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            g(i,j,1)=255; </span><br><span class="line">            g(i,j,2)=255; </span><br><span class="line">            g(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,3);imshow(g);title(&#x27;提取绿分量后&#x27;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取蓝色分量 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,3)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,3)-I(i,j,2)&gt;level)) </span><br><span class="line">                    b(i,j,1)=I(i,j,1); </span><br><span class="line">                    b(i,j,2)=I(i,j,2); </span><br><span class="line">                    b(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            b(i,j,1)=255; </span><br><span class="line">            b(i,j,2)=255; </span><br><span class="line">            b(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,4);imshow(b);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%清空变量，读取图像</span></span><br><span class="line">RGB = imread(<span class="string">&#x27;2019050913413134.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;process&#x27;</span>),</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(RGB),title(<span class="string">&#x27;原始RGB&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%convert frame from RGB to YCBCR colorspace（转换到YCBCR空间）</span></span><br><span class="line">YCBCR = rgb2ycbcr(RGB);</span><br><span class="line">whos,</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(YCBCR),title(<span class="string">&#x27;YCBCR&#x27;</span>),</span><br><span class="line"><span class="comment">%filter YCBCR image between values and store filtered image to threshold</span></span><br><span class="line"><span class="comment">%matrix（用各个通道的阈值对其进行二值化处理）</span></span><br><span class="line">Y_MIN = <span class="number">0</span>;  Y_MAX = <span class="number">256</span>;</span><br><span class="line">Cb_MIN = <span class="number">100</span>;   Cb_MAX = <span class="number">127</span>;</span><br><span class="line">Cr_MIN = <span class="number">138</span>;   Cr_MAX = <span class="number">170</span>;</span><br><span class="line">threshold=roicolor(YCBCR(:,:,<span class="number">1</span>),Y_MIN,Y_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">2</span>),Cb_MIN,Cb_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">3</span>),Cr_MIN,Cr_MAX);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(threshold),title(<span class="string">&#x27;YCBCR二值化&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%perform morphological operations on thresholded image to eliminate noise</span></span><br><span class="line"><span class="comment">%and emphasize the filtered object(s)（进行形态学处理：腐蚀、膨胀、孔洞填充）</span></span><br><span class="line">erodeElement = strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">3</span>) ;</span><br><span class="line">dilateElement=strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">8</span>) ;</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imfill(threshold,<span class="string">&#x27;holes&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(threshold),title(<span class="string">&#x27;形态学处理&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%获取区域的&#x27;basic&#x27;属性， &#x27;Area&#x27;, &#x27;Centroid&#x27;, and &#x27;BoundingBox&#x27; </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;处理结果&#x27;</span>),</span><br><span class="line">stats = regionprops(threshold, <span class="string">&#x27;basic&#x27;</span>);</span><br><span class="line">[C,area_index]=<span class="built_in">max</span>([stats.Area]);</span><br><span class="line"><span class="comment">%定位脸部区域</span></span><br><span class="line">face_locate=[stats(area_index).Centroid(<span class="number">1</span>),stats(area_index).Centroid(<span class="number">2</span>)];</span><br><span class="line">imshow(RGB);title(<span class="string">&#x27;after&#x27;</span>),<span class="built_in">hold</span> on</span><br><span class="line">text(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>)<span class="number">-40</span>,  <span class="string">&#x27;face&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>), <span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[stats(area_index).BoundingBox],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/23/15-24-59/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/23/15-24-59/" class="post-title-link" itemprop="url">电子专业资料共享计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-23 15:24:59" itemprop="dateCreated datePublished" datetime="2022-03-23T15:24:59+08:00">2022-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-03 17:27:43" itemprop="dateModified" datetime="2022-04-03T17:27:43+08:00">2022-04-03</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/23/15-24-59/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/23/15-24-59/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言">前言</h1>
<blockquote>
<p>我也曾很努力地收集各种课程资料，但到最后，某些重要信息的得到却往往依然是纯属偶然。这种状态时常令我感到后怕与不安。我也曾在课程结束后终于有了些许方法与总结，但这些想法无处诉说，最终只能把花费时间与精力才换来的经验耗散在了漫漫的遗忘之中。</p>
<p>我为这一年一年，这么多人孤军奋战的重复劳动感到不平。</p>
<p>我希望能够将这些隐晦的、不确定的、口口相传的资料和经验，变为公开的、易于获取的和大家能够共同完善、积累的共享资料。</p>
<p>我希望只要是前人走过的弯路，后人就不必再走。这是我的信念，也是我建立这个项目的原因。</p>
</blockquote>
<p>注：如果您对本篇博客的目的存在疑问，请阅读<a target="_blank" rel="noopener" href="https://qsctech.github.io/zju-icicles/">此文</a>。</p>
<h3 id="加入我们">加入我们：</h3>
<p><strong>如果您有意愿加入该计划，请注册wolai账号并在<a target="_blank" rel="noopener" href="https://www.wolai.com/aPVPDQTgKUnVaE9JQzKudx">此处</a>进行编辑，请选择文章最后一部分的”推荐模板“，并复制在其上面，然后将副标题改做”来自xxx的推荐“，结束后在评论区评论以联系我去将内容发布在博客内。</strong></p>
<h1 id="河南大学迈阿密学院电子信息专业培养计划及其课本">河南大学迈阿密学院电子信息专业培养计划及其课本</h1>
<h3 id="大一上学期">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 1 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>3 Longman Academic Writing Series</em><br> （无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 1 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>中国近现代史纲要</td>
<td>《中国近现代史纲要 （2018年版）》</td>
</tr>
<tr class="even">
<td>形式与政策</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>大学体育（一）College Physical Education I</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><a target="_blank" rel="noopener" href="https://kdocs.cn/l/cbVej03YO5yb?f=201"><em>Elementary Linear Algebra</em><br></a>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td><em>Thinking Like an Engineer</em><br>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>编程导论（Introduction to Programming）</td>
<td><em>C++ Pregramming program Design Including Data Structures</em><br>（无中文版和答案）</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 2 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td>The Everyday Writer 6th Edition <br>（无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td>《流畅英语口语教程 第二册》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 2 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>思想道德修养与法律基础</td>
<td>《思想道德修养与法律基础 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（二）College Physical Education II</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 下》<br>参考答案</td>
</tr>
<tr class="odd">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td><em>Engineering Circuit Analysis</em><br>《工程电路分析 中文版》<br></td>
</tr>
<tr class="even">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td><em>Electric Circuit Ninth Edition</em><br>《电路 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>电路实验</td>
<td>“教师讲义 + 教学课件”</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 3 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>Technical Writing A Practical Guide for Engineers, Scientists, and Nontechnical Professionals by Phillip A. Laplante</em><br>无中文版</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 3 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>马克思主义基本原理概论</td>
<td>《马克思主义基本原理概论 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（三）College Physical Education III</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td><em>A Textbook on Ordinary Differential Equations</em><br>（无中文版和参考答案）<br>参考书：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="odd">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>数据结构（Data Structures）</td>
<td>《数据结构（C语言版）》<br><em>Data Structures Using C</em><br>参考资料：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1">视频课</a></td>
</tr>
<tr class="even">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="odd">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共两门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 4 智慧版》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 4 智慧版》</td>
</tr>
<tr class="even">
<td>大学体育（四）（College Physical Education IV）</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td><em>Probability, Statistics, and Random Processes For Electrical Engineerin</em><br>《机率与统计 第三版 中文版 台版》<br><a href>参考答案</a><br>参考资料：《概率论与数理统计 (第四版)》</td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>《信号与系统（郑君里）第三版 上》<br>参考书籍：<br>《信号与系统（郑君里）第三版 下》<br>《信号与系统（奥本海姆）第二版》</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td><em>Fundamentals Of Logic Design Seven Edition</em><br>《逻辑设计基础 中文版》<br>参考答案</td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>ARM：《微机原理与接口技术 第三版 基于ARM Cortex-M4 田辉》<br><em>Practical Microcontroller Engineering with ARMÂ­ Technology by Ying Bai<br></em>参考资料：x86：《微型计算机原理与接口技术》</td>
</tr>
<tr class="even">
<td><del>电子电路CAD （Electronic Circuit CAD）</del></td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期">大三上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td><em>Signal &amp; System</em><br>《中文版 信号与系统 奥本海姆》</td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td><em>Field and Wave Electromagnetics by David K. Cheng</em><br>《电磁场与电磁波 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td><em>Semiconductor physics and devices basic principles by Donald A. Neamen</em><br>《半导体物理与器件 中文版》</td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td><em>The 8051 Microcontroller A Systems Approach (Mazidi, Muhammad AliMcKinlay, Rolin DMazidi etc.)</em> <br>《8051单片机系统》<br>《单片机原理及接口技术 第5版》</td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td><em>Verilog HDL - A Guide To Digital Design And Synth<br></em>《Verilog HDL 数字设计与综合》</td>
</tr>
<tr class="even">
<td>创新项目实践（一）Practice of Innovation Project I</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期">大三下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td><del>《嵌入式系统设计——基于STM32CubeMX与HAL库》</del></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin<br></em>《通信系统 中文版》<br>《通信原理 第七版》</td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin</em><br>参考答案</td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td>《电力电子技术》<br>参考答案</td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td><em>Digital integrated circuits a design perspective</em><br>《数字集成电路——电路系统与设计 中文版》</td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td><em>Design of Analog CMOS Integrated Circuits by Behzad Razavi</em><br>《数字集成电路：电路、系统与设计第2版》<br></td>
</tr>
<tr class="odd">
<td>创新项目实践（二）Practice of Innovation Project II</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐">电子专业课程书籍课程资源推荐</h1>
<h2 id="来自邱金羽的推荐">——来自邱金羽的推荐</h2>
<h3 id="大一上学期-1">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td>课本讲的挺不错<br>入学前可以看一下 <span class="math inline">\(3Blue1Brown\)</span> 的数学频道，微积分对应为：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qW411N7FU">微积分的本质</a>》<br>国内常用教材为：《高等数学》<br>推荐一个写微积分比较好的知乎文章：《<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1249046061567741952">Re:从零开始的数学世界生活</a>》，里面包括微积分、线性代数和概率论的知识</td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><span class="math inline">\(3Blue1Brown\)</span> 的数学频道：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ys411472E">线性代数的本质</a>》</td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td>无</td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td>工程学导论教学内容：Excal + Matlab + 编程基础 + CAD基础<br>Excal要求很低，会使用基本函数就行<br>Matlab很值得学习，主要包括基本的语法和绘图操作，建议跟着官网的教程学习：<a target="_blank" rel="noopener" href="https://matlabacademy.mathworks.com/details/matlab-onramp/gettingstarted">Matlba Courses</a><br>Matlab学习中实现一些小项目可以帮助自己去理解，善用谷歌搜索和官网文档解决问题<br>对电子来说编程基础与编程导论课程内容重复<br>CAD基础，课时很少，简单了解</td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td>推荐网课：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ls411w7rx?spm_id_from=..search-card.all.click">C语言程序设计</a>》<br>推荐书籍：《C Primer Plus 中文版》（这本书适合作为工具书使用，其中代码写的比较规范，适合跟着敲练习）<br> 《C Primer Plus 中文版》</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-1">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td>同上</td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td>大物二：声热光，相对没大物三的电磁重要</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>大物实验课比较水</td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td>Matlab绘图：如果大一学的好，现在应该不需要再学了<br>推荐一些博客：<br>《<a target="_blank" rel="noopener" href="http://cighao.com/2016/04/11/draw-picture-with-matlab-001-line-style/">matlab 画图</a>》<br>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4220232.html">MATLAB学习笔记</a>》</td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td>强烈推荐看完整个《电路》课本，里面很多知识很重要</td>
</tr>
<tr class="even">
<td>电路实验</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-1">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td>可以参考国内教材：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td>电磁部分比较难，需要认真学</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>比较水</td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td>强烈推荐使用此视频入门数据结构：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1">深入浅出数据结构 - 顶尖程序员图文讲解</a><br>课程较难，需要认真学习</td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td>可以使用此课程进行半导体器件的入门，比较生动：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qt411m7Vm">可汗学院-半导体器件</a>》<br>强烈推荐使用此课程进行学习《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>与理论课不匹配</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-1">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td>强烈推荐使用此课程进行学习《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>有一点匹配</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-1">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-1">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐-1">电子专业课程书籍课程资源推荐</h1>
<h2 id="推荐模板">——推荐模板</h2>
<h3 id="大一上学期-2">大一上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td></td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td></td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-2">大一下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td></td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电路实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-2">大二上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-2">大二下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-2">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-2">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/15/15-32-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/15/15-32-05/" class="post-title-link" itemprop="url">记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-15 15:32:05" itemprop="dateCreated datePublished" datetime="2022-03-15T15:32:05+08:00">2022-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-31 15:06:04" itemprop="dateModified" datetime="2022-03-31T15:06:04+08:00">2022-03-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/15/15-32-05/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/15/15-32-05/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="fpga">FPGA</h1>
<h3 id="时序约束">时序约束</h3>
<ol type="1">
<li>如通信实验，时钟频率比较高的实验，需要进行时序约束</li>
<li>当占用芯片的逻辑资源多的时候，需要使用时序约束：因为FPGA在布线时会优先考虑面积</li>
</ol>
<p>时钟约束用来描述设计人员对于时序的要求，包括时钟频率和输入输出延时</p>
<p>D触发器</p>
<p>arduino 机械臂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myservo_1;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_2;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_3;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line"><span class="type">int</span> pos_1 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_2 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_3 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.attach(<span class="number">12</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">    myservo_2.attach(<span class="number">11</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">      myservo_3.attach(<span class="number">10</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_1 = <span class="number">0</span>; pos_1 &lt;= <span class="number">10</span>; pos_1 ++) &#123; <span class="comment">// 0°到180°</span></span><br><span class="line">    <span class="comment">// in steps of 1 degree</span></span><br><span class="line">    myservo_1.write(pos_1);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">for</span> (pos_2 = <span class="number">0</span>; pos_2 &lt;= <span class="number">60</span>; pos_2 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_2.write(pos_2);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_3 = <span class="number">0</span>; pos_3 &lt;= <span class="number">30</span>; pos_3 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_3.write(pos_3);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_1.write(<span class="number">-5</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////  for (pos_1 = 0; pos_1 &lt;= 120; pos_1 ++) &#123; // 0°到g180°</span></span><br><span class="line"><span class="comment">////    // in steps of 1 degree</span></span><br><span class="line"><span class="comment">////    myservo_1.write(pos_1);              // 舵机角度写入</span></span><br><span class="line"><span class="comment">////    delay(5);                       // 等待转动到指定角度</span></span><br><span class="line"><span class="comment">////  &#125;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字电路中的逻辑值">数字电路中的逻辑值：</h3>
<ul>
<li>逻辑 0：表示低电平，相当于电路 GND。</li>
<li>逻辑 1：表示高电平，相当于电路 VCC。</li>
<li>逻辑 X：表示未知，高或低。</li>
<li>逻辑 Z：表示高阻态，悬空状态</li>
</ul>
<h3 id="verilog-中的数字表示">Verilog 中的数字表示：</h3>
<p>“（数字的二进制）位宽 + 进制（缩写） + 数值”来表示一个数字。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制0101的表示</span></span><br><span class="line"><span class="number">4&#x27;b0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制2的表示，数字2的二进制表示为0010占4位</span></span><br><span class="line"><span class="number">4&#x27;d2</span></span><br></pre></td></tr></table></figure>
<p>Verilog 的默认二进制位宽为32位，默认的进制为十进制。</p>
<p>当二进制数字位数多的时候可以使用下划线增加可读性，编译时下划线会被去掉。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16&#x27;b1001_1010_1010_1001</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符">标识符：</h4>
<p>Verilog 的标识符可以用于定义模块名、端口名和信号名。</p>
<p>Verilog 的命名规则与 C 语言变量名的命名规则基本相同：只有一点，可以在命名中包含$符号。</p>
<p>标识符规则：</p>
<ul>
<li></li>
</ul>
<p>标识符推荐写法：</p>
<ul>
<li>不建议大小写混合</li>
<li>普通内部信号全部小写</li>
<li>信号命名体现含义</li>
<li>使用下划线区分词</li>
<li>采用前后缀：比如时钟可以采用：clk_50，clk_cpu</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>三种数据类型：</p>
<ul>
<li><p>寄存器数据类型：实际电路物理模型</p>
<ul>
<li><p>抽象数据存储单元，可以通过赋值语句改变寄存器储存的值</p></li>
<li><p>关键字：reg，默认初始值为 X 不确定</p></li>
<li><p>```verilog // reg + [位宽：31:0 指32位位宽，高位在前] + 标识符名称（寄存器名称） reg [31:0] delay_cnt; //延时计数使用的寄存器 reg key_reg; //没给位宽时默认位宽为1 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + reg 类型的数据只能在 always 语句和 initial 语句中被赋值</span><br><span class="line"></span><br><span class="line">  + 如果 always 中带有时钟信号即过程语句描述的是时序逻辑，则寄存器对应为触发器</span><br><span class="line"></span><br><span class="line">  + 如果 always 中不带有时钟信号即过程语句描述的是组合逻辑，则寄存器对应为硬件连线</span><br><span class="line"></span><br><span class="line">  + </span><br><span class="line"></span><br><span class="line">+ 线网数据类型：实际电路物理模型</span><br><span class="line"></span><br><span class="line">+ 参数数据类型：给编译器用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 图像处理</span><br><span class="line"></span><br><span class="line">OV7725摄像头</span><br><span class="line"></span><br><span class="line">主控器控制OV7725时采用SCCB协议读写其寄存器，而它输出图像时则使用VGA或QVGA时序， 其中VGA在输出图像分辨率为480*640时采用，QVGA是Quarter VGA，其输出分辨率为240*320， 这些时序跟控制液晶屏输出图像数据时十分类似。</span><br><span class="line"></span><br><span class="line">OV7725传感器输出图像时，一帧帧地输出，在帧内的数据一般从左到右，从上到下， 一个像素一个像素地输出(也可通过寄存器修改方向)，见图 [摄像头数据输出](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id20) 。</span><br><span class="line"></span><br><span class="line">![摄像头数据输出](记录/OV7725012.jpg)</span><br><span class="line"></span><br><span class="line">例如，见图 [像素同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id21) 和图 [QVGA帧图像同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#qvga) ， 若我们使用D2-D9数据线，图像格式设置为RGB565，&lt;img src=&quot;记录/image-20220326130518483.png&quot; alt=&quot;image-20220326130518483&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">```verilog</span><br><span class="line">//RGB数据转换为YCBCR</span><br><span class="line">//因为FPGA处理除法是比较耗费资源的，所以我们团队采用左移右移以替代乘除法。处理整形数据可以将数据整体左移八位，再进行计算，最后在右移回去即可。</span><br><span class="line"></span><br><span class="line">Y’ = 0.257R’ + 0.504G’ + 0.098*B’ + 16</span><br><span class="line">Cb’ = -0.148R’ - 0.291G’ + 0.439*B’ + 128</span><br><span class="line">Cr’ = 0.439R’ - 0.368G’ - 0.071*B’ + 128</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>进行数据输出时，D2-D9数据线在PCLK在上升沿阶段维持稳定， 并且会在1个像素同步时钟PCLK的驱动下发送1字节的数据信号，所以2个PCLK时钟可发送1个RGB565格式的像素数据。 当HREF为高电平时，像素数据依次传输，每传输完一行数据时，行同步信号HREF会输出一个电平跳变信号间隔开当前行和下一行的数据； 一帧的图像由N行数据组成，当VSYNC为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC会输出一个电平跳变信号。</p>
<p><img src="/2022/03/15/15-32-05/image-20220326132950059.png" alt="image-20220326132950059" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rows=<span class="number">200</span></span><br><span class="line">cols=<span class="number">300</span></span><br><span class="line">num=<span class="number">2000</span> <span class="comment">#随机像素点的个数</span></span><br><span class="line">img=np.zeros((rows,cols,<span class="number">3</span>),np.uint8)</span><br><span class="line">pos1=np.random.randint(<span class="number">200</span>,size=(num,<span class="number">1</span>)) <span class="comment">#行位置随机数组</span></span><br><span class="line">pos2=np.random.randint(<span class="number">300</span>,size=(num,<span class="number">1</span>)) <span class="comment">#列</span></span><br><span class="line"><span class="comment">#随机位置处设置像素点值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">0</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">1</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">2</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">如果在OpenCV中处理图像，是BGR的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I=numpy.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=numpy.uint8) </span><br><span class="line"><span class="comment">#图片I大小为3*3，灰度值全为0，也就是黑色图像</span></span><br><span class="line">I=cv2.cvtColor(I,cv2.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#此时图像I变成了三个通道的每个像素点的值都为0</span></span><br><span class="line"><span class="comment">#有27个像素值，HSV色彩空间也是同样的方式，只是只是通道数不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emptyImage = np.zeros(img.shape, np.uint8)</span><br><span class="line">cv2.imshow(<span class="string">&quot;EmptyImage&quot;</span>, emptyImage) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">Strawberry=cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line"><span class="comment">#Strawberry=cv2.imread(&quot;strawberry.jpg&quot;)</span></span><br><span class="line">Lower = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">Upper = np.array([<span class="number">40</span>, <span class="number">40</span>, <span class="number">255</span>])</span><br><span class="line">Binary = cv2.inRange(Strawberry, Lower, Upper)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>, Binary)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\fruits.jpg&#x27;</span>)</span><br><span class="line">fruit = cv2.cvtColor(fruit,cv2.COLOR_BGR2YUV)</span><br><span class="line">Y,U,V = cv2.split(fruit)</span><br><span class="line">Blueberry = cv2.inRange(U,<span class="number">130</span>,<span class="number">255</span>)</span><br><span class="line">Strawberry = cv2.inRange(V,<span class="number">170</span>,<span class="number">255</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;blueberry&quot;</span>,Blueberry)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>,Strawberry)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line">skin1 = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OSTU&quot;</span>, skin1)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cr_otsu1</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;YCrCb颜色空间的Cr分量+Otsu阈值分割</span></span><br><span class="line"><span class="string">    :param image: 图片路径</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"></span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">_, skin = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image raw&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image raw&quot;</span>, img)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image CR&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, skin)</span><br><span class="line"></span><br><span class="line">dst = cv2.bitwise_and(img, img, mask=skin)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;seperate&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;seperate&quot;</span>, dst)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="灰度化">灰度化</h3>
<p>转换色彩空间：</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\name_of_picture&#x27;</span>)</span><br><span class="line">img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"><span class="comment">#img_YUV = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span></span><br><span class="line"><span class="comment">#img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img_ycbcr)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>以RGB格式的彩图为例，通常灰度化采用的方法主要有：</p>
<p>方法1：<span class="math inline">\(Gray=(R+G+B)/3\)</span></p>
<p>方法2：<span class="math inline">\(Gray=max(R,G,B)\)</span></p>
<p>方法3：<span class="math inline">\(Gray=0.299R+0.587G+0.114B\)</span>（这种参数考虑到了人眼的生理特点）</p>
<p>所谓阈值处理，就是给定一个阈值，当像素值比指定阈值大或小时做相关的操作。==这个字念yu，不是fa==，方法签名为:<code>cv2.threshold(src,thresh,maxval,type,dst=None)</code>,需要将的是OpenCV中提供的几种type：</p>
<ul>
<li>cv2.THRESH_BINARY：若像素值大于阈值，则置为maxval；否则置0</li>
<li>cv2.THRESH_BINARY_INV：THRESH_BINARY的反转</li>
<li>cv2.THRESH_TRUNC：若像素值大于阈值，则置为阈值；否则不变</li>
<li>cv2.THRESH_TOZERO：小于阈值的部分置为0；其他不变</li>
<li>cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">_, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY_INV)</span><br><span class="line">_, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TRUNC)</span><br><span class="line">_, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO)</span><br><span class="line">_, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO_INV)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#固定阈值的二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>选则合适的阈值筛选不同的色块，链接下文轮廓识别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自适应阈值二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th3)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="腐蚀">腐蚀</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;i.png&quot;</span>)</span><br><span class="line">img_noise = copy.deepcopy(img)</span><br><span class="line"><span class="comment"># add some noise to original image</span></span><br><span class="line">rows, cols = img_noise.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">	i = random.randint(<span class="number">0</span>, rows - <span class="number">1</span>)</span><br><span class="line">	j = random.randint(<span class="number">0</span>, cols - <span class="number">1</span>)</span><br><span class="line">	img_noise[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), dtype=np.uint8)</span><br><span class="line">erosion = cv2.erode(img_noise, kernel)</span><br><span class="line">dilation = cv2.dilate(erosion, kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;rectangle.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_contours_of_binary_image</span>():</span><br><span class="line">	im = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>)</span><br><span class="line">	imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">	ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">		<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">	res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">   	img_show(res)</span><br><span class="line">    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>轮廓检测能用代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">kernel = np.ones((<span class="number">1</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, anchor=(<span class="number">2</span>, <span class="number">0</span>), iterations=<span class="number">5</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>能看懂的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调节二值化的阈值可以描出不同的色块</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">100</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="二值化">二值化</h3>
<p>二值图也就是黑白图。将灰度图转换成黑白图的过程，就是二值化。二值化的一般算法是：</p>
<p><span class="math inline">\(g={0,f≤t1,f&gt;t}\)</span></p>
<p>其中t被称为阀值。阀值的确定方法有下面几种。</p>
<h2 id="otsu法大津法或最大类间方差法">Otsu法（大津法或最大类间方差法）</h2>
<p>来自霓虹国的大津展之为这种波谷找到了一个合适的数学表达，并于 1979 年发表论文[2]。这个二值化方法称为<strong>大津算法（Otsu’s method）</strong>。</p>
<p>大津算法就是，<strong>从 1 到 255 一个个数字试，找到一个数字能够把两个波峰切开</strong>，让两个波峰内部的类内方差之和最小。类内方差之和就是，单独求这两个波峰各自的方差，乘上波峰的占比权重，然后加起来。</p>
<p>这个数字就能最好的把图像分开，<strong>对应的就是双峰直方图中的波谷</strong>。这个算法最多只需遍历两次直方图数组，速度飞快，至今仍被广泛应用。</p>
<p>图像比较复杂的时候，我们对大津算法稍加扩展也可以完成分割。对大津算法的多级推广成为<strong>多大津算法（multi Otsu method） [3]</strong>。</p>
<p>*这里提到的是局部阈值的基本方法，对于实际使用中常见的其他局部阈值方法，请参阅<strong>Chow-Kaneko 自适应阈值法 [4]</strong>。</p>
<p>局部阈值的应用非常广泛，特别是对白纸黑字的处理非常有效。光学字符识别（OCR）和二维码扫描的算法中，很多都用了局部阈值操作。比如下面这张受光不均的二维码。</p>
<p>该算法是一种动态阈值分割算法。它的主要思想是按照灰度特性将图像划分为背景和目标2部分（这里我们将f≤t的部分称为背景，其他部分称为目标。），选取门限值，使得背景和目标之间的方差最大。</p>
<blockquote>
<p>注：Nobuyuki Otsu（大津展之），东京大学博士，先后在筑波大学和东京大学担任教授。</p>
</blockquote>
<p>其步骤如下：</p>
<p>1.建立图像灰度直方图。</p>
<p>2.计算背景和目标的出现概率。</p>
<p><span class="math inline">\(pA=∑i=0tpi,pB=∑i=t+1L−1pi=1−pA\)</span></p>
<p>其中，A和B分别表示背景部分和目标部分。</p>
<p>3.计算A和B两个区域的类间方差。</p>
<p><span class="math inline">\(公式ωA=∑i=0tipipA,ωB=∑i=t+1L−1ipipB(公式1)\)</span></p>
<p>公式1分别计算A和B区域的平均灰度值；</p>
<p>公式<span class="math inline">\(ω0=pAωA+pBωB=∑i=0L−1ipi\)</span>(公式2)</p>
<p>公式2计算灰度图像全局的灰度平均值；</p>
<p>公式<span class="math inline">\(σ2=pA(ωA−ω0)2+pB(ωB−ω0)2\)</span>(公式3)</p>
<p>公式3计算A、B两个区域的类间方差。</p>
<p>4.针对每一个灰度值，计算类间方差。选择方差最大的灰度值，作为阀值t。</p>
<p>下面是几个在使用opencv作轮廓检测时需要注意的点：</p>
<ul>
<li>为了更精确地提取轮廓，请使用二值图。也就是说，在使用轮廓提取函数前，请将源图片运用阈值进行<code>二值化(cv2.threshold())</code>或者采用<code>Canny边缘检测</code>。</li>
<li>findContours 函数会修改源图片，如果希望在轮廓检测后继续使用源图片，务必提前保存在另一个变量中。</li>
<li>在OpenCV中，轮廓检测视作从黑色背景中提取白色的物体，所以，在结果中，白色表示物体，黑色表示背景。</li>
</ul>
<p><em>提取轮廓的步骤大概会是这样子：</em></p>
<ol type="1">
<li>读取源图片，并转化为灰度图</li>
<li>运用threshold将灰度图片二值化（也可以使用Canny边缘检测）</li>
<li>使用<code>findContours()函数</code>找到所有的轮廓</li>
<li>使用<code>drawContours()函数</code>将轮廓画出来</li>
</ol>
<p>https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</p>
<h2 id="图像处理">图像处理</h2>
<h3 id="形态学">形态学</h3>
<h4 id="膨胀">膨胀</h4>
<h5 id="简介">简介</h5>
<p>膨胀是数学形态学的两种基本运算之一，腐蚀是另一种基本运算。它通常应用于二值图像，但也有适用于灰度图像的版本。该算子对二值图像的基本作用是逐渐扩大前景像素(通常为白色像素)区域的边界。因此，前景像素的区域会增大，而这些区域内的孔会变小。</p>
<h5 id="它是如何运作的">它是如何运作的</h5>
<p>这个描述的有用背景在词汇表的数学形态学部分给出。</p>
<p>膨胀运算符接受两段数据作为输入。首先是要放大的图像。第二个是一组坐标点(通常很小)，称为结构元素(也称为内核)。正是这个构造元素决定了输入图像的精确膨胀效果。</p>
<p>二值图像膨胀的数学定义如下：</p>
<p>设X为输入二值图像对应的欧几里德坐标集，K为构造元素的坐标集。</p>
<p>Kx表示K的平移使其原点在x处。</p>
<p>那么X乘以K的膨胀就是所有点X的集合使得Kx与X的交点非空。</p>
<p>除了与输入图像相关联的一组坐标的导出方式之外，灰度膨胀的数学定义是相同的。此外，这些坐标是三维的，而不是二维的。</p>
<p>作为二元扩张的一个例子</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/09/16-14-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/09/16-14-26/" class="post-title-link" itemprop="url">逻辑设计基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-09 16:14:26" itemprop="dateCreated datePublished" datetime="2022-03-09T16:14:26+08:00">2022-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-22 21:17:40" itemprop="dateModified" datetime="2022-03-22T21:17:40+08:00">2022-03-22</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/09/16-14-26/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/09/16-14-26/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="logic-design">Logic Design</h1>
<h3 id="数制">数制</h3>
<p>数制是用一组固定符号和统一规则来表示数值的方法，通常包含基数和位权两个基本要素。其中<strong>基数</strong>是指使用数码的个数，例如：二进制的基数为<code>2</code>，十进制的基数为<code>10</code>。<strong>位权</strong>是指数制某位所表示的数值权重的大小，例如：十进制数<code>123</code>，<code>1</code>的位权是<code>100</code>，<code>2</code>的位权是<code>10</code>，<code>3</code>的位权是<code>1</code>。二进制数<code>1011</code>，从左至右<code>1</code>、<code>0</code>、<code>1</code>、<code>1</code>的位权依次是<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>。常用的数制有<strong>二</strong>、<strong>八</strong>、<strong>十</strong>、<strong>十六</strong>四种进制，书写时可以在相应数值尾部添加字母<strong>B</strong>、<strong>O</strong>、<strong>D</strong>、<strong>H</strong>或者下标<strong>2</strong>、<strong>8</strong>、<strong>10</strong>、<strong>16</strong>进行标识，计算机<strong>传输和保存数据</strong>通常使用的是<strong>二进制</strong>。</p>
<h3 id="码制">码制</h3>
<p>码制是计算机存储、传输数据所使用的编码规则；其中原码、反码、补码是计算机设备保存数值类型数据的编码方式，ASCII 与 Unicode 属于保存字符类型数据的编码格式；而 BCD 编码、格雷码则主要用于设备之间的数据<strong>传输以及转换</strong>。</p>
<blockquote>
<p>BCD 码的优点在于格式转换容易，十进制数值表达精度较高；缺点是增加了电路进行算术运算的复杂度，并且存储效率较低。</p>
</blockquote>
<h3 id="数字系统">数字系统</h3>
<p>数字系统设计大致分为三个方面</p>
<ul>
<li>系统设计
<ul>
<li>系统设计是将一个数字系统划分为多个子系统进行设计。</li>
</ul></li>
<li>逻辑设计
<ul>
<li>逻辑设计是将多个逻辑功能块互联实现特定功能</li>
</ul></li>
<li>电路设计</li>
</ul>
<p>数字系统的中许多子系统以开关电路的形式存在，开关电路具有一个或多个输入端，一个或多个输出端，输入输出端都取离散值的电路。开关电路一般使用门电路来描述，使用布尔代数进行分析。开关电路有两种——组合电路和时序电路。</p>
<p>开关电路分类：</p>
<ul>
<li>组合电路
<ul>
<li>组合电路中输出值仅与当前输入值有关</li>
<li>组合电路的基本构成是逻辑门，逻辑设计就是将逻辑门相互连接起来以便将电路的输入信号转化为预期的输出信号。</li>
</ul></li>
<li>时序电路
<ul>
<li>时序电路中输出值不仅与当前输入值有关，也与之前的输入值有关；可以认为时序电路具有记忆功能</li>
<li>时序电路的基本存储元件（存储之前的值）是触发器，触发器与逻辑门一起组成时序电路——如计数器和寄存器。</li>
</ul></li>
</ul>
<h3 id="布尔代数">布尔代数</h3>
<p>逻辑设计课程中我们使用二值布尔代数来设计开关电路。我们使用布尔变量来表示电路的输入和输出，其中布尔变量代表逻辑电路中的两种不同状态——</p>
<p>普通代数中的<strong>交换律</strong>和<strong>结合律</strong>同样可以在布尔代数中使用。</p>
<p>布尔代数中的交换律表明开关的位置（出现次序）不会影响最终结果，结合律表明开关导通的次序不会影响最终结果。</p>
<p>在布尔代数中，分配律有两种形式：</p>
<ul>
<li><p>一种是普通的分配律：<span class="math inline">\(X(Y+Z)=XY+XZ\)</span></p>
<p>​ 与运算可以分配在或运算上</p>
<p>​ 去和括号内相乘</p></li>
<li><p>另一种被称作第二分配律：<span class="math inline">\(X+(YZ)=(X+Y)(X+Z)\)</span></p>
<p>​ 或运算可以分配在与运算上</p>
<p>​ 去和括号内相加</p></li>
</ul>
<p>很多布尔代数表达式可以使用一个更简单的表达式替换，每个布尔代数表达式</p>
<h2 id="数字电路概念">数字电路概念</h2>
<h3 id="高阻态">高阻态</h3>
<p>高阻抗状态（<em>High impedance</em>）表示电路中的某个节点具有相对电路中其它点更高的阻抗，电路分析时通常将高阻态作为开路理解。即可以将其视为输出/输入电阻极大，极限状态可以认为是悬空（<em>断路</em>）的状态，高阻态通常使用字母<strong>Z</strong>表示。</p>
<h3 id="三态门">三态门</h3>
<p>数字电路中的三态逻辑（<em>Three-state logic</em>）是指其输出既可以是代表<code>0</code>和<code>1</code>的高低电平，也可以是其特有的高阻抗状态（<em>相当于隔断状态，电阻极大，类似于开路</em>）。</p>
<p>具有高电平、低电平、高阻态三种状态的元器件称为三态器件，三态器件都通过一个控制使能端 B 来控制整个三态门电路的通断。当使能端高电平有效时，三态器件可以正常的<code>0</code>或<code>1</code>输出，当使能端低电平无效时，三态电路将会输出高阻态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">输入端 A</th>
<th style="text-align: left;">使能端 B</th>
<th style="text-align: left;">输出端 C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>X</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>Z</code></td>
</tr>
</tbody>
</table>
<h3 id="组合时序逻辑电路">组合/时序逻辑电路</h3>
<ul>
<li><strong>组合逻辑电路</strong>（<em>Combinational Logic Circuit</em>），其任一时刻的稳态输出仅与该时刻输入的变量取值有关，而与该时刻之前输入的变量取值无关。组合电路主要由各种逻辑门（<code>半加器</code>、<code>全加器</code>、<code>半减器</code>、<code>全减器</code>、<code>数据选择器</code>、<code>数据分配器</code>、<code>编码器</code>、<code>译码器</code>）组成，电路中没有记忆元件和反馈线。</li>
<li><strong>时序逻辑电路</strong>（<em>Sequential Logic Circuit</em>）任意时刻的稳态输出不仅取决于当前输入，还与前一时刻输入的状态有关，换而言之，时序逻辑电路必须拥有特定的储存元件来保存前一次的输入状态。因此，时序逻辑电路除包含有组合逻辑电路以外，还必须含拥有存储信息能力的电路（<code>触发器</code>、<code>寄存器</code>、<code>计数器</code>）。</li>
</ul>
<h3 id="gpio">GPIO</h3>
<p><strong>通用输入输出</strong>（<em>General-purpose input/output</em>），功能类似于 8051 单片机的 P0 到 P3 口，引脚输出的高低电平可由开发人员读写相应寄存器进行控制。该接口有时也称为<strong>总线扩展器</strong>，当开发板接口不够用时，可以通过转接板将其扩展为<code>I²C</code>、<code>SPI</code>等其它串行接口。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/05/16-32-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/05/16-32-26/" class="post-title-link" itemprop="url">微机原理与接口技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-05 16:32:26" itemprop="dateCreated datePublished" datetime="2022-03-05T16:32:26+08:00">2022-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-23 11:38:16" itemprop="dateModified" datetime="2022-03-23T11:38:16+08:00">2022-03-23</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/05/16-32-26/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/05/16-32-26/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微机原理与接口技术">微机原理与接口技术</h1>
<h2 id="基本概念">基本概念</h2>
<p>微型计算机简称微机，是微机原理这门课程的主要研究范围。</p>
<p>首先我们先对微型计算机有一个初步的认识。</p>
<h4 id="电脑微型计算机系统">电脑——微型计算机系统</h4>
<p>电脑是我们熟悉的事物，我们家用的台式电脑和笔记本电脑都是属于<strong>个人电脑（Personal Computer）</strong>，简称为PC。个人电脑PC是一个<strong>通用微型计算机系统（）</strong>。其中，“通用”暗示了“专用”计算机系统的存在，而“微型”暗示了“大型”计算机系统的存在。其中还有值得注意的是计算机系统中的“系统”二字，因为这暗示了在计算机之上还存在一个更加宏观的概念。</p>
<p>计算机根据规格和能力区分的话可以粗略分作超级计算机，大型计算机，小型计算机和微型计算机。其中超算和微机可能是我们日常生活中常常能听到的词语，前者出现在新闻里面，比如天河二号；后者出现在我们们的日常生活中，也就是我们的电脑（主机）。</p>
<p>经典的电脑硬件配置包括鼠标，键盘，显示器和电脑主机，虽然笔记本发展后大多数笔记本都配备有触控板作为鼠标的代替，但是鼠标依旧是更受欢迎的计算机<strong>外设（Peripherals）</strong>。除了鼠标，键盘和显示器也是最经典的外设，但是对于完全不了解电脑构造却经常使用电脑的人来说，或许会认为显示器是计算机，尤其是一体机的存在使得这个错误更容易犯下。但是，计算机，顾名思义是计算的机器，它的功能并不会包括“显示”。根据输入，计算机会得到输出，但是这个输出不是我们可以直接看到的“显示”，“显示”的功能来自一个密布发光单元的显示器，显示器可以将计算机的输出变成屏幕上的文字或者图片为我们“显示”出来。</p>
<p>外设不是计算机，真正的计算机是我们通常称为“电脑主机”的的部分，在台式机中，它是显示器旁边的长方体的箱子；在笔记本中，它一般在你的键盘的下面。</p>
<p>计算机（个人计算机）和外设，配合上电源，便组成了微型计算机系统的硬件部分。完整的微型计算机系统不仅包括硬件，还包括软件。后者不是我们在微机原理课程中重点的关注的内容，但是理解软件部分是微型计算机系统不可缺少的部分却很重要。</p>
<p>微型计算机系统的软件部分包括<strong>系统软件</strong>和<strong>应用软件</strong>，系统软件中我们最熟悉的就是操作系统，如Windows和MacOS；而像Office或者浏览器等软件则是应用程序即应用软件。</p>
<p>==总结：家用电脑整体称作<strong>微型计算机系统（）</strong>，这个系统分为硬件和软件两大部分，其中软件部分包括系统软件和应用软件；硬件部分包括电源、外设和最重要的微型计算机（电脑主机）。接下来我们重点介绍微型计算机的内部结构。==</p>
<h4 id="微型计算机">微型计算机</h4>
<p><strong>微型计算机（）</strong>内部结构可概括为四部分：</p>
<ul>
<li>CPU（这个肯定耳熟了，稍后会进一步介绍）</li>
<li>存储器（比较复杂，稍后重点介绍）</li>
<li>总线（bus）：总线就是连接计算机内部部件的导线</li>
<li>输入输出接口电路：与外设连接的导线</li>
</ul>
<p>相信即便是最不了解电脑的小白也听说过CPU的大名。CPU中的字母C表示Center，是中心的意思，表明CPU是计算机的中心。计算机中的一切一切都是围绕着CPU转圈的。这样重要且复杂的部件，我们肯定要单独拿出来讲：下一节微处理器，就是对CPU的详细介绍。</p>
<p>计算机的本质是计算，无论是使用计算机显示文本或是图形，播放音乐或是视频，计算机本身都只是在快速做着最简单的运算。我们从很小的时候便学习开始做运算了，我们知道，做运算首先我们需要纸笔记录下数字，然后可能还需要将结果记录在另一张纸上（比如你的试卷）。计算机中也存在大量的数字，我们称作数据（data），它们存在计算机的存储器中。除数据外，计算中我们需要知道算数的方法，比如老师对我们说，将两个数字相乘，我们就做乘法。计算机也存在类似的东西，称作指令（code）。众所周知，计算机使用二进制，也就是计算机中不存在文字，甚至不存在数字2，我们在计算机中只有0和1。因此计算机中指令和数据都是由0和1进行表示的。在计算机经典结构——冯·诺伊曼结构中，指令和数字不加区分的放在存储器中；而在另一种改进过的计算机结构——哈佛结构中，指令放在指令存储器中而数据放在数据存储器中。这种分开存放的优势在于可以使数据和指令的存取同时进行，我们将在后面进一步看到这样做的重要意义。</p>
<p>目前我们已经知道了，存储器存储着数据和指令。处理数据是计算机无时无刻都在做的事情，而指令则告诉计算机该怎样处理数据。那么接下来的问题是：我们需要一个什么样的存储器呢？</p>
<p>简单来说，我们需要一个好的存储器。一般来说，我们关注存储器的如下3个特点</p>
<ol type="1">
<li>存储器是一个存储结构，既要存，还要取
<ul>
<li>存——要求能存住，机器断电（掉电）后能不能一直保存</li>
<li>取——主要看速度，取出来自然是越快越好</li>
</ul></li>
<li>最后就是作为商品，我们还是要考虑成本的，成本太高买不起就不行了。</li>
</ol>
<p>综上，我们需要一个价格便宜，能掉电存储且读取速度快的存储器。</p>
<p>可惜的是，现实中没有那么完美的存储器（至少目前），虽然根据不同的原理人们制作出的低成本且掉电存储的快闪存储器Flash（就是很多人U盘用的那个），但是它传输速度慢；另一方面人们制作出了静态随机存储器SRAM，虽然便宜还传输快，但是掉电不保存。虽然除了上述两种还有一些类型的存储器，但是也都有其缺点。为了协调速度、容量和成本三个方面，人们设计出了三级存储结构：<strong>高速缓存存储器</strong>、<strong>内存储器（主存）</strong>和<strong>外存储器（辅存）</strong>。</p>
<p>高速缓存存储器存在于主存与CPU之间的一级存储器，容量小但是速度很快，接近于CPU的速度。</p>
<p>内存储器是CPU读取数据和指令的地方，如果数据在外存储器中，CPU将先把数据从外存储器移至内存储器中然后再处理数据。</p>
<p>外存储器就是我们平时说的电脑的固态硬盘，手里拿的U盘和已经淘汰了的光盘。</p>
<p>三级存储结构帮助我们再速度、容量和成本三个方面达到一个平衡。但是未来如果有更好的存储手段，能同时满足上述三点，或许我们就将创造全新的存储器结构，主存和辅存也将会像光盘一样被淘汰掉。</p>
<hr>
<p>微型计算机的分类——按微型计算机的结构形式分类。</p>
<ul>
<li>单片机</li>
<li>单板机</li>
<li>多板机</li>
</ul>
<p>对于数码爱好者，尤其是那些对于台式机组装机器充满兴趣的人都不会对多板机这个概念感到困惑。在台式机中存在一个叫主板或是叫母板的东西。典型的主板能提供一系列接合点，供我们非常熟悉名字的例如处理器、显卡、硬盘驱动器、存储器、对外设备等设备的接合。</p>
<p>多板机是在一块主板上提供了多个扩展插槽，并使用总线将各个部分进行连接，最终将一切封装在一个机箱里面。在组装的开始，我们有一堆板子，在组装完成后，我们有一台电脑。</p>
<p>单板机的思路与多板机不同，单板机将一台电脑用到的所用功能集成在一块电路板上，在购买单板机时我们直接买到的就是一台电脑，而不需要再进行组装。当然，鉴于单板机性能弱一般用于实验室和简单的控制场所，所以单板机所在的电路板可能会进一步连接在其他的电路板上。但是，无论外部还会连接什么，重点是，在一小块电路板上我们有了一台基础功能完备的电脑。这里值得一提的是，对于电子设计爱好者，很可能听说过Arduino和树莓派的大名，这里要说明，Arduino和树莓派都属于单板机。</p>
<p>单片机也被称作微控制器，这个名字基本对单片机定了性质。单片机通常是用来做控制的，常常用于工业，在实验室也经常见到它的身影。单片机将CPU和存储器……其实就是上面提到的微型计算机中该有的那些东西，集成在了一个芯片上面。通常来讲，你对商店老板说来来些单片机，那你将收到的是一些黑色塑料外壳包着的下方有许多金属引脚的小东西。与Arduino和树莓派，一个芯片既不能直接连接一个LED控制它的亮灭，也不能直接烧录程序。单片机正常执行控制需要建立一个最小工作系统，然后才能进行控制。如果想了解更具体些，<a href>这里</a>会有你想知道的。</p>
<p>==总结一下：微型计算机由CPU和存储器组成，内部有总线连接，向外有输入输出电路进行扩展。计算机的本职工作是做计算，计算需要指令和数据，根据指令数据的存储方式的不同可以将微型计算机分为冯·诺伊曼结构和哈佛结构。计算机可以分为单片机、单板机和多板机。将计算机放在一个芯片上是单片机，放在一个电路板上是单板机，多个板子各司其职组装在一起形成电脑叫多板机。==</p>
<h4 id="微处理器">微处理器</h4>
<p>微处理器（microprocessor）也称中央处理单元（central processing unit），是微型计算机的核心部件。</p>
<p>前面我们已将提过，计算机的本职工作是做计算。计算需要两方面内容——数据和指令。前者就相当于给你数字2和3，后者就相当于告诉你对2和3做乘法。对于CPU来说不止但肯定有下述三个功能：</p>
<ul>
<li>进行基本的算数和逻辑运算（如果想要知道电路是如何做运算的，<a href>这里</a>会找到答案的）</li>
<li>暂存少量数据（这是好理解的，毕竟我们计算式也要先把数字写在草稿纸上）</li>
<li>执行指令（值得注意的是指令是需要译码的）</li>
</ul>
<h3 id="嵌入式系统">嵌入式系统</h3>
<p>上文我们以通用计算机系统为例，沿着“微型计算机系统-&gt;微型计算机-&gt;微（型）处理器”三个层次描述了微机的基本概念。最后我们注意微机的另一大类，即平行于通用计算机系统的，名为嵌入式系统的专用计算机系统。</p>
<p>嵌入式系统也是微型计算机系统，上面描述的通用计算机系统包含的内容，在嵌入式系统中也同样有所体现。但是嵌入式系统的关键词在于“专用”。专用意味着嵌入式系统为某一具体的应用问题而生，不需要具备通用计算机系统的全部内容。例如，嵌入式系统中可能不会连接鼠标键盘等外设，而且不会具备完整的系统软件。</p>
<h2 id="arm微处理器">ARM微处理器</h2>
<p>ARM微处理器最重要的特性是其英文名称</p>
<h4 id="arm-微处理器的工作状态">ARM 微处理器的工作状态</h4>
<ul>
<li>ARM 状态：处理器执行32位的 ARM 指令集，即执行字方式的 ARM 指令</li>
<li>Thumb 状态：处理器执行16位的 Thumb 指令集，即执行半字方式的 ARM 指令</li>
</ul>
<p>ARM 微处理器在两种工作模式下都有切换处理器工作状态的指令，但是在 ARM 处理器开始执行代码时处理器应处于 ARM 状态。</p>
<h4 id="arm-微处理器的工作模式">ARM 微处理器的工作模式</h4>
<ul>
<li>用户模式</li>
<li>特权模式
<ul>
<li>系统模式</li>
<li>异常模式
<ul>
<li>管理模式</li>
<li>快速中断模式</li>
<li>外部中断模式</li>
<li>数据访问中止模式</li>
<li>未定义指令中止模式</li>
</ul></li>
</ul></li>
</ul>
<p>工作模式可以通过软件改变，也可以通过外部中断和处理器异常来改变。并且每一种模式下可以使用的寄存器是不同的。</p>
<h4 id="arm-处理器支持的数据类型和存储格式">ARM 处理器支持的数据类型和存储格式</h4>
<h5 id="数据类型">数据类型</h5>
<p>在处理器中数据类型是这样分类的，分成下面三种类型：</p>
<ul>
<li>字节类型</li>
<li>半字类型</li>
<li>字类型</li>
</ul>
<p>数据操作都是以字为单位的（这里课本写：ARM 指令是一个字长而 Thumb 指令是半字长；但不是说操作都是以字为单位并且都是一样长吗？？？），而从存储器读写的数据则可以按上述三种不同的数据类型进行读写。</p>
<p>对存储器按字或者半字类型进行读取时，需要进行对齐操作；对数据进行字节传输时不需要对齐。</p>
<blockquote>
<p>一条指令（指的是机器码）由操作码（opcode）和操作数（operand）构成。操作数可以是1个，也可以是多个，甚至可以没有。操作码则是每一条指令都必须有。操作码表示该指令要做什么动作，例如跳转，加减等等。操作数则表示操作对象，操作数可能还会分为目的操作数和源操作数。操作数当然是一个数字，该操作数可以由多种来源，例如寄存器，存储器或者立即数。本节介绍的处理器的寻址方式就是讨论指令中操作数的来源问题。</p>
</blockquote>
<h5 id="存储格式">存储格式</h5>
<blockquote>
<p>指令编码中，用来说明操作数来源和操作数构成存储器地址的方法，叫做寻址方式，英文为Addressing Mode。寻址方式是由处理器的指令编码直接决定的，是处理器体系架构的一部分，所以我们一般叫做xxx处理器寻址方式，例如8086寻址方式，MIPS寻址方式。寻址方式是学习任何一种汇编语言的起点。</p>
</blockquote>
<p>ARM 存储器的最大寻址空间为4 GB。</p>
<p>存储器可以看作是一个从零开始线性递增的一个容器，容器的基本单位为字节。</p>
<p>数据以字为单位存储在存储器中，这意味着一个（字）数据将存放在存储器的四个基本单位中。</p>
<p>数据在存储器中的存储方式有两种，区分两种存储方式的关键在于一个字的四个字节在存储器中哪一个存在高位哪一个存在低位：</p>
<ul>
<li>大端格式：数据的高字节位存储在存储器的低地址中</li>
<li>小端格式：数据的低字节位存储在存储器的低地址中</li>
</ul>
<p>大小端的存储方式可以通过外部引脚和内部寄存器的配置来进行选择，选择要在使用前进行配置，开始使用后只能选择一种存储器数据存储方式。</p>
<h4 id="arm-处理器的寄存器">ARM 处理器的寄存器</h4>
<p>ARM 寄存器：</p>
<ul>
<li>定义：寄存器是 CPU 内部用来暂时存放参与运算的数据和运算结果的小型存储区域</li>
<li>特征：传输数据的速度非常快</li>
<li>分类：
<ul>
<li>通用寄存器：保存数据和地址</li>
<li>状态寄存器：标识 CPU 的工作状态及程序的运行状态</li>
</ul></li>
<li>经典 ARM 寄存器在物理上共有37个32位寄存器组成
<ul>
<li>31个通用寄存器</li>
<li>6个状态寄存器</li>
</ul></li>
</ul>
<h4 id="arm-处理器的io组织">ARM 处理器的I/O组织</h4>
<p>I/O 是 CPU 与外部设备之间通信的桥梁</p>
<p>对 I/O 端口物理地址进行编址的方式有两种：</p>
<ul>
<li><p>独立编址方式：I/O映射方式，x86采用</p>
<p>I/O 端口地址与内存单元地址分开独立编址，I/O 端口地址不占用内存空间的地址范围，需要专门的I/O 指令和控制逻辑</p></li>
<li><p>统一编址方式：内存映射方式，ARM采用</p>
<p>I/O 端口地址与内存单元地址混在一起：将内存的一部分划分出来作为I/O 地址空间。</p></li>
</ul>
<h2 id="cortex-m4-微处理器">Cortex-M4 微处理器</h2>
<h4 id="cortex-m4-微处理器的工作状态">Cortex-M4 微处理器的工作状态</h4>
<h4 id="cortex-m4-微处理器的工作模式">Cortex-M4 微处理器的工作模式</h4>
<h4 id="cortex-m4-微处理器的寄存器组织">Cortex-M4 微处理器的寄存器组织</h4>
<ul>
<li>存在于：寄存器存在于处理器的内核之中</li>
<li>作用：执行数据处理和控制</li>
<li>分类：16个32位寄存器
<ul>
<li>通用寄存器组</li>
<li>特殊功能寄存器</li>
</ul></li>
<li>与经典的 ARM 微处理器对比：Cortex-M4 微处理器的寄存器较少</li>
<li>通用寄存器详解：
<ol type="1">
<li><span class="math inline">\(R0-R7\)</span>：
<ul>
<li>统称：低组寄存器</li>
<li>访问指令：32位指令和大多数16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R8-R12\)</span>：
<ul>
<li>统称：高组寄存器</li>
<li>访问指令：32位指令和少量16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R13\)</span>：
<ul>
<li>统称：堆栈指针寄存器</li>
<li>系统可以同时支持两个堆栈，</li>
</ul></li>
</ol></li>
</ul>
<h4 id="cortex-m4-微处理器的存储组织">Cortex-M4 微处理器的存储组织</h4>
<h1 id="摘抄">摘抄：</h1>
<p>RISC使用的是load-store结构。load-store结构的本质，在于RISC技术的CPU只处理（指逻辑，算术运算处理）寄存器中的数据。相反，X86却能够直接处理存储器中的数据。</p>
<p><a target="_blank" rel="noopener" href="https://nieyong.github.io/wiki_cpu/index.html">index (nieyong.github.io)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/02/27/16-42-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/27/16-42-18/" class="post-title-link" itemprop="url">信号与系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-27 16:42:18" itemprop="dateCreated datePublished" datetime="2022-02-27T16:42:18+08:00">2022-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-27 00:16:39" itemprop="dateModified" datetime="2022-03-27T00:16:39+08:00">2022-03-27</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/02/27/16-42-18/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/02/27/16-42-18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="x信号">x信号</h2>
<h3 id="常见的奇异信号">常见的奇异信号</h3>
<p>奇异信号：函数中包含不连续点或其微分与积分有不连续点的函数，统称为奇异函数，也就是奇异信号。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>函数表达式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f(t)\)</span>：单位斜变信号</td>
<td><span class="math inline">\(f(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ t &amp; t\ge0 \\ \end{cases}\)</span></td>
</tr>
<tr class="even">
<td>$ u(t)$：单位阶跃信号</td>
<td><span class="math inline">\(u(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ 1 &amp; t&gt;0 \\ \end{cases}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</td>
<td><span class="math inline">\(\begin{cases} \begin{aligned} &amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\ &amp;\delta(t) = 0\quad while(t\not=0) \end{aligned} \end{cases}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</td>
<td><span class="math inline">\(\delta(t)&#39;=\frac{d\delta(t)}{dt}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="ft单位斜变信号"><span class="math inline">\(f(t)\)</span>：单位斜变信号</h4>
<p>单位斜变信号的“单位”体现在其非零部分的斜率为 <span class="math inline">\(1\)</span> 。</p>
<p>函数表达式： <span class="math display">\[
f(t) = 
\begin{cases}
0 &amp;     t&lt;0     \\\\
t &amp;     t\ge0   \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后： <span class="math display">\[
f(t-t_0) = 
\begin{cases}
0       &amp;       t&lt;t_0           \\\\
t-t_0   &amp;       t\ge t_0        \\
\end{cases}
\]</span></p>
<h4 id="ut单位阶跃信号">$ u(t)$：单位阶跃信号</h4>
<p>函数表达式：</p>
<p>由表达式可知 <span class="math inline">\(t=0\)</span> 处函数未定义，可以将 <span class="math inline">\(t=0\)</span> 处函数值定义为 <span class="math inline">\(u(0)=\frac{1}{2}\)</span>。 <span class="math display">\[
u(t) = 
\begin{cases}
0   &amp;       t&lt;0     \\\\
1   &amp;       t&gt;0     \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后（或认为阶跃延时 <span class="math inline">\(t\)</span> 后），有： <span class="math display">\[
u(t-t_0) = 
\begin{cases}
0   &amp;       t&lt;t_0       \\\\
1   &amp;       t&gt;t_0       \\
\end{cases}
\]</span></p>
<h4 id="deltat单位冲激函数"><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</h4>
<p>狄拉克（Dirac）定义方式： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\
&amp;\delta(t) = 0\quad while(t\not=0)
\end{aligned}
\end{cases}
\]</span> 狄拉克（Dirac）定义表明：</p>
<ol type="1">
<li>除了坐标轴零点处，其余位置单位冲激函数的函数值均为 <span class="math inline">\(0\)</span> 。</li>
<li>单位冲激函数仅在一点处取值，而其面积（积分）为 <span class="math inline">\(1\)</span> ，由此可知单位冲激函数为长度为 <span class="math inline">\(1\)</span> 的线段：表示中我们使用长度为 <span class="math inline">\(1\)</span> 的向量来表示，方向与 <span class="math inline">\(y\)</span> 轴正半轴方向相同。</li>
</ol>
<h4 id="deltat冲激偶函数"><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</h4>
<p>由符号可知冲激偶函数为冲激函数的导数。</p>
<h4 id="常见奇异信号之间的关系">常见奇异信号之间的关系：</h4>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{df(t)}{dt}=u(t)\\\\
&amp;\frac{du(t)}{dt}=\delta(t)\\\\
&amp;\delta(t)&#39;=\frac{d\delta(t)}{dt}
\end{aligned}
\end{cases}
\]</span></p>
<h4 id="单位冲激函数-deltat-的简单性质">单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 的简单性质：</h4>
<ol type="1">
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 具有<strong>抽样特性</strong>（也称“筛选”特性），<span class="math inline">\(\delta(t)\)</span> 可以用来筛选出信号中某一时刻的值（函数值），具体操作如下： <span class="math display">\[
\int_{-\infty}^{\infty}\delta(t-t_0)f(t)dt=f(t_0)
\]</span> 解释：对于任意一个信号 <span class="math inline">\(f(t)\)</span> ，我们使用 <span class="math inline">\(\delta(t)\)</span> 可以筛选出目标的函数值 <span class="math inline">\(f(t_0)\)</span> 。</p></li>
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 是一个偶函数，即 <span class="math inline">\(\delta(t)=\delta(-t)\)</span></p></li>
</ol>
<h3 id="线性时不变系统lti">线性时不变系统——LTI</h3>
<ol type="1">
<li><p>理解线性：</p>
<ol type="1">
<li>满足叠加性和均匀性</li>
</ol></li>
<li><p>理解时不变特性：即系统本身的参数不随时间发生改变</p></li>
<li><p>线性时不变系统还具有的特性：</p>
<ol type="1">
<li><p>微分特性：微分特性由线性和时不变性共同得出，内容为：</p>
<p>若激励信号 <span class="math inline">\(e(t)\)</span> 可使系统产生响应信号 <span class="math inline">\(r(t)\)</span>，则</p>
<ul>
<li>激励 <span class="math inline">\(\frac{de(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{dr(t)}{dt}\)</span></li>
<li>激励 <span class="math inline">\(\frac{d^2e(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{d^2r(t)}{dt}\)</span>，其余高阶求导同理</li>
<li>激励 <span class="math inline">\(\int^t_0e(\tau)d\tau\)</span> 可产生响应 <span class="math inline">\(\int^t_0r(\tau)d\tau\)</span></li>
</ul></li>
<li><p>因果特性：因果特性描述了激励信号与响应信号之间的联系，因果特性表明：<span class="math inline">\(t_0\)</span> 时刻的响应只与<span class="math inline">\(t=t_0\)</span> 和 <span class="math inline">\(t&lt;t_0\)</span> 时刻的输入有关，即激励和响应有着因果关系，只有有激励才会有响应。</p></li>
</ol></li>
</ol>
<h3 id="分析lti">分析LTI</h3>
<p>系统建模就是使用数学工具例如方程或者微分方程来建立模型。</p>
<ol type="1">
<li>系统的数学描述方法可以分为两大类：</li>
</ol>
<ul>
<li>输入输出描述法——该方法注重系统激励和响应之间的关系，不关心系统内部变量情况
<ul>
<li>这种方法在数学上表现为一元<span class="math inline">\(n\)</span>阶微分方程</li>
</ul></li>
<li>状态变量描述法
<ul>
<li>可以给出系统响应</li>
<li>提供系统内部各变量的情况</li>
<li>可以用于多输入多输出系统的分析</li>
<li>这种方法在数学上表现为<span class="math inline">\(n\)</span>元联立一阶微分方程</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>使用数学方法描述了一个系统后，我们就需要一些求解方法来求解系统模型，求解方法大体上也可以分为两类：</li>
</ol>
<ul>
<li>时域分析——时域分析是指在时间域上分析系统；前文可知系统可以简单理解为一个以时间为自变量的函数或函数族，时间域分析就是直接分析这个以时间变量作为自变量的函数。
<ul>
<li>时域分析分析输入输出法描述的系统模型时：
<ul>
<li>可以使用经典的常系数微分方程和差分方程</li>
<li>也可以使用算子符号来简化上面的微分方程和差分方程</li>
<li>卷积是分析线性系统时域的重要数学工具</li>
</ul></li>
<li>时域分析分析状态变量法描述的系统模型时：
<ul>
<li>需要求解矩阵方程</li>
</ul></li>
</ul></li>
<li>变换域分析——变换域是指将时变函数中的自变量：时间变量变换成其他变量函数。变换域分析使得时域分析中复杂的微分积分运算变成了代数运算，将复杂的卷积运算变成了乘法运算</li>
</ul>
<h3 id="电系统的lti数学模型建立">电系统的LTI数学模型建立</h3>
<p>构成电系统的LTI模型表现为微分方程式</p>
<p>构成此类方程式的依据是电系统网络的两类约束特性：</p>
<ul>
<li>电元器件约束特性——电子元器件的伏安特性
<ul>
<li>欧姆定律：
<ul>
<li><span class="math inline">\(V_R(t)=Ri_R(t)\)</span></li>
<li><span class="math inline">\(V_L(t)=L\frac{di(t)}{dt}\)</span></li>
<li><span class="math inline">\(V_C(t)=\frac{1}{C}\int_{-\infty}^ti_C{(\tau)}d\tau\)</span></li>
</ul></li>
</ul></li>
<li>网络拓扑结构——网络结构决定的电流电压关系
<ul>
<li>基尔霍夫定律：
<ul>
<li><span class="math inline">\(\sum i(t)=0\)</span></li>
<li><span class="math inline">\(\sum v(t)=0\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>线性时不变系统的时域分析，微分方程的一般形式： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 上式可以缩写为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 特殊形式，例如我们可以整理约束关系得到下式： <span class="math display">\[
\frac{d^3r(t)}{dt^3}+7\frac{d^2r(t)}{dt^2}+16\frac{dr(t)}{dt}+12r(t)=e(t)
\]</span> 微分方程的全解由齐次解 <span class="math inline">\(r_h(t)\)</span> 和特解 <span class="math inline">\(r_h(t)\)</span> )组成，即： <span class="math display">\[
r(t)=r_h(t)+r_h(t)
\]</span> 解法：</p>
<ol type="1">
<li>求齐次解 <span class="math inline">\(r_h(t)\)</span>：</li>
</ol>
<ul>
<li><p>令 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0\)</span>，该式称为齐次方程</p></li>
<li><p>将 <span class="math inline">\(r(t)=Ae^{\alpha t}\)</span> 代入齐次方程得 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\alpha^{i}=0\)</span>，称为特征方程</p></li>
<li><p>根据特征方程可以得齐次解 <span class="math inline">\(r_h(t)\)</span> 为</p>
<ul>
<li><p>特征方程没有重根：<img src="/2022/02/27/16-42-18/image-20220326234840139-16483097818622.png" alt="image-20220326234840139" style="zoom: 40%;"></p></li>
<li><p>特征方程有重根：<img src="/2022/02/27/16-42-18/image-20220326234918784-16483097790591.png" alt="image-20220326234918784" style="zoom: 40%;"></p></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>求特解 <span class="math inline">\(r_h(t)\)</span>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>激励函数 <span class="math inline">\(e(t)\)</span></th>
<th>响应函数 <span class="math inline">\(r(t)\)</span> 的特解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E\)</span></td>
<td><span class="math inline">\(B\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^p\)</span></td>
<td><span class="math inline">\(B_1t^p+B_2t^{p-1}+···+B_pt+B_{p+1}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(e^{\alpha t}\)</span></td>
<td><span class="math inline">\(Be^{\alpha t}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(cos(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(sin(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^pe^{\alpha t}cos(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(t^pe^{\alpha t}sin(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>求待定系数 <span class="math inline">\(A\)</span>：</p></li>
</ol>
<h3 id="拉普拉斯变换">拉普拉斯变换</h3>
<p>形态上，拉普拉斯变换做了这样一件事： <span class="math display">\[
f(t)\xrightarrow{\sf{拉普拉斯变换}}F(s)
\]</span> 或者说： <span class="math display">\[
f(t)\xrightarrow{\mathscr{L}\{f(t)\}}F(s)
\]</span> 从形态上讲，拉普拉斯变换将一个以时间 <span class="math inline">\(t\)</span> 为自变量的函数变换成了一个以频率 <span class="math inline">\(s\)</span> 为自变量的函数。</p>
<p>拉普拉斯变换将函数从时域变换到了频域，其实就是信号的自变量发生了变化。</p>
<p>意义：拉普拉斯变换可以将时域内的微分方程变换成频域内的代数方程，降低计算难度并且从频域再次回到时域时保证解不变。</p>
<p><span class="math inline">\(\mathscr{L}\{f(t)\}\)</span> 拉氏变换的定义为： <span class="math display">\[
\mathscr{L}\{f(t)\}=\int_{0}^{\infty}f(t)\cdot e^{-st}dt
\]</span> 注意事项：</p>
<ol type="1">
<li>进行拉氏变换的 <span class="math inline">\(f(t)\)</span> 是否存在的问题：
<ul>
<li>首先是初等函数都能进行拉氏变换</li>
<li>默认在线性电路分析中均使用能够进行拉氏变换的电源进行系统的激励</li>
</ul></li>
<li>上述拉氏变换也可以称作单边拉氏变换，此变换忽略了 <span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span></li>
<li><span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span> 可以通过初始条件来考虑</li>
</ol>
<p>分类：</p>
<p>学习拉普拉斯变换将拉普拉斯变换分为函数变换和算子变换</p>
<ul>
<li>函数变换：研究初等函数的拉氏变换</li>
<li>算子变换：研究一般函数的拉氏变换</li>
</ul>
<h4 id="算子变换">算子变换：</h4>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>拉氏变换</th>
<th><span class="math inline">\(\mathscr{L}\{f(t)\}=F(s)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乘以常数</td>
<td><span class="math inline">\(\mathscr{L}\{Kf(t)\}=KF(s)\)</span></td>
</tr>
<tr class="even">
<td>加减运算</td>
<td><span class="math inline">\(\mathscr{L}\{f(t_1)+f(t_2)-f(t_3)\}=F(s_1)+F(s_2)-F(s_3)\)</span></td>
</tr>
<tr class="odd">
<td>微分运算</td>
<td>一重微分：<span class="math inline">\(\mathscr{L}\{\frac{df(t)}{dt}\}=sF(s)-f(0^-)\)</span><br><span class="math inline">\(n\)</span> 重微分：<span class="math inline">\(\mathscr{L}\{\frac{d^nf(t)}{dt^n}\}=s^nF(s)-s^{n-1}f(0^-)-\sum_{i=2}^{n}s^{n-i}\frac{d^{i-1}f(0^-)}{dt^{i-1}}\)</span></td>
</tr>
<tr class="even">
<td>积分运算</td>
<td><span class="math inline">\(\mathscr{L}\{\int_{0^-}^{t}f(t)dt\}=F(s)/s\)</span></td>
</tr>
<tr class="odd">
<td>时域平移特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(t-a)\cdot u(t-a)\}=e^{-as}\cdot F(s),\quad a&gt;0\)</span><br><span class="math inline">\(\mathscr{L}\{e^{-as}\cdot F(s)\}=F(s+a)\)</span></td>
</tr>
<tr class="even">
<td>尺度变换特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(at)\}=\frac{1}{a}F\left(\frac{s}{a}\right),\quad a&gt;0\)</span></td>
</tr>
</tbody>
</table>
<h3 id="傅里叶分析简介">傅里叶分析简介</h3>
<p>傅里叶定理表明，任何一个角频率为<span class="math inline">\(\omega_0\)</span>的周期函数都可以表示为无穷多个频率为<span class="math inline">\(\omega_0\)</span>整数倍的正弦函数与余弦函数之和。</p>
<p>对于一个周期函数<span class="math inline">\(f(t)\)</span>，若满足Dirichlet条件，则该周期函数可以展开成傅里叶级数，即： <span class="math display">\[
\begin{aligned}
    &amp;if\quad f(t)=f(t+T)\\\\
    &amp;then\quad f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) +  \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
        &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
    &amp;if \quad f(t)=f(-t)\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\;\,\\\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
        &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=0 \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p>展开式中<span class="math inline">\(a_0\)</span>称为直流分量，其值等于函数<span class="math inline">\(f(t)\)</span>的平均值；<span class="math inline">\(a_n\)</span>与<span class="math inline">\(b_n(n\not=0)\)</span>是交流分量的幅值 <span class="math display">\[
f(t)=f(t+T)\Rightarrow
f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) + \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
\]</span></p>
<p><span class="math display">\[
\begin{array}{c|c|c}
    \begin{aligned}
    &amp;general\quad condition\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
            &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
            &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) sin(n\omega_0t) \,dt \\
        \end{aligned}
    }
    \end{aligned}
    &amp;
    \begin{aligned}
        &amp;if \quad f(t)=f(-t)\\
        &amp;\boxed
        {
            \begin{aligned}
                &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
                &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
                &amp;b_n=0 \\
            \end{aligned}
}
    \end{aligned}
    &amp; 
    \begin{aligned}
    &amp;if \quad f(t)=-f(-t)\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=0\\
            &amp;a_n=0\\
            &amp;b_n=\frac{4}{T}\int^{T/2}_{0} f(t) sin(n\omega_0t) \,dt  \\
        \end{aligned}
}
    \end{aligned}\\
\end{array}\\
\]</span></p>
<p><span class="math display">\[
P_{1\Omega}=F_{rms}^2=a_0^2+\frac{1}{2}\displaystyle\sum_{n=1}^{\infty}(a_n^2+b_n^2)
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/02/27/16-42-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/27/16-42-00/" class="post-title-link" itemprop="url">电路基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-27 16:42:00" itemprop="dateCreated datePublished" datetime="2022-02-27T16:42:00+08:00">2022-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-03 15:36:44" itemprop="dateModified" datetime="2022-03-03T15:36:44+08:00">2022-03-03</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/02/27/16-42-00/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/02/27/16-42-00/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/02/27/16-41-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/27/16-41-33/" class="post-title-link" itemprop="url">电子学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-27 16:41:33" itemprop="dateCreated datePublished" datetime="2022-02-27T16:41:33+08:00">2022-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-01 16:30:50" itemprop="dateModified" datetime="2022-04-01T16:30:50+08:00">2022-04-01</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/02/27/16-41-33/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/02/27/16-41-33/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="电子学">电子学</h1>
<h3 id="前言">前言</h3>
<p>本书主要参考尼曼（Donald A. Neamen）的《电子电路分析与设计（第四版）》（Microelectronics: Circuit Analysis And Design Forth Edition）写成。</p>
<h2 id="半导体器件及其基本应用">半导体器件及其基本应用</h2>
<h3 id="半导体">半导体</h3>
<p>在电路课和物理课上我们已经学习了一些电子器件，例如最典型的器件——电阻器。电阻器是导体，其最重要的性质“电阻”表示了导体对于电流的阻碍性质。除此之外我们还学习了电容和电感；电感的性质存在于线圈之中，线圈是使用导体制成的；电容则是导体极板中间夹着一个绝缘体介质形成。如此归纳，我们会发现在之前的课程之中，我们了解的范畴始终存在于导体和绝缘体之中，而半导体材料制作而成的器件却从未被提及。所以，在“半导体”这一节中，我们将注意力集中在半导体上，从研究半导体自身的性质开始，最终我们将得到一个简单的半导体器件。</p>
<p>正式开始本节前，我们简单地回顾一下中学的知识，以下这些是作者默认读者已经了解了的知识。</p>
<ul>
<li>导体中存在大量可以自由移动的电子，称之为自由电子（free electron）。自由电子在受到外电场或外磁场的作用时，能够在物质中自由移动。</li>
<li>导体中自由电子的定向移动形成了电流，电流（current）的定义式为 <span class="math inline">\(i=\frac{dq}{dt}\)</span>。</li>
<li>载流子（charge carrier）指可以自由移动的带有电荷的物质微粒，是物质中电流形成的原因，导体中的载流子是电子。</li>
<li>在半导体中存在两种载流子——电子（electron）和空穴（hole）。空穴是电子移动后留下的空位，从物理模型上可以将空穴看作是正电子。在半导体中，电子和空穴两种载流子共同形成半导体中的电流。</li>
</ul>
<h4 id="本征半导体intrinsic-semiconductor">本征半导体（intrinsic semiconductor）</h4>
<blockquote>
<p>本征半导体是指纯净（pure）的半导体</p>
</blockquote>
<p>本征半导体的概念是我们应当格外注意的，因为这不是一个偏日常化和口语化的词语，但是在这里它的含义却是十分简单——本征，不过就是纯净不含杂质的意思。</p>
<p>强调材料的纯度似乎是一件奇怪的事情，因为常识中我们通常认为提纯是必须的，无需额外强调的。例如我们不会强调一个钢筋的纯度，但是我们知道</p>
<p>本征半导体是指纯净的半导体，强调这个词似乎暗示着有一种不纯净的半导体的存在，并且这种不纯净的半导体的存在是十分有必要的。</p>
<h3 id="二极管及其基本电路">二极管及其基本电路</h3>
<p>TODO</p>
<h3 id="三极管及其基本电路">三极管及其基本电路</h3>
<p>TODO</p>
<h3 id="场效应管及其基本电路">场效应管及其基本电路</h3>
<p>TODO</p>
<h2 id="模拟电子技术">模拟电子技术</h2>
<p>TODO</p>
<h2 id="数字电子技术">数字电子技术</h2>
<p>TODO</p>
<h2 id="运算放大器电路">运算放大器电路</h2>
<p>分析顺序</p>
<ul>
<li>图像</li>
<li>公式</li>
<li>结论</li>
</ul>
<ol type="1">
<li><p>反相放大电路</p>
<ul>
<li><p>反相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1249-16473232199221.PNG" alt="IMG_1249" style="zoom: 25%;"></p></li>
<li><p>反相放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p>假设运算放大器是理想的，即</p>
<ul>
<li>开环增益 <span class="math inline">\(A_{od}=\infty\)</span>：故输入信号 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是相等的。且由于 <span class="math inline">\(v_2\)</span> 与地面连接，故 <span class="math inline">\(v_2\)</span> 是“接地”，而 <span class="math inline">\(v_1\)</span> 是“虚地”。</li>
<li>输入阻抗大小为 <span class="math inline">\(\infty\)</span>：流入运算放大器的电流为 <span class="math inline">\(0\)</span> 。</li>
</ul>
<p>理想运放约束+基尔霍夫定律可得： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{v_{i_1}-v_1}{R_1}=\frac{v_1-v_o}{R_2}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<ul>
<li>对于理想运放，闭环电压增益是运放外电阻比值的函数，与运放内部的参数无关。</li>
<li>增益中的负号表示 “反相” ，是反相放大电路名字的由来。</li>
<li>反相放大电路中没有耦合电容（就是电容，作用是耦合所以叫耦合电容），因此反相放大电路可以放大直流电压信号。</li>
</ul></li>
</ul></li>
<li><p>反相放大电路扩展——带 T 型网络的放大电路</p>
<ul>
<li><p>作为改进方案被提出的原因：</p>
<p>反相放大电路的增益 <span class="math inline">\(A_v\)</span> 为 <span class="math inline">\(-\frac{R_2}{R_1}\)</span>，那么如果我们的设计目标是设计一个闭环增益 <span class="math inline">\(A_v=-100\)</span> 且输入电阻 <span class="math inline">\(R_i=R_1=50k\Omega\)</span> 的反相放大电路。于是，反馈电阻 <span class="math inline">\(R_2\)</span> 就必须是 <span class="math inline">\(5M\Omega\)</span>。然而，这个电阻值对大多数实际电路来说太大了。为了解决这个问题我们提出了作为改进方案的带 T 型网络的放大电路。</p></li>
<li><p>带 T 型网络的放大电路的电路图如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1258.PNG" alt="IMG_1258" style="zoom:25%;"></p></li>
<li><p>设 <span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span> 和 <span class="math inline">\(R_4\)</span> 三个电阻的公共节点处电势为 <span class="math inline">\(v_x\)</span>，则: <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;i_2+i_3=i_4\\\\
&amp;\frac{v_1-v_x}{R_2}+\frac{v_x-v_o}{R_3}=\frac{v_x}{R_4}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<p>使用带 T 型网络的放大电路，可以在使用合理大小电阻的情况下获得更大的增益。</p></li>
</ul></li>
<li><p>同相放大电路；</p>
<ul>
<li><p>同相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1253-16473270320863.PNG" alt="IMG_1253" style="zoom: 25%;"></p></li>
<li><p>同相放大电路增益 <span class="math inline">\(A_v=\frac{R_2}{R_1}+1\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\begin{cases}
v_-=v_+=v_i\\\\
\frac{0-v_-}{R1}=\frac{v_--v_o}{R_2}\\
\end{cases}\\\\
&amp;get\quad A_v=\frac{v_o}{v_i}=\frac{R_2}{R_1}+1
\end{aligned}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>电压跟随器：</p>
<ul>
<li><p>电压跟随器连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1246.PNG" alt="IMG_1246" style="zoom:25%;"></p></li>
<li><p>电压跟随器增益 <span class="math inline">\(A_v\)</span>：</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>求和放大电路：</p>
<ul>
<li><p>求和放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1252.PNG" alt="IMG_1252" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}\)</span>：</p>
<p><span class="math display">\[
\sum_{j=1}^{n}\frac{v_{i_j}-0}{R_i}=\frac{0-v_o}{R_f}\\
get\quad v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>差分放大电路：</p>
<ul>
<li><p>差分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1244.PNG" alt="IMG_1244" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})\)</span>：</p>
<p>$$</p>
<span class="math display">\[\begin{aligned}
&amp;if\quad v_{i_2}=0,\;v_{i_1}\not=0\\

&amp;then\quad v_{o_1}=-\frac{R_2}{R_1}v_{i_1}\\\\\\

&amp;if\quad v_{i_2}\not=0,\;v_{i_1}=0\\

&amp;then\quad v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}\\\\\\

&amp;so\quad v_o=v_{o_1}+v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}-\frac{R_2}{R_1}v_{i_1}\\

&amp;To\quad satified\quad when\quad v_{i_1}=v_{i_2},v_o=0\,;so\quad \frac{R_4}{R_3}=\frac{R_2}{R_1}\\

&amp;Finally\quad v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})
\end{aligned}\]</span>
<p>$$</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>积分放大电路：</p>
<ul>
<li><p>积分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1254.PNG" alt="IMG_1254" style="zoom:25%;"></p></li>
<li><p>积分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=V_C-\frac{1}{RC}\int_{0}^{t}v_i(\tau)d\tau
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>微分放大电路：</p>
<ul>
<li><p>微分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1251.PNG" alt="IMG_1251" style="zoom:25%;"></p></li>
<li><p>微分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-RC\frac{dv_{i}}{dt}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>对数放大电路：</p>
<ul>
<li><p>对数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1247.PNG" alt="IMG_1247" style="zoom:25%;"></p></li>
<li><p>对数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-V_Tln\left(\frac{v_i}{I_SR_1}\right)
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>指数放大电路：</p>
<ul>
<li><p>指数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1257.PNG" alt="IMG_1257" style="zoom:25%;"></p></li>
<li><p>指数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-I_SR\cdot e^{v_i/V_T}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>仪用放大电路：</p>
<ul>
<li><p>仪用放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1256.PNG" alt="IMG_1256" style="zoom:25%;"></p></li>
<li><p>仪用放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=\frac{R_4}{R_3}\left(1+\frac{2R_2}{R_1}\right)(v_{i_2}-v_{i_1})
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
</ol>
<h2 id="集成电路偏置">集成电路偏置</h2>
<p>使用分立电子元器件对晶体管放大电路进行偏置时，我们通常使用的是分压电阻网络。在集成电路设计中，电阻的集成需要比晶体管更大的面积，因此我们更希望通过晶体管来配置放大电路。在接下来的设计中我们可以看到，晶体管可以构成恒流源和负载器件。</p>
<p>集成电路偏置和有源负载这一章节学习了在设计集成电路中需要使用到的<strong>晶体管恒流源——镜像电流源（Current Mirror）</strong>和<strong>晶体管电阻（负载）——有源负载</strong></p>
<p>关于集成电路的部分放到下一阶段学习吧</p>
<p>一个设计良好的电流源电路，必须同时满足如下这四点要求：</p>
<ul>
<li>能够输出符合要求的直流电流；</li>
<li>温度稳定性更好；</li>
<li>受到电源电压等因素的影响较小；</li>
<li>输出电阻要尽可能更大；</li>
</ul>
<p>如果一个电流源能够同时满足上述这些要求，那么就可以将其等效为下面的<strong>理想电流源</strong>：<img src="/2022/02/27/16-41-33/image-20220316212039647-16474368536751.png" alt="image-20220316212039647" style="zoom:25%;"></p>
<p>晶体管和场效应管等有源元件，在放大区的输出电流几乎不受输出电压的影响，展现出恒流特性：</p>
<h2 id="差分和多级放大电路">差分和多级放大电路</h2>
<p>本章介绍的是主要内容是一种多晶体管电路——差分放大电路。与之前理想运放一节不同的是，这里的差分放大电路是由基本的晶体管构成的电路</p>
<p>差分放大电路是模拟电路的基本单元，既是几乎所有运放的输入级，也是高速数字逻辑电路的基础。</p>
<p>差分放大电路为</p>
<h2 id="section"></h2>
<h3 id="施密特触发器">施密特触发器</h3>
<h4 id="比较器">比较器</h4>
<h4 id="施密特触发器-1">施密特触发器</h4>
<h1 id="放大电路">放大电路</h1>
<h2 id="基本放大电路的构成">基本放大电路的构成</h2>
<p>设计一个放大电路：</p>
<ol type="1">
<li><p>放大的概念：</p>
<p>放大电路的放大是指对于功率的放大，即小电流电压输入转化为一个大电流电压输出</p></li>
<li><p>本质：</p>
<p>功率放大的本质在于对能量的控制。</p>
<p>为了首先对能量的控制，我们必须在电路中引入一个控制能力的元件——有源元件，具体来说就是三极管和场效应管等。</p></li>
<li><p>前提：</p>
<p>合理放大信号的前提是不失真</p></li>
<li><p>测试：</p>
<p>在实验中我们使用正弦波进行信号放大的测试。</p>
<p>因为声波或其他各种波形，由傅里叶变换可以变换成多个正弦波的叠加，故只要电路系统可以正常的放大分解后的所有正弦波，就可以实现具体的设计目标。</p>
<p>因此在实验中我们使用正弦波进行放大的测试</p></li>
<li><p>放大电路的构建方法：</p>
<ol type="1">
<li>目标：小功率转化为大功率
<ul>
<li>小信号：小的什么程度：几毫伏或几十个毫伏</li>
</ul></li>
<li>条件：
<ul>
<li>有源元件</li>
<li>能量</li>
</ul></li>
<li>技术路线：
<ul>
<li>三极管工作在放大状态下——即 <span class="math inline">\(i_b\)</span> 可以控制 <span class="math inline">\(i_c\)</span></li>
<li>小信号控制 <span class="math inline">\(i_b\)</span></li>
<li>合理的输出</li>
</ul></li>
<li></li>
</ol></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><p><span class="math display">\[
V_i（一个小信号输出电压）-&gt;放大电路-&gt;实现功率放大
\]</span></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="page-number" href="/default-index/page/3/">3</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邱金羽</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"Bolgqjy","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
